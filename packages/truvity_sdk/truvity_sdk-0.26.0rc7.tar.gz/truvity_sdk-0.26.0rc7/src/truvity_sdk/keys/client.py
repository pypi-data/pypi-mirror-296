# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pydantic_utilities import parse_obj_as
from ..core.request_options import RequestOptions
from ..errors.bad_request_error import BadRequestError
from ..errors.forbidden_error import ForbiddenError
from ..errors.internal_server_error import InternalServerError
from ..errors.method_not_allowed_error import MethodNotAllowedError
from ..errors.not_found_error import NotFoundError
from ..errors.precondition_failed_error import PreconditionFailedError
from ..errors.unauthorized_error import UnauthorizedError
from ..errors.unsupported_media_type_error import UnsupportedMediaTypeError
from ..types.annotations import Annotations
from ..types.bad_request_error_body import BadRequestErrorBody
from ..types.credential_unsigned import CredentialUnsigned
from ..types.did_method import DidMethod
from ..types.key_filter import KeyFilter
from ..types.key_generate import KeyGenerate
from ..types.key_import_secret import KeyImportSecret
from ..types.key_list import KeyList
from ..types.key_resource import KeyResource
from ..types.key_sort import KeySort
from ..types.labels import Labels
from ..types.presentation_unsigned import PresentationUnsigned
from ..types.problem_conflict_resource import ProblemConflictResource
from ..types.problem_forbidden import ProblemForbidden
from ..types.problem_internal_server_error import ProblemInternalServerError
from ..types.problem_unauthorized import ProblemUnauthorized
from ..types.problem_unsupported_media_type import ProblemUnsupportedMediaType
from ..types.resource_id import ResourceId
from ..types.revision import Revision

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class KeysClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def key_generate(
        self,
        *,
        data: KeyGenerate,
        idempotency_key: typing.Optional[str] = None,
        annotations: typing.Optional[Annotations] = OMIT,
        labels: typing.Optional[Labels] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> KeyResource:
        """
        Generate key's resource.

        You could use KeyGenerate, if you want to rely to generated by Truvity key-pairs for CredentialIssue and PresentationIssue.
        Remember, that you do not have any option to get private key by Truvity API, you could only use it

        | Truvity   | JWX - KeyType | JWX - Curve | FIPS  | SEC2      | OpenSSL    | AWS KMS         |
        | --------- | ------------- | ----------- | ----- | --------- | ---------- | --------------- |
        | ED25519   | OKP           | Ed25519     |       |           | ed25519    |                 |
        | P256      | EC            | P-256       | P-256 | secp256r1 | prime256v1 | ECC_NIST_P256   |
        | P384      | EC            | P-384       | P-384 | secp384r1 | secp384r1  | ECC_NIST_P384   |
        | SECP256K1 | EC            | secp256k1   |       | secp256k1 | secp256k1  | ECC_SECG_P256K1 |

        Useful third-party documentation:

        - [openssl-genrsa - generate an RSA private key](https://www.openssl.org/docs/manmaster/man1/openssl-genpkey.html).
        - [openssl-ec, ec - EC key processing](https://www.openssl.org/docs/man1.0.2/man1/ec.html)
        - [openssl-genrsa - generate an RSA private key](https://www.openssl.org/docs/man3.0/man1/openssl-genrsa.html)
        - [openssl-pkcs8 - PKCS#8 format private key conversion command](https://www.openssl.org/docs/manmaster/man1/openssl-pkcs8.html)
        - [JWX - github.com/lestrrat-go/jwx](https://github.com/lestrrat-go/jwx/blob/main/cmd/jwx/README.md)
        - [FIPS 186-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf).
        - [SEC2](https://www.secg.org/sec2-v2.pdf).
        - [AWS KMS - Asymmetric key specs](https://docs.aws.amazon.com/kms/latest/developerguide/asymmetric-key-specs.html)
          .

        Parameters
        ----------
        data : KeyGenerate

        idempotency_key : typing.Optional[str]
            From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
            The **Idempotency-Key** is a free identifier created by the client to
            identify a request. It is used by the service to identify repeated request
            to ensure idempotent behavior by sending the same (or a similar) response
            without executing the request a second time.

            Clients should be careful as any subsequent requests with the same key may
            return the same response without further check. Thus, it is recommended to
            use a UUID version 4 (random) or any other random string with enough
            entropy to avoid collisions.

            Keys expire after 24 hours. Clients are responsible to stay within this
            limit, if they require idempotent behavior.

            See [API Guideline Rule #181][api-230] for further details.

            [api-230]: <https://opensource.zalando.com/restful-api-guidelines/#230>.

        annotations : typing.Optional[Annotations]

        labels : typing.Optional[Labels]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        KeyResource
            Result of key's resource Create or Update or Restore.

        Examples
        --------
        from truvity_sdk import KeyGenerate, TruvityApi

        client = TruvityApi(
            api_key="YOUR_API_KEY",
        )
        client.keys.key_generate(
            idempotency_key="7da7a728-f910-11e6-942a-68f728c1ba70",
            data=KeyGenerate(),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "keys/generate",
            method="POST",
            json={"data": data, "annotations": annotations, "labels": labels},
            headers={"Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(KeyResource, parse_obj_as(type_=KeyResource, object_=_response.json()))  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(BadRequestErrorBody, parse_obj_as(type_=BadRequestErrorBody, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(ProblemUnauthorized, parse_obj_as(type_=ProblemUnauthorized, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(ProblemForbidden, parse_obj_as(type_=ProblemForbidden, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    typing.cast(ProblemUnsupportedMediaType, parse_obj_as(type_=ProblemUnsupportedMediaType, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(ProblemInternalServerError, parse_obj_as(type_=ProblemInternalServerError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def key_import(
        self,
        *,
        data: KeyImportSecret,
        idempotency_key: typing.Optional[str] = None,
        annotations: typing.Optional[Annotations] = OMIT,
        labels: typing.Optional[Labels] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> KeyResource:
        """
        Import key's resource.

        You could use KeyGenerate, if you want to rely to generated by Truvity key-pairs for CredentialIssue and PresentationIssue.
        Remember, that you do not have any option to get private key by Truvity API, you could only use it

        If you prefer to keep private key, then you need to generate it manually.
        To use manually generated key CredentialIssue and PresentationIssue you need to import it.

        To generate key-pair you have two options

        1. OpenSSL - [OpenSSL commands](https://www.openssl.org/docs/man1.1.1/man1/index.html)
        2. JWX tool - [https://github.com/lestrrat-go/jwx/blob/main/cmd/jwx/README.md](https://github.com/lestrrat-go/jwx/blob/main/cmd/jwx/README.md)

        How to install JWX

        1. Download & Install Golang - [https://go.dev/doc/install](https://go.dev/doc/install)
        2. Clone & Build & Install [github.com/lestrrat-go/jwx](https://github.com/lestrrat-go/jwx)
           ```bash
           git clone https://github.com/lestrrat-go/jwx
           cd jwx/cmd/jwx
           go install -tags=jwx_es256k,jwx_secp256k1_pem .
           ```
        3. Verify that you correctly install everything

           ```bash
           ➜ jwx --help
           NAME:
                jwx - Tools for various JWE/JWK/JWS/JWT operations

            USAGE:
                jwx [global options] command [command options] [arguments...]

            COMMANDS:
                jwa      List available algorithms and types
                jwe      Work with JWE messages
                jwk      Work with JWK and JWK sets
                jws      Work with JWS messages
                help, h  Shows a list of commands or help for one command

            GLOBAL OPTIONS:
                --help, -h  show help
           ```

        How generate private key by `jwx` (output format JWK)

        ```bash
        # ED25519
        jwx jwx generate --type OKP --curve Ed25519
        # P256
        jwx jwx generate --type EC --curve P-256
        # P384
        jwx jwx generate --type EC --curve P-384
        # SECP256K1
        jwx jwx generate --type EC --curve secp256k1
        ```

        How to generate public key from private key by `jwx` (input format - JWK, output format - JWK)

        ```bash
        jwx jwk format -I json -O json - <(pathfile with private key in JWK format)
        ```

        How to generate private key by OpenSSL (output format PEM - PKCS#8)

        ```bash
        # ED25519
        openssl genpkey -algorithm ed25519 | openssl pkcs8 -nocrypt -topk8
        # P256
        openssl ecparam -name prime256v1 -noout -genkey | openssl pkcs8 -nocrypt -topk8
        # P384
        openssl ecparam -name secp384r1 -noout -genkey | openssl pkcs8 -nocrypt -topk8
        # SECP256K1
        openssl ecparam -name secp256k1 -noout -genkey | openssl pkcs8 -nocrypt -topk8
        ```

        How to transform existing private key to PKCS8 format by OpenSSL (input format PEM, output format - PEM PCKS#8)

        ```bash
        openssl pkcs8 -nocrypt -topk8 <(pathfile with private key in PEM format)
        ```

        How to transform private key to public key by OpenSSL (input format PEM, output format - PEM PKIX)

        ```bash
        openssl pkey -pubout <(pathfile with private key in PKCS8 format)
        ```

        Useful third-party documentation:

        - [openssl-genrsa - generate an RSA private key](https://www.openssl.org/docs/manmaster/man1/openssl-genpkey.html).
        - [openssl-ec, ec - EC key processing](https://www.openssl.org/docs/man1.0.2/man1/ec.html)
        - [openssl-genrsa - generate an RSA private key](https://www.openssl.org/docs/man3.0/man1/openssl-genrsa.html)
        - [openssl-pkcs8 - PKCS#8 format private key conversion command](https://www.openssl.org/docs/manmaster/man1/openssl-pkcs8.html)
        - [JWX - github.com/lestrrat-go/jwx](https://github.com/lestrrat-go/jwx/blob/main/cmd/jwx/README.md)
        - [FIPS 186-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf).
        - [SEC2](https://www.secg.org/sec2-v2.pdf).
        - [AWS KMS - Asymmetric key specs](https://docs.aws.amazon.com/kms/latest/developerguide/asymmetric-key-specs.html)
          .

        Parameters
        ----------
        data : KeyImportSecret

        idempotency_key : typing.Optional[str]
            From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
            The **Idempotency-Key** is a free identifier created by the client to
            identify a request. It is used by the service to identify repeated request
            to ensure idempotent behavior by sending the same (or a similar) response
            without executing the request a second time.

            Clients should be careful as any subsequent requests with the same key may
            return the same response without further check. Thus, it is recommended to
            use a UUID version 4 (random) or any other random string with enough
            entropy to avoid collisions.

            Keys expire after 24 hours. Clients are responsible to stay within this
            limit, if they require idempotent behavior.

            See [API Guideline Rule #181][api-230] for further details.

            [api-230]: <https://opensource.zalando.com/restful-api-guidelines/#230>.

        annotations : typing.Optional[Annotations]

        labels : typing.Optional[Labels]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        KeyResource
            Result of key's resource Create or Update or Restore.

        Examples
        --------
        from truvity_sdk import TruvityApi

        client = TruvityApi(
            api_key="YOUR_API_KEY",
        )
        client.keys.key_import(
            idempotency_key="7da7a728-f910-11e6-942a-68f728c1ba70",
            data="data",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "keys/import",
            method="POST",
            json={"data": data, "annotations": annotations, "labels": labels},
            headers={"Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(KeyResource, parse_obj_as(type_=KeyResource, object_=_response.json()))  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(BadRequestErrorBody, parse_obj_as(type_=BadRequestErrorBody, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(ProblemUnauthorized, parse_obj_as(type_=ProblemUnauthorized, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(ProblemForbidden, parse_obj_as(type_=ProblemForbidden, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    typing.cast(ProblemUnsupportedMediaType, parse_obj_as(type_=ProblemUnsupportedMediaType, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(ProblemInternalServerError, parse_obj_as(type_=ProblemInternalServerError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def key_search(
        self,
        *,
        filter: typing.Optional[typing.Sequence[KeyFilter]] = OMIT,
        sort: typing.Optional[typing.Sequence[KeySort]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> KeyList:
        """
        Take a look at [GET with body payload](https://opensource.zalando.com/restful-api-guidelines/#get-with-body)

        - no resources created: Returns all keys matching the query passed as request input payload.

        Parameters
        ----------
        filter : typing.Optional[typing.Sequence[KeyFilter]]
            Filter for the keys' resources.

        sort : typing.Optional[typing.Sequence[KeySort]]
            Sort of the keys' resources.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        KeyList
            Result of search of the keys' resources.

        Examples
        --------
        from truvity_sdk import TruvityApi

        client = TruvityApi(
            api_key="YOUR_API_KEY",
        )
        client.keys.key_search()
        """
        _response = self._client_wrapper.httpx_client.request(
            "keys/search",
            method="POST",
            json={"filter": filter, "sort": sort},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(KeyList, parse_obj_as(type_=KeyList, object_=_response.json()))  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(BadRequestErrorBody, parse_obj_as(type_=BadRequestErrorBody, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(ProblemUnauthorized, parse_obj_as(type_=ProblemUnauthorized, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(ProblemForbidden, parse_obj_as(type_=ProblemForbidden, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    typing.cast(ProblemUnsupportedMediaType, parse_obj_as(type_=ProblemUnsupportedMediaType, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(ProblemInternalServerError, parse_obj_as(type_=ProblemInternalServerError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def key_latest(
        self,
        id: ResourceId,
        *,
        if_none_match: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> KeyResource:
        """
        Read the latest revision of the key's resource.

        Parameters
        ----------
        id : ResourceId
            Take a look to documentation about #/components/schemas/ResourceID.

        if_none_match : typing.Optional[str]
            From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
            The **If-None-Match header** field is used to declare a list of identifiers
            that are required to fail matching all the current resource version
            identifiers as a pre-condition for executing the request on the server
            side. This is especially used in conjunction with an **\*** (asterix) that
            is matching all possible resource identifiers to ensure the initial
            creation of a resource. Other use cases are possible but rare.

            If the pre-condition fails the server will respond with status code **412**
            (Precondition Failed). See [RFC 9110 Section 13.1.2][rfc-9110-13.1.2] as
            well as [API Guideline Rule #182][api-182] for further details.

            [rfc-9110-13.1.2]: https://tools.ietf.org/html/rfc9110#section-13.1.2

            [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        KeyResource
            Result of key's resource Create or Update or Restore.

        Examples
        --------
        from truvity_sdk import TruvityApi

        client = TruvityApi(
            api_key="YOUR_API_KEY",
        )
        client.keys.key_latest(
            id="id",
            if_none_match="5db68c06-1a68-11e9-8341-68f728c1ba70",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"keys/{jsonable_encoder(id)}",
            method="GET",
            headers={"If-None-Match": str(if_none_match) if if_none_match is not None else None},
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(KeyResource, parse_obj_as(type_=KeyResource, object_=_response.json()))  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(BadRequestErrorBody, parse_obj_as(type_=BadRequestErrorBody, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(ProblemUnauthorized, parse_obj_as(type_=ProblemUnauthorized, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(ProblemForbidden, parse_obj_as(type_=ProblemForbidden, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(typing.Any, parse_obj_as(type_=typing.Any, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(ProblemInternalServerError, parse_obj_as(type_=ProblemInternalServerError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def key_delete(
        self,
        id: ResourceId,
        *,
        if_match: str,
        idempotency_key: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Delete key's resource.

        Parameters
        ----------
        id : ResourceId
            Take a look to documentation about #/components/schemas/ResourceID.

        if_match : str
            From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
            The **If-Match** header field is used to declare a list of identifiers that
            are required to match the current resource version identifier in at least
            one position as a pre-condition for executing the request on the server
            side. This behavior is used to validate and reject optimistic updates, by
            checking if the resource version a consumer has based his changes on is
            outdated on arrival of the change request to prevent lost updates.

            If the pre-condition fails the server will respond with status code **412**
            (Precondition Failed). See [RFC 9110 Section 13.1.1][rfc-9110-13.1.1] as
            well as [API Guideline Rule #182][api-182] for further details.

            [rfc-9110-13.1.1]: https://tools.ietf.org/html/rfc9110#section-13.1.1

            [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.

        idempotency_key : typing.Optional[str]
            From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
            The **Idempotency-Key** is a free identifier created by the client to
            identify a request. It is used by the service to identify repeated request
            to ensure idempotent behavior by sending the same (or a similar) response
            without executing the request a second time.

            Clients should be careful as any subsequent requests with the same key may
            return the same response without further check. Thus, it is recommended to
            use a UUID version 4 (random) or any other random string with enough
            entropy to avoid collisions.

            Keys expire after 24 hours. Clients are responsible to stay within this
            limit, if they require idempotent behavior.

            See [API Guideline Rule #181][api-230] for further details.

            [api-230]: <https://opensource.zalando.com/restful-api-guidelines/#230>.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from truvity_sdk import TruvityApi

        client = TruvityApi(
            api_key="YOUR_API_KEY",
        )
        client.keys.key_delete(
            id="id",
            idempotency_key="7da7a728-f910-11e6-942a-68f728c1ba70",
            if_match="5db68c06-1a68-11e9-8341-68f728c1ba70",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"keys/{jsonable_encoder(id)}",
            method="DELETE",
            headers={
                "Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None,
                "If-Match": str(if_match) if if_match is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(BadRequestErrorBody, parse_obj_as(type_=BadRequestErrorBody, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(ProblemUnauthorized, parse_obj_as(type_=ProblemUnauthorized, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(ProblemForbidden, parse_obj_as(type_=ProblemForbidden, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(typing.Any, parse_obj_as(type_=typing.Any, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    typing.cast(typing.Any, parse_obj_as(type_=typing.Any, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 412:
                raise PreconditionFailedError(
                    typing.cast(ProblemConflictResource, parse_obj_as(type_=ProblemConflictResource, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(ProblemInternalServerError, parse_obj_as(type_=ProblemInternalServerError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def key_update(
        self,
        id: ResourceId,
        *,
        if_match: str,
        idempotency_key: typing.Optional[str] = None,
        annotations: typing.Optional[Annotations] = OMIT,
        labels: typing.Optional[Labels] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> KeyResource:
        """
        Update key's resource.

        Parameters
        ----------
        id : ResourceId
            Take a look to documentation about #/components/schemas/ResourceID.

        if_match : str
            From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
            The **If-Match** header field is used to declare a list of identifiers that
            are required to match the current resource version identifier in at least
            one position as a pre-condition for executing the request on the server
            side. This behavior is used to validate and reject optimistic updates, by
            checking if the resource version a consumer has based his changes on is
            outdated on arrival of the change request to prevent lost updates.

            If the pre-condition fails the server will respond with status code **412**
            (Precondition Failed). See [RFC 9110 Section 13.1.1][rfc-9110-13.1.1] as
            well as [API Guideline Rule #182][api-182] for further details.

            [rfc-9110-13.1.1]: https://tools.ietf.org/html/rfc9110#section-13.1.1

            [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.

        idempotency_key : typing.Optional[str]
            From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
            The **Idempotency-Key** is a free identifier created by the client to
            identify a request. It is used by the service to identify repeated request
            to ensure idempotent behavior by sending the same (or a similar) response
            without executing the request a second time.

            Clients should be careful as any subsequent requests with the same key may
            return the same response without further check. Thus, it is recommended to
            use a UUID version 4 (random) or any other random string with enough
            entropy to avoid collisions.

            Keys expire after 24 hours. Clients are responsible to stay within this
            limit, if they require idempotent behavior.

            See [API Guideline Rule #181][api-230] for further details.

            [api-230]: <https://opensource.zalando.com/restful-api-guidelines/#230>.

        annotations : typing.Optional[Annotations]

        labels : typing.Optional[Labels]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        KeyResource
            Result of key's resource Create or Update or Restore.

        Examples
        --------
        from truvity_sdk import TruvityApi

        client = TruvityApi(
            api_key="YOUR_API_KEY",
        )
        client.keys.key_update(
            id="id",
            idempotency_key="7da7a728-f910-11e6-942a-68f728c1ba70",
            if_match="5db68c06-1a68-11e9-8341-68f728c1ba70",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"keys/{jsonable_encoder(id)}",
            method="PATCH",
            json={"annotations": annotations, "labels": labels},
            headers={
                "Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None,
                "If-Match": str(if_match) if if_match is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(KeyResource, parse_obj_as(type_=KeyResource, object_=_response.json()))  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(BadRequestErrorBody, parse_obj_as(type_=BadRequestErrorBody, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(ProblemUnauthorized, parse_obj_as(type_=ProblemUnauthorized, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(ProblemForbidden, parse_obj_as(type_=ProblemForbidden, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(typing.Any, parse_obj_as(type_=typing.Any, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    typing.cast(typing.Any, parse_obj_as(type_=typing.Any, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 412:
                raise PreconditionFailedError(
                    typing.cast(ProblemConflictResource, parse_obj_as(type_=ProblemConflictResource, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    typing.cast(ProblemUnsupportedMediaType, parse_obj_as(type_=ProblemUnsupportedMediaType, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(ProblemInternalServerError, parse_obj_as(type_=ProblemInternalServerError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def credential_sign(
        self,
        id: ResourceId,
        *,
        request: CredentialUnsigned,
        did_method: typing.Optional[DidMethod] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Iterator[bytes]:
        """
        Sign a JSON-LD representation of an unsigned credential.

        Parameters
        ----------
        id : ResourceId
            Take a look to documentation about #/components/schemas/ResourceID.

        request : CredentialUnsigned

        did_method : typing.Optional[DidMethod]
            All supported DID methods. Default value: web.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Yields
        ------
        typing.Iterator[bytes]
            Result of a credential signing.

        Examples
        --------
        from truvity_sdk import TruvityApi

        client = TruvityApi(
            api_key="YOUR_API_KEY",
        )
        client.keys.credential_sign(
            id="string",
            did_method="key",
            request="string",
        )
        """
        with self._client_wrapper.httpx_client.stream(
            f"keys/{jsonable_encoder(id)}/credentials/sign",
            method="POST",
            params={"did_method": did_method},
            json=request,
            request_options=request_options,
            omit=OMIT,
        ) as _response:
            try:
                if 200 <= _response.status_code < 300:
                    for _chunk in _response.iter_bytes():
                        yield _chunk
                    return
                _response.read()
                if _response.status_code == 400:
                    raise BadRequestError(
                        typing.cast(BadRequestErrorBody, parse_obj_as(type_=BadRequestErrorBody, object_=_response.json()))  # type: ignore
                    )
                if _response.status_code == 401:
                    raise UnauthorizedError(
                        typing.cast(ProblemUnauthorized, parse_obj_as(type_=ProblemUnauthorized, object_=_response.json()))  # type: ignore
                    )
                if _response.status_code == 403:
                    raise ForbiddenError(
                        typing.cast(ProblemForbidden, parse_obj_as(type_=ProblemForbidden, object_=_response.json()))  # type: ignore
                    )
                if _response.status_code == 404:
                    raise NotFoundError(
                        typing.cast(typing.Any, parse_obj_as(type_=typing.Any, object_=_response.json()))  # type: ignore
                    )
                if _response.status_code == 500:
                    raise InternalServerError(
                        typing.cast(ProblemInternalServerError, parse_obj_as(type_=ProblemInternalServerError, object_=_response.json()))  # type: ignore
                    )
                _response_json = _response.json()
            except JSONDecodeError:
                raise ApiError(status_code=_response.status_code, body=_response.text)
            raise ApiError(status_code=_response.status_code, body=_response_json)

    def didcomm_message_sign(
        self,
        id: ResourceId,
        *,
        request: str,
        did_method: typing.Optional[DidMethod] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Iterator[bytes]:
        """
        Sign DIDCOMM Message Plaintext.

        Parameters
        ----------
        id : ResourceId
            Take a look to documentation about #/components/schemas/ResourceID.

        request : str

        did_method : typing.Optional[DidMethod]
            All supported DID methods. Default value: web.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Yields
        ------
        typing.Iterator[bytes]
            DIDCOMM Signed Message according to [DIDComm Messaging v2.x Editor’s Draft](https://identity.foundation/didcomm-messaging/spec).

        Examples
        --------
        from truvity_sdk import TruvityApi

        client = TruvityApi(
            api_key="YOUR_API_KEY",
        )
        client.keys.didcomm_message_sign(
            id="string",
            did_method="key",
            request="string",
        )
        """
        with self._client_wrapper.httpx_client.stream(
            f"keys/{jsonable_encoder(id)}/didcomm-messages/sign",
            method="POST",
            params={"did_method": did_method},
            json=request,
            request_options=request_options,
            omit=OMIT,
        ) as _response:
            try:
                if 200 <= _response.status_code < 300:
                    for _chunk in _response.iter_bytes():
                        yield _chunk
                    return
                _response.read()
                if _response.status_code == 400:
                    raise BadRequestError(
                        typing.cast(BadRequestErrorBody, parse_obj_as(type_=BadRequestErrorBody, object_=_response.json()))  # type: ignore
                    )
                if _response.status_code == 401:
                    raise UnauthorizedError(
                        typing.cast(ProblemUnauthorized, parse_obj_as(type_=ProblemUnauthorized, object_=_response.json()))  # type: ignore
                    )
                if _response.status_code == 403:
                    raise ForbiddenError(
                        typing.cast(ProblemForbidden, parse_obj_as(type_=ProblemForbidden, object_=_response.json()))  # type: ignore
                    )
                if _response.status_code == 404:
                    raise NotFoundError(
                        typing.cast(typing.Any, parse_obj_as(type_=typing.Any, object_=_response.json()))  # type: ignore
                    )
                if _response.status_code == 500:
                    raise InternalServerError(
                        typing.cast(ProblemInternalServerError, parse_obj_as(type_=ProblemInternalServerError, object_=_response.json()))  # type: ignore
                    )
                _response_json = _response.json()
            except JSONDecodeError:
                raise ApiError(status_code=_response.status_code, body=_response.text)
            raise ApiError(status_code=_response.status_code, body=_response_json)

    def presentation_sign(
        self,
        id: ResourceId,
        *,
        request: PresentationUnsigned,
        did_method: typing.Optional[DidMethod] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Iterator[bytes]:
        """
        Sign a JSON-LD representation of an unsigned presentation.

        Parameters
        ----------
        id : ResourceId
            Take a look to documentation about #/components/schemas/ResourceID.

        request : PresentationUnsigned

        did_method : typing.Optional[DidMethod]
            All supported DID methods. Default value: web.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Yields
        ------
        typing.Iterator[bytes]
            Result of a presentation signing.

        Examples
        --------
        from truvity_sdk import TruvityApi

        client = TruvityApi(
            api_key="YOUR_API_KEY",
        )
        client.keys.presentation_sign(
            id="string",
            did_method="key",
            request="string",
        )
        """
        with self._client_wrapper.httpx_client.stream(
            f"keys/{jsonable_encoder(id)}/presentations/sign",
            method="POST",
            params={"did_method": did_method},
            json=request,
            request_options=request_options,
            omit=OMIT,
        ) as _response:
            try:
                if 200 <= _response.status_code < 300:
                    for _chunk in _response.iter_bytes():
                        yield _chunk
                    return
                _response.read()
                if _response.status_code == 400:
                    raise BadRequestError(
                        typing.cast(BadRequestErrorBody, parse_obj_as(type_=BadRequestErrorBody, object_=_response.json()))  # type: ignore
                    )
                if _response.status_code == 401:
                    raise UnauthorizedError(
                        typing.cast(ProblemUnauthorized, parse_obj_as(type_=ProblemUnauthorized, object_=_response.json()))  # type: ignore
                    )
                if _response.status_code == 403:
                    raise ForbiddenError(
                        typing.cast(ProblemForbidden, parse_obj_as(type_=ProblemForbidden, object_=_response.json()))  # type: ignore
                    )
                if _response.status_code == 404:
                    raise NotFoundError(
                        typing.cast(typing.Any, parse_obj_as(type_=typing.Any, object_=_response.json()))  # type: ignore
                    )
                if _response.status_code == 500:
                    raise InternalServerError(
                        typing.cast(ProblemInternalServerError, parse_obj_as(type_=ProblemInternalServerError, object_=_response.json()))  # type: ignore
                    )
                _response_json = _response.json()
            except JSONDecodeError:
                raise ApiError(status_code=_response.status_code, body=_response.text)
            raise ApiError(status_code=_response.status_code, body=_response_json)

    def key_restore(
        self,
        id: ResourceId,
        *,
        if_match: str,
        idempotency_key: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> KeyResource:
        """
        Restore key's resource.

        Parameters
        ----------
        id : ResourceId
            Take a look to documentation about #/components/schemas/ResourceID.

        if_match : str
            From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
            The **If-Match** header field is used to declare a list of identifiers that
            are required to match the current resource version identifier in at least
            one position as a pre-condition for executing the request on the server
            side. This behavior is used to validate and reject optimistic updates, by
            checking if the resource version a consumer has based his changes on is
            outdated on arrival of the change request to prevent lost updates.

            If the pre-condition fails the server will respond with status code **412**
            (Precondition Failed). See [RFC 9110 Section 13.1.1][rfc-9110-13.1.1] as
            well as [API Guideline Rule #182][api-182] for further details.

            [rfc-9110-13.1.1]: https://tools.ietf.org/html/rfc9110#section-13.1.1

            [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.

        idempotency_key : typing.Optional[str]
            From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
            The **Idempotency-Key** is a free identifier created by the client to
            identify a request. It is used by the service to identify repeated request
            to ensure idempotent behavior by sending the same (or a similar) response
            without executing the request a second time.

            Clients should be careful as any subsequent requests with the same key may
            return the same response without further check. Thus, it is recommended to
            use a UUID version 4 (random) or any other random string with enough
            entropy to avoid collisions.

            Keys expire after 24 hours. Clients are responsible to stay within this
            limit, if they require idempotent behavior.

            See [API Guideline Rule #181][api-230] for further details.

            [api-230]: <https://opensource.zalando.com/restful-api-guidelines/#230>.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        KeyResource
            Result of key's resource Create or Update or Restore.

        Examples
        --------
        from truvity_sdk import TruvityApi

        client = TruvityApi(
            api_key="YOUR_API_KEY",
        )
        client.keys.key_restore(
            id="id",
            idempotency_key="7da7a728-f910-11e6-942a-68f728c1ba70",
            if_match="5db68c06-1a68-11e9-8341-68f728c1ba70",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"keys/{jsonable_encoder(id)}/restore",
            method="POST",
            headers={
                "Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None,
                "If-Match": str(if_match) if if_match is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(KeyResource, parse_obj_as(type_=KeyResource, object_=_response.json()))  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(BadRequestErrorBody, parse_obj_as(type_=BadRequestErrorBody, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(ProblemUnauthorized, parse_obj_as(type_=ProblemUnauthorized, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(ProblemForbidden, parse_obj_as(type_=ProblemForbidden, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(typing.Any, parse_obj_as(type_=typing.Any, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    typing.cast(typing.Any, parse_obj_as(type_=typing.Any, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 412:
                raise PreconditionFailedError(
                    typing.cast(ProblemConflictResource, parse_obj_as(type_=ProblemConflictResource, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(ProblemInternalServerError, parse_obj_as(type_=ProblemInternalServerError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def key_history(
        self,
        id: ResourceId,
        *,
        if_none_match: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> KeyList:
        """
        History of the keys' resources.

        Parameters
        ----------
        id : ResourceId
            Take a look to documentation about #/components/schemas/ResourceID.

        if_none_match : typing.Optional[str]
            From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
            The **If-None-Match header** field is used to declare a list of identifiers
            that are required to fail matching all the current resource version
            identifiers as a pre-condition for executing the request on the server
            side. This is especially used in conjunction with an **\*** (asterix) that
            is matching all possible resource identifiers to ensure the initial
            creation of a resource. Other use cases are possible but rare.

            If the pre-condition fails the server will respond with status code **412**
            (Precondition Failed). See [RFC 9110 Section 13.1.2][rfc-9110-13.1.2] as
            well as [API Guideline Rule #182][api-182] for further details.

            [rfc-9110-13.1.2]: https://tools.ietf.org/html/rfc9110#section-13.1.2

            [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        KeyList
            History of the keys' resources.

        Examples
        --------
        from truvity_sdk import TruvityApi

        client = TruvityApi(
            api_key="YOUR_API_KEY",
        )
        client.keys.key_history(
            id="id",
            if_none_match="5db68c06-1a68-11e9-8341-68f728c1ba70",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"keys/{jsonable_encoder(id)}/revisions",
            method="GET",
            headers={"If-None-Match": str(if_none_match) if if_none_match is not None else None},
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(KeyList, parse_obj_as(type_=KeyList, object_=_response.json()))  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(BadRequestErrorBody, parse_obj_as(type_=BadRequestErrorBody, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(ProblemUnauthorized, parse_obj_as(type_=ProblemUnauthorized, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(ProblemForbidden, parse_obj_as(type_=ProblemForbidden, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(typing.Any, parse_obj_as(type_=typing.Any, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(ProblemInternalServerError, parse_obj_as(type_=ProblemInternalServerError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def key_revision(
        self,
        id: ResourceId,
        revision: Revision,
        *,
        if_none_match: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> KeyResource:
        """
        Read the specific version of the key's resource.

        Parameters
        ----------
        id : ResourceId
            Take a look to documentation about #/components/schemas/ResourceID.

        revision : Revision
            We could refer to the specific version of the resource.
            Take a look to documentation about #/components/schemas/Revision.

        if_none_match : typing.Optional[str]
            From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
            The **If-None-Match header** field is used to declare a list of identifiers
            that are required to fail matching all the current resource version
            identifiers as a pre-condition for executing the request on the server
            side. This is especially used in conjunction with an **\*** (asterix) that
            is matching all possible resource identifiers to ensure the initial
            creation of a resource. Other use cases are possible but rare.

            If the pre-condition fails the server will respond with status code **412**
            (Precondition Failed). See [RFC 9110 Section 13.1.2][rfc-9110-13.1.2] as
            well as [API Guideline Rule #182][api-182] for further details.

            [rfc-9110-13.1.2]: https://tools.ietf.org/html/rfc9110#section-13.1.2

            [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        KeyResource
            Result of key's resource Create or Update or Restore.

        Examples
        --------
        from truvity_sdk import TruvityApi

        client = TruvityApi(
            api_key="YOUR_API_KEY",
        )
        client.keys.key_revision(
            id="id",
            revision=1,
            if_none_match="5db68c06-1a68-11e9-8341-68f728c1ba70",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"keys/{jsonable_encoder(id)}/revisions/{jsonable_encoder(revision)}",
            method="GET",
            headers={"If-None-Match": str(if_none_match) if if_none_match is not None else None},
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(KeyResource, parse_obj_as(type_=KeyResource, object_=_response.json()))  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(BadRequestErrorBody, parse_obj_as(type_=BadRequestErrorBody, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(ProblemUnauthorized, parse_obj_as(type_=ProblemUnauthorized, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(ProblemForbidden, parse_obj_as(type_=ProblemForbidden, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(typing.Any, parse_obj_as(type_=typing.Any, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(ProblemInternalServerError, parse_obj_as(type_=ProblemInternalServerError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncKeysClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def key_generate(
        self,
        *,
        data: KeyGenerate,
        idempotency_key: typing.Optional[str] = None,
        annotations: typing.Optional[Annotations] = OMIT,
        labels: typing.Optional[Labels] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> KeyResource:
        """
        Generate key's resource.

        You could use KeyGenerate, if you want to rely to generated by Truvity key-pairs for CredentialIssue and PresentationIssue.
        Remember, that you do not have any option to get private key by Truvity API, you could only use it

        | Truvity   | JWX - KeyType | JWX - Curve | FIPS  | SEC2      | OpenSSL    | AWS KMS         |
        | --------- | ------------- | ----------- | ----- | --------- | ---------- | --------------- |
        | ED25519   | OKP           | Ed25519     |       |           | ed25519    |                 |
        | P256      | EC            | P-256       | P-256 | secp256r1 | prime256v1 | ECC_NIST_P256   |
        | P384      | EC            | P-384       | P-384 | secp384r1 | secp384r1  | ECC_NIST_P384   |
        | SECP256K1 | EC            | secp256k1   |       | secp256k1 | secp256k1  | ECC_SECG_P256K1 |

        Useful third-party documentation:

        - [openssl-genrsa - generate an RSA private key](https://www.openssl.org/docs/manmaster/man1/openssl-genpkey.html).
        - [openssl-ec, ec - EC key processing](https://www.openssl.org/docs/man1.0.2/man1/ec.html)
        - [openssl-genrsa - generate an RSA private key](https://www.openssl.org/docs/man3.0/man1/openssl-genrsa.html)
        - [openssl-pkcs8 - PKCS#8 format private key conversion command](https://www.openssl.org/docs/manmaster/man1/openssl-pkcs8.html)
        - [JWX - github.com/lestrrat-go/jwx](https://github.com/lestrrat-go/jwx/blob/main/cmd/jwx/README.md)
        - [FIPS 186-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf).
        - [SEC2](https://www.secg.org/sec2-v2.pdf).
        - [AWS KMS - Asymmetric key specs](https://docs.aws.amazon.com/kms/latest/developerguide/asymmetric-key-specs.html)
          .

        Parameters
        ----------
        data : KeyGenerate

        idempotency_key : typing.Optional[str]
            From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
            The **Idempotency-Key** is a free identifier created by the client to
            identify a request. It is used by the service to identify repeated request
            to ensure idempotent behavior by sending the same (or a similar) response
            without executing the request a second time.

            Clients should be careful as any subsequent requests with the same key may
            return the same response without further check. Thus, it is recommended to
            use a UUID version 4 (random) or any other random string with enough
            entropy to avoid collisions.

            Keys expire after 24 hours. Clients are responsible to stay within this
            limit, if they require idempotent behavior.

            See [API Guideline Rule #181][api-230] for further details.

            [api-230]: <https://opensource.zalando.com/restful-api-guidelines/#230>.

        annotations : typing.Optional[Annotations]

        labels : typing.Optional[Labels]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        KeyResource
            Result of key's resource Create or Update or Restore.

        Examples
        --------
        import asyncio

        from truvity_sdk import AsyncTruvityApi, KeyGenerate

        client = AsyncTruvityApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.keys.key_generate(
                idempotency_key="7da7a728-f910-11e6-942a-68f728c1ba70",
                data=KeyGenerate(),
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "keys/generate",
            method="POST",
            json={"data": data, "annotations": annotations, "labels": labels},
            headers={"Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(KeyResource, parse_obj_as(type_=KeyResource, object_=_response.json()))  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(BadRequestErrorBody, parse_obj_as(type_=BadRequestErrorBody, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(ProblemUnauthorized, parse_obj_as(type_=ProblemUnauthorized, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(ProblemForbidden, parse_obj_as(type_=ProblemForbidden, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    typing.cast(ProblemUnsupportedMediaType, parse_obj_as(type_=ProblemUnsupportedMediaType, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(ProblemInternalServerError, parse_obj_as(type_=ProblemInternalServerError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def key_import(
        self,
        *,
        data: KeyImportSecret,
        idempotency_key: typing.Optional[str] = None,
        annotations: typing.Optional[Annotations] = OMIT,
        labels: typing.Optional[Labels] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> KeyResource:
        """
        Import key's resource.

        You could use KeyGenerate, if you want to rely to generated by Truvity key-pairs for CredentialIssue and PresentationIssue.
        Remember, that you do not have any option to get private key by Truvity API, you could only use it

        If you prefer to keep private key, then you need to generate it manually.
        To use manually generated key CredentialIssue and PresentationIssue you need to import it.

        To generate key-pair you have two options

        1. OpenSSL - [OpenSSL commands](https://www.openssl.org/docs/man1.1.1/man1/index.html)
        2. JWX tool - [https://github.com/lestrrat-go/jwx/blob/main/cmd/jwx/README.md](https://github.com/lestrrat-go/jwx/blob/main/cmd/jwx/README.md)

        How to install JWX

        1. Download & Install Golang - [https://go.dev/doc/install](https://go.dev/doc/install)
        2. Clone & Build & Install [github.com/lestrrat-go/jwx](https://github.com/lestrrat-go/jwx)
           ```bash
           git clone https://github.com/lestrrat-go/jwx
           cd jwx/cmd/jwx
           go install -tags=jwx_es256k,jwx_secp256k1_pem .
           ```
        3. Verify that you correctly install everything

           ```bash
           ➜ jwx --help
           NAME:
                jwx - Tools for various JWE/JWK/JWS/JWT operations

            USAGE:
                jwx [global options] command [command options] [arguments...]

            COMMANDS:
                jwa      List available algorithms and types
                jwe      Work with JWE messages
                jwk      Work with JWK and JWK sets
                jws      Work with JWS messages
                help, h  Shows a list of commands or help for one command

            GLOBAL OPTIONS:
                --help, -h  show help
           ```

        How generate private key by `jwx` (output format JWK)

        ```bash
        # ED25519
        jwx jwx generate --type OKP --curve Ed25519
        # P256
        jwx jwx generate --type EC --curve P-256
        # P384
        jwx jwx generate --type EC --curve P-384
        # SECP256K1
        jwx jwx generate --type EC --curve secp256k1
        ```

        How to generate public key from private key by `jwx` (input format - JWK, output format - JWK)

        ```bash
        jwx jwk format -I json -O json - <(pathfile with private key in JWK format)
        ```

        How to generate private key by OpenSSL (output format PEM - PKCS#8)

        ```bash
        # ED25519
        openssl genpkey -algorithm ed25519 | openssl pkcs8 -nocrypt -topk8
        # P256
        openssl ecparam -name prime256v1 -noout -genkey | openssl pkcs8 -nocrypt -topk8
        # P384
        openssl ecparam -name secp384r1 -noout -genkey | openssl pkcs8 -nocrypt -topk8
        # SECP256K1
        openssl ecparam -name secp256k1 -noout -genkey | openssl pkcs8 -nocrypt -topk8
        ```

        How to transform existing private key to PKCS8 format by OpenSSL (input format PEM, output format - PEM PCKS#8)

        ```bash
        openssl pkcs8 -nocrypt -topk8 <(pathfile with private key in PEM format)
        ```

        How to transform private key to public key by OpenSSL (input format PEM, output format - PEM PKIX)

        ```bash
        openssl pkey -pubout <(pathfile with private key in PKCS8 format)
        ```

        Useful third-party documentation:

        - [openssl-genrsa - generate an RSA private key](https://www.openssl.org/docs/manmaster/man1/openssl-genpkey.html).
        - [openssl-ec, ec - EC key processing](https://www.openssl.org/docs/man1.0.2/man1/ec.html)
        - [openssl-genrsa - generate an RSA private key](https://www.openssl.org/docs/man3.0/man1/openssl-genrsa.html)
        - [openssl-pkcs8 - PKCS#8 format private key conversion command](https://www.openssl.org/docs/manmaster/man1/openssl-pkcs8.html)
        - [JWX - github.com/lestrrat-go/jwx](https://github.com/lestrrat-go/jwx/blob/main/cmd/jwx/README.md)
        - [FIPS 186-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf).
        - [SEC2](https://www.secg.org/sec2-v2.pdf).
        - [AWS KMS - Asymmetric key specs](https://docs.aws.amazon.com/kms/latest/developerguide/asymmetric-key-specs.html)
          .

        Parameters
        ----------
        data : KeyImportSecret

        idempotency_key : typing.Optional[str]
            From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
            The **Idempotency-Key** is a free identifier created by the client to
            identify a request. It is used by the service to identify repeated request
            to ensure idempotent behavior by sending the same (or a similar) response
            without executing the request a second time.

            Clients should be careful as any subsequent requests with the same key may
            return the same response without further check. Thus, it is recommended to
            use a UUID version 4 (random) or any other random string with enough
            entropy to avoid collisions.

            Keys expire after 24 hours. Clients are responsible to stay within this
            limit, if they require idempotent behavior.

            See [API Guideline Rule #181][api-230] for further details.

            [api-230]: <https://opensource.zalando.com/restful-api-guidelines/#230>.

        annotations : typing.Optional[Annotations]

        labels : typing.Optional[Labels]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        KeyResource
            Result of key's resource Create or Update or Restore.

        Examples
        --------
        import asyncio

        from truvity_sdk import AsyncTruvityApi

        client = AsyncTruvityApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.keys.key_import(
                idempotency_key="7da7a728-f910-11e6-942a-68f728c1ba70",
                data="data",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "keys/import",
            method="POST",
            json={"data": data, "annotations": annotations, "labels": labels},
            headers={"Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(KeyResource, parse_obj_as(type_=KeyResource, object_=_response.json()))  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(BadRequestErrorBody, parse_obj_as(type_=BadRequestErrorBody, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(ProblemUnauthorized, parse_obj_as(type_=ProblemUnauthorized, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(ProblemForbidden, parse_obj_as(type_=ProblemForbidden, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    typing.cast(ProblemUnsupportedMediaType, parse_obj_as(type_=ProblemUnsupportedMediaType, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(ProblemInternalServerError, parse_obj_as(type_=ProblemInternalServerError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def key_search(
        self,
        *,
        filter: typing.Optional[typing.Sequence[KeyFilter]] = OMIT,
        sort: typing.Optional[typing.Sequence[KeySort]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> KeyList:
        """
        Take a look at [GET with body payload](https://opensource.zalando.com/restful-api-guidelines/#get-with-body)

        - no resources created: Returns all keys matching the query passed as request input payload.

        Parameters
        ----------
        filter : typing.Optional[typing.Sequence[KeyFilter]]
            Filter for the keys' resources.

        sort : typing.Optional[typing.Sequence[KeySort]]
            Sort of the keys' resources.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        KeyList
            Result of search of the keys' resources.

        Examples
        --------
        import asyncio

        from truvity_sdk import AsyncTruvityApi

        client = AsyncTruvityApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.keys.key_search()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "keys/search",
            method="POST",
            json={"filter": filter, "sort": sort},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(KeyList, parse_obj_as(type_=KeyList, object_=_response.json()))  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(BadRequestErrorBody, parse_obj_as(type_=BadRequestErrorBody, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(ProblemUnauthorized, parse_obj_as(type_=ProblemUnauthorized, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(ProblemForbidden, parse_obj_as(type_=ProblemForbidden, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    typing.cast(ProblemUnsupportedMediaType, parse_obj_as(type_=ProblemUnsupportedMediaType, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(ProblemInternalServerError, parse_obj_as(type_=ProblemInternalServerError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def key_latest(
        self,
        id: ResourceId,
        *,
        if_none_match: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> KeyResource:
        """
        Read the latest revision of the key's resource.

        Parameters
        ----------
        id : ResourceId
            Take a look to documentation about #/components/schemas/ResourceID.

        if_none_match : typing.Optional[str]
            From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
            The **If-None-Match header** field is used to declare a list of identifiers
            that are required to fail matching all the current resource version
            identifiers as a pre-condition for executing the request on the server
            side. This is especially used in conjunction with an **\*** (asterix) that
            is matching all possible resource identifiers to ensure the initial
            creation of a resource. Other use cases are possible but rare.

            If the pre-condition fails the server will respond with status code **412**
            (Precondition Failed). See [RFC 9110 Section 13.1.2][rfc-9110-13.1.2] as
            well as [API Guideline Rule #182][api-182] for further details.

            [rfc-9110-13.1.2]: https://tools.ietf.org/html/rfc9110#section-13.1.2

            [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        KeyResource
            Result of key's resource Create or Update or Restore.

        Examples
        --------
        import asyncio

        from truvity_sdk import AsyncTruvityApi

        client = AsyncTruvityApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.keys.key_latest(
                id="id",
                if_none_match="5db68c06-1a68-11e9-8341-68f728c1ba70",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"keys/{jsonable_encoder(id)}",
            method="GET",
            headers={"If-None-Match": str(if_none_match) if if_none_match is not None else None},
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(KeyResource, parse_obj_as(type_=KeyResource, object_=_response.json()))  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(BadRequestErrorBody, parse_obj_as(type_=BadRequestErrorBody, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(ProblemUnauthorized, parse_obj_as(type_=ProblemUnauthorized, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(ProblemForbidden, parse_obj_as(type_=ProblemForbidden, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(typing.Any, parse_obj_as(type_=typing.Any, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(ProblemInternalServerError, parse_obj_as(type_=ProblemInternalServerError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def key_delete(
        self,
        id: ResourceId,
        *,
        if_match: str,
        idempotency_key: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Delete key's resource.

        Parameters
        ----------
        id : ResourceId
            Take a look to documentation about #/components/schemas/ResourceID.

        if_match : str
            From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
            The **If-Match** header field is used to declare a list of identifiers that
            are required to match the current resource version identifier in at least
            one position as a pre-condition for executing the request on the server
            side. This behavior is used to validate and reject optimistic updates, by
            checking if the resource version a consumer has based his changes on is
            outdated on arrival of the change request to prevent lost updates.

            If the pre-condition fails the server will respond with status code **412**
            (Precondition Failed). See [RFC 9110 Section 13.1.1][rfc-9110-13.1.1] as
            well as [API Guideline Rule #182][api-182] for further details.

            [rfc-9110-13.1.1]: https://tools.ietf.org/html/rfc9110#section-13.1.1

            [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.

        idempotency_key : typing.Optional[str]
            From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
            The **Idempotency-Key** is a free identifier created by the client to
            identify a request. It is used by the service to identify repeated request
            to ensure idempotent behavior by sending the same (or a similar) response
            without executing the request a second time.

            Clients should be careful as any subsequent requests with the same key may
            return the same response without further check. Thus, it is recommended to
            use a UUID version 4 (random) or any other random string with enough
            entropy to avoid collisions.

            Keys expire after 24 hours. Clients are responsible to stay within this
            limit, if they require idempotent behavior.

            See [API Guideline Rule #181][api-230] for further details.

            [api-230]: <https://opensource.zalando.com/restful-api-guidelines/#230>.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from truvity_sdk import AsyncTruvityApi

        client = AsyncTruvityApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.keys.key_delete(
                id="id",
                idempotency_key="7da7a728-f910-11e6-942a-68f728c1ba70",
                if_match="5db68c06-1a68-11e9-8341-68f728c1ba70",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"keys/{jsonable_encoder(id)}",
            method="DELETE",
            headers={
                "Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None,
                "If-Match": str(if_match) if if_match is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(BadRequestErrorBody, parse_obj_as(type_=BadRequestErrorBody, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(ProblemUnauthorized, parse_obj_as(type_=ProblemUnauthorized, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(ProblemForbidden, parse_obj_as(type_=ProblemForbidden, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(typing.Any, parse_obj_as(type_=typing.Any, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    typing.cast(typing.Any, parse_obj_as(type_=typing.Any, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 412:
                raise PreconditionFailedError(
                    typing.cast(ProblemConflictResource, parse_obj_as(type_=ProblemConflictResource, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(ProblemInternalServerError, parse_obj_as(type_=ProblemInternalServerError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def key_update(
        self,
        id: ResourceId,
        *,
        if_match: str,
        idempotency_key: typing.Optional[str] = None,
        annotations: typing.Optional[Annotations] = OMIT,
        labels: typing.Optional[Labels] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> KeyResource:
        """
        Update key's resource.

        Parameters
        ----------
        id : ResourceId
            Take a look to documentation about #/components/schemas/ResourceID.

        if_match : str
            From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
            The **If-Match** header field is used to declare a list of identifiers that
            are required to match the current resource version identifier in at least
            one position as a pre-condition for executing the request on the server
            side. This behavior is used to validate and reject optimistic updates, by
            checking if the resource version a consumer has based his changes on is
            outdated on arrival of the change request to prevent lost updates.

            If the pre-condition fails the server will respond with status code **412**
            (Precondition Failed). See [RFC 9110 Section 13.1.1][rfc-9110-13.1.1] as
            well as [API Guideline Rule #182][api-182] for further details.

            [rfc-9110-13.1.1]: https://tools.ietf.org/html/rfc9110#section-13.1.1

            [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.

        idempotency_key : typing.Optional[str]
            From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
            The **Idempotency-Key** is a free identifier created by the client to
            identify a request. It is used by the service to identify repeated request
            to ensure idempotent behavior by sending the same (or a similar) response
            without executing the request a second time.

            Clients should be careful as any subsequent requests with the same key may
            return the same response without further check. Thus, it is recommended to
            use a UUID version 4 (random) or any other random string with enough
            entropy to avoid collisions.

            Keys expire after 24 hours. Clients are responsible to stay within this
            limit, if they require idempotent behavior.

            See [API Guideline Rule #181][api-230] for further details.

            [api-230]: <https://opensource.zalando.com/restful-api-guidelines/#230>.

        annotations : typing.Optional[Annotations]

        labels : typing.Optional[Labels]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        KeyResource
            Result of key's resource Create or Update or Restore.

        Examples
        --------
        import asyncio

        from truvity_sdk import AsyncTruvityApi

        client = AsyncTruvityApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.keys.key_update(
                id="id",
                idempotency_key="7da7a728-f910-11e6-942a-68f728c1ba70",
                if_match="5db68c06-1a68-11e9-8341-68f728c1ba70",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"keys/{jsonable_encoder(id)}",
            method="PATCH",
            json={"annotations": annotations, "labels": labels},
            headers={
                "Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None,
                "If-Match": str(if_match) if if_match is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(KeyResource, parse_obj_as(type_=KeyResource, object_=_response.json()))  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(BadRequestErrorBody, parse_obj_as(type_=BadRequestErrorBody, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(ProblemUnauthorized, parse_obj_as(type_=ProblemUnauthorized, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(ProblemForbidden, parse_obj_as(type_=ProblemForbidden, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(typing.Any, parse_obj_as(type_=typing.Any, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    typing.cast(typing.Any, parse_obj_as(type_=typing.Any, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 412:
                raise PreconditionFailedError(
                    typing.cast(ProblemConflictResource, parse_obj_as(type_=ProblemConflictResource, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    typing.cast(ProblemUnsupportedMediaType, parse_obj_as(type_=ProblemUnsupportedMediaType, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(ProblemInternalServerError, parse_obj_as(type_=ProblemInternalServerError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def credential_sign(
        self,
        id: ResourceId,
        *,
        request: CredentialUnsigned,
        did_method: typing.Optional[DidMethod] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.AsyncIterator[bytes]:
        """
        Sign a JSON-LD representation of an unsigned credential.

        Parameters
        ----------
        id : ResourceId
            Take a look to documentation about #/components/schemas/ResourceID.

        request : CredentialUnsigned

        did_method : typing.Optional[DidMethod]
            All supported DID methods. Default value: web.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Yields
        ------
        typing.AsyncIterator[bytes]
            Result of a credential signing.

        Examples
        --------
        import asyncio

        from truvity_sdk import AsyncTruvityApi

        client = AsyncTruvityApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.keys.credential_sign(
                id="string",
                did_method="key",
                request="string",
            )


        asyncio.run(main())
        """
        async with self._client_wrapper.httpx_client.stream(
            f"keys/{jsonable_encoder(id)}/credentials/sign",
            method="POST",
            params={"did_method": did_method},
            json=request,
            request_options=request_options,
            omit=OMIT,
        ) as _response:
            try:
                if 200 <= _response.status_code < 300:
                    async for _chunk in _response.aiter_bytes():
                        yield _chunk
                    return
                await _response.aread()
                if _response.status_code == 400:
                    raise BadRequestError(
                        typing.cast(BadRequestErrorBody, parse_obj_as(type_=BadRequestErrorBody, object_=_response.json()))  # type: ignore
                    )
                if _response.status_code == 401:
                    raise UnauthorizedError(
                        typing.cast(ProblemUnauthorized, parse_obj_as(type_=ProblemUnauthorized, object_=_response.json()))  # type: ignore
                    )
                if _response.status_code == 403:
                    raise ForbiddenError(
                        typing.cast(ProblemForbidden, parse_obj_as(type_=ProblemForbidden, object_=_response.json()))  # type: ignore
                    )
                if _response.status_code == 404:
                    raise NotFoundError(
                        typing.cast(typing.Any, parse_obj_as(type_=typing.Any, object_=_response.json()))  # type: ignore
                    )
                if _response.status_code == 500:
                    raise InternalServerError(
                        typing.cast(ProblemInternalServerError, parse_obj_as(type_=ProblemInternalServerError, object_=_response.json()))  # type: ignore
                    )
                _response_json = _response.json()
            except JSONDecodeError:
                raise ApiError(status_code=_response.status_code, body=_response.text)
            raise ApiError(status_code=_response.status_code, body=_response_json)

    async def didcomm_message_sign(
        self,
        id: ResourceId,
        *,
        request: str,
        did_method: typing.Optional[DidMethod] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.AsyncIterator[bytes]:
        """
        Sign DIDCOMM Message Plaintext.

        Parameters
        ----------
        id : ResourceId
            Take a look to documentation about #/components/schemas/ResourceID.

        request : str

        did_method : typing.Optional[DidMethod]
            All supported DID methods. Default value: web.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Yields
        ------
        typing.AsyncIterator[bytes]
            DIDCOMM Signed Message according to [DIDComm Messaging v2.x Editor’s Draft](https://identity.foundation/didcomm-messaging/spec).

        Examples
        --------
        import asyncio

        from truvity_sdk import AsyncTruvityApi

        client = AsyncTruvityApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.keys.didcomm_message_sign(
                id="string",
                did_method="key",
                request="string",
            )


        asyncio.run(main())
        """
        async with self._client_wrapper.httpx_client.stream(
            f"keys/{jsonable_encoder(id)}/didcomm-messages/sign",
            method="POST",
            params={"did_method": did_method},
            json=request,
            request_options=request_options,
            omit=OMIT,
        ) as _response:
            try:
                if 200 <= _response.status_code < 300:
                    async for _chunk in _response.aiter_bytes():
                        yield _chunk
                    return
                await _response.aread()
                if _response.status_code == 400:
                    raise BadRequestError(
                        typing.cast(BadRequestErrorBody, parse_obj_as(type_=BadRequestErrorBody, object_=_response.json()))  # type: ignore
                    )
                if _response.status_code == 401:
                    raise UnauthorizedError(
                        typing.cast(ProblemUnauthorized, parse_obj_as(type_=ProblemUnauthorized, object_=_response.json()))  # type: ignore
                    )
                if _response.status_code == 403:
                    raise ForbiddenError(
                        typing.cast(ProblemForbidden, parse_obj_as(type_=ProblemForbidden, object_=_response.json()))  # type: ignore
                    )
                if _response.status_code == 404:
                    raise NotFoundError(
                        typing.cast(typing.Any, parse_obj_as(type_=typing.Any, object_=_response.json()))  # type: ignore
                    )
                if _response.status_code == 500:
                    raise InternalServerError(
                        typing.cast(ProblemInternalServerError, parse_obj_as(type_=ProblemInternalServerError, object_=_response.json()))  # type: ignore
                    )
                _response_json = _response.json()
            except JSONDecodeError:
                raise ApiError(status_code=_response.status_code, body=_response.text)
            raise ApiError(status_code=_response.status_code, body=_response_json)

    async def presentation_sign(
        self,
        id: ResourceId,
        *,
        request: PresentationUnsigned,
        did_method: typing.Optional[DidMethod] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.AsyncIterator[bytes]:
        """
        Sign a JSON-LD representation of an unsigned presentation.

        Parameters
        ----------
        id : ResourceId
            Take a look to documentation about #/components/schemas/ResourceID.

        request : PresentationUnsigned

        did_method : typing.Optional[DidMethod]
            All supported DID methods. Default value: web.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Yields
        ------
        typing.AsyncIterator[bytes]
            Result of a presentation signing.

        Examples
        --------
        import asyncio

        from truvity_sdk import AsyncTruvityApi

        client = AsyncTruvityApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.keys.presentation_sign(
                id="string",
                did_method="key",
                request="string",
            )


        asyncio.run(main())
        """
        async with self._client_wrapper.httpx_client.stream(
            f"keys/{jsonable_encoder(id)}/presentations/sign",
            method="POST",
            params={"did_method": did_method},
            json=request,
            request_options=request_options,
            omit=OMIT,
        ) as _response:
            try:
                if 200 <= _response.status_code < 300:
                    async for _chunk in _response.aiter_bytes():
                        yield _chunk
                    return
                await _response.aread()
                if _response.status_code == 400:
                    raise BadRequestError(
                        typing.cast(BadRequestErrorBody, parse_obj_as(type_=BadRequestErrorBody, object_=_response.json()))  # type: ignore
                    )
                if _response.status_code == 401:
                    raise UnauthorizedError(
                        typing.cast(ProblemUnauthorized, parse_obj_as(type_=ProblemUnauthorized, object_=_response.json()))  # type: ignore
                    )
                if _response.status_code == 403:
                    raise ForbiddenError(
                        typing.cast(ProblemForbidden, parse_obj_as(type_=ProblemForbidden, object_=_response.json()))  # type: ignore
                    )
                if _response.status_code == 404:
                    raise NotFoundError(
                        typing.cast(typing.Any, parse_obj_as(type_=typing.Any, object_=_response.json()))  # type: ignore
                    )
                if _response.status_code == 500:
                    raise InternalServerError(
                        typing.cast(ProblemInternalServerError, parse_obj_as(type_=ProblemInternalServerError, object_=_response.json()))  # type: ignore
                    )
                _response_json = _response.json()
            except JSONDecodeError:
                raise ApiError(status_code=_response.status_code, body=_response.text)
            raise ApiError(status_code=_response.status_code, body=_response_json)

    async def key_restore(
        self,
        id: ResourceId,
        *,
        if_match: str,
        idempotency_key: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> KeyResource:
        """
        Restore key's resource.

        Parameters
        ----------
        id : ResourceId
            Take a look to documentation about #/components/schemas/ResourceID.

        if_match : str
            From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
            The **If-Match** header field is used to declare a list of identifiers that
            are required to match the current resource version identifier in at least
            one position as a pre-condition for executing the request on the server
            side. This behavior is used to validate and reject optimistic updates, by
            checking if the resource version a consumer has based his changes on is
            outdated on arrival of the change request to prevent lost updates.

            If the pre-condition fails the server will respond with status code **412**
            (Precondition Failed). See [RFC 9110 Section 13.1.1][rfc-9110-13.1.1] as
            well as [API Guideline Rule #182][api-182] for further details.

            [rfc-9110-13.1.1]: https://tools.ietf.org/html/rfc9110#section-13.1.1

            [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.

        idempotency_key : typing.Optional[str]
            From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
            The **Idempotency-Key** is a free identifier created by the client to
            identify a request. It is used by the service to identify repeated request
            to ensure idempotent behavior by sending the same (or a similar) response
            without executing the request a second time.

            Clients should be careful as any subsequent requests with the same key may
            return the same response without further check. Thus, it is recommended to
            use a UUID version 4 (random) or any other random string with enough
            entropy to avoid collisions.

            Keys expire after 24 hours. Clients are responsible to stay within this
            limit, if they require idempotent behavior.

            See [API Guideline Rule #181][api-230] for further details.

            [api-230]: <https://opensource.zalando.com/restful-api-guidelines/#230>.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        KeyResource
            Result of key's resource Create or Update or Restore.

        Examples
        --------
        import asyncio

        from truvity_sdk import AsyncTruvityApi

        client = AsyncTruvityApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.keys.key_restore(
                id="id",
                idempotency_key="7da7a728-f910-11e6-942a-68f728c1ba70",
                if_match="5db68c06-1a68-11e9-8341-68f728c1ba70",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"keys/{jsonable_encoder(id)}/restore",
            method="POST",
            headers={
                "Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None,
                "If-Match": str(if_match) if if_match is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(KeyResource, parse_obj_as(type_=KeyResource, object_=_response.json()))  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(BadRequestErrorBody, parse_obj_as(type_=BadRequestErrorBody, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(ProblemUnauthorized, parse_obj_as(type_=ProblemUnauthorized, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(ProblemForbidden, parse_obj_as(type_=ProblemForbidden, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(typing.Any, parse_obj_as(type_=typing.Any, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    typing.cast(typing.Any, parse_obj_as(type_=typing.Any, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 412:
                raise PreconditionFailedError(
                    typing.cast(ProblemConflictResource, parse_obj_as(type_=ProblemConflictResource, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(ProblemInternalServerError, parse_obj_as(type_=ProblemInternalServerError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def key_history(
        self,
        id: ResourceId,
        *,
        if_none_match: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> KeyList:
        """
        History of the keys' resources.

        Parameters
        ----------
        id : ResourceId
            Take a look to documentation about #/components/schemas/ResourceID.

        if_none_match : typing.Optional[str]
            From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
            The **If-None-Match header** field is used to declare a list of identifiers
            that are required to fail matching all the current resource version
            identifiers as a pre-condition for executing the request on the server
            side. This is especially used in conjunction with an **\*** (asterix) that
            is matching all possible resource identifiers to ensure the initial
            creation of a resource. Other use cases are possible but rare.

            If the pre-condition fails the server will respond with status code **412**
            (Precondition Failed). See [RFC 9110 Section 13.1.2][rfc-9110-13.1.2] as
            well as [API Guideline Rule #182][api-182] for further details.

            [rfc-9110-13.1.2]: https://tools.ietf.org/html/rfc9110#section-13.1.2

            [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        KeyList
            History of the keys' resources.

        Examples
        --------
        import asyncio

        from truvity_sdk import AsyncTruvityApi

        client = AsyncTruvityApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.keys.key_history(
                id="id",
                if_none_match="5db68c06-1a68-11e9-8341-68f728c1ba70",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"keys/{jsonable_encoder(id)}/revisions",
            method="GET",
            headers={"If-None-Match": str(if_none_match) if if_none_match is not None else None},
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(KeyList, parse_obj_as(type_=KeyList, object_=_response.json()))  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(BadRequestErrorBody, parse_obj_as(type_=BadRequestErrorBody, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(ProblemUnauthorized, parse_obj_as(type_=ProblemUnauthorized, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(ProblemForbidden, parse_obj_as(type_=ProblemForbidden, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(typing.Any, parse_obj_as(type_=typing.Any, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(ProblemInternalServerError, parse_obj_as(type_=ProblemInternalServerError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def key_revision(
        self,
        id: ResourceId,
        revision: Revision,
        *,
        if_none_match: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> KeyResource:
        """
        Read the specific version of the key's resource.

        Parameters
        ----------
        id : ResourceId
            Take a look to documentation about #/components/schemas/ResourceID.

        revision : Revision
            We could refer to the specific version of the resource.
            Take a look to documentation about #/components/schemas/Revision.

        if_none_match : typing.Optional[str]
            From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
            The **If-None-Match header** field is used to declare a list of identifiers
            that are required to fail matching all the current resource version
            identifiers as a pre-condition for executing the request on the server
            side. This is especially used in conjunction with an **\*** (asterix) that
            is matching all possible resource identifiers to ensure the initial
            creation of a resource. Other use cases are possible but rare.

            If the pre-condition fails the server will respond with status code **412**
            (Precondition Failed). See [RFC 9110 Section 13.1.2][rfc-9110-13.1.2] as
            well as [API Guideline Rule #182][api-182] for further details.

            [rfc-9110-13.1.2]: https://tools.ietf.org/html/rfc9110#section-13.1.2

            [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        KeyResource
            Result of key's resource Create or Update or Restore.

        Examples
        --------
        import asyncio

        from truvity_sdk import AsyncTruvityApi

        client = AsyncTruvityApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.keys.key_revision(
                id="id",
                revision=1,
                if_none_match="5db68c06-1a68-11e9-8341-68f728c1ba70",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"keys/{jsonable_encoder(id)}/revisions/{jsonable_encoder(revision)}",
            method="GET",
            headers={"If-None-Match": str(if_none_match) if if_none_match is not None else None},
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(KeyResource, parse_obj_as(type_=KeyResource, object_=_response.json()))  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(BadRequestErrorBody, parse_obj_as(type_=BadRequestErrorBody, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(ProblemUnauthorized, parse_obj_as(type_=ProblemUnauthorized, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(ProblemForbidden, parse_obj_as(type_=ProblemForbidden, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(typing.Any, parse_obj_as(type_=typing.Any, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(ProblemInternalServerError, parse_obj_as(type_=ProblemInternalServerError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
