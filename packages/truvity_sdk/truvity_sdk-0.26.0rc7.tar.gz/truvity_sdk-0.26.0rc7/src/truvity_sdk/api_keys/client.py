# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pydantic_utilities import parse_obj_as
from ..core.request_options import RequestOptions
from ..errors.bad_request_error import BadRequestError
from ..errors.forbidden_error import ForbiddenError
from ..errors.internal_server_error import InternalServerError
from ..errors.method_not_allowed_error import MethodNotAllowedError
from ..errors.not_found_error import NotFoundError
from ..errors.precondition_failed_error import PreconditionFailedError
from ..errors.unauthorized_error import UnauthorizedError
from ..errors.unsupported_media_type_error import UnsupportedMediaTypeError
from ..types.annotations import Annotations
from ..types.api_key_create_output import ApiKeyCreateOutput
from ..types.api_key_filter import ApiKeyFilter
from ..types.api_key_list import ApiKeyList
from ..types.api_key_resource import ApiKeyResource
from ..types.api_key_sort import ApiKeySort
from ..types.bad_request_error_body import BadRequestErrorBody
from ..types.labels import Labels
from ..types.problem_conflict_resource import ProblemConflictResource
from ..types.problem_forbidden import ProblemForbidden
from ..types.problem_internal_server_error import ProblemInternalServerError
from ..types.problem_unauthorized import ProblemUnauthorized
from ..types.problem_unsupported_media_type import ProblemUnsupportedMediaType
from ..types.resource_id import ResourceId
from ..types.revision import Revision

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class ApiKeysClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def api_key_create(
        self,
        *,
        idempotency_key: typing.Optional[str] = None,
        annotations: typing.Optional[Annotations] = OMIT,
        labels: typing.Optional[Labels] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ApiKeyCreateOutput:
        """
        Create api-key's resource.

        Parameters
        ----------
        idempotency_key : typing.Optional[str]
            From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
            The **Idempotency-Key** is a free identifier created by the client to
            identify a request. It is used by the service to identify repeated request
            to ensure idempotent behavior by sending the same (or a similar) response
            without executing the request a second time.

            Clients should be careful as any subsequent requests with the same key may
            return the same response without further check. Thus, it is recommended to
            use a UUID version 4 (random) or any other random string with enough
            entropy to avoid collisions.

            Keys expire after 24 hours. Clients are responsible to stay within this
            limit, if they require idempotent behavior.

            See [API Guideline Rule #181][api-230] for further details.

            [api-230]: <https://opensource.zalando.com/restful-api-guidelines/#230>.

        annotations : typing.Optional[Annotations]

        labels : typing.Optional[Labels]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ApiKeyCreateOutput
            Result of api-key's resource Create or Update or Restore.

        Examples
        --------
        from truvity_sdk import TruvityApi

        client = TruvityApi(
            api_key="YOUR_API_KEY",
        )
        client.api_keys.api_key_create(
            idempotency_key="7da7a728-f910-11e6-942a-68f728c1ba70",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "api-keys",
            method="POST",
            json={"annotations": annotations, "labels": labels},
            headers={"Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(ApiKeyCreateOutput, parse_obj_as(type_=ApiKeyCreateOutput, object_=_response.json()))  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(BadRequestErrorBody, parse_obj_as(type_=BadRequestErrorBody, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(ProblemUnauthorized, parse_obj_as(type_=ProblemUnauthorized, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(ProblemForbidden, parse_obj_as(type_=ProblemForbidden, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    typing.cast(ProblemUnsupportedMediaType, parse_obj_as(type_=ProblemUnsupportedMediaType, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(ProblemInternalServerError, parse_obj_as(type_=ProblemInternalServerError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def api_key_search(
        self,
        *,
        filter: typing.Optional[typing.Sequence[ApiKeyFilter]] = OMIT,
        sort: typing.Optional[typing.Sequence[ApiKeySort]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ApiKeyList:
        """
        Take a look at [GET with body payload](https://opensource.zalando.com/restful-api-guidelines/#get-with-body)

        - no resources created: Returns all api-keys matching the query passed as request input payload.

        Parameters
        ----------
        filter : typing.Optional[typing.Sequence[ApiKeyFilter]]
            Filter for the api-keys' resources.

        sort : typing.Optional[typing.Sequence[ApiKeySort]]
            Sort of the api-keys' resources.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ApiKeyList
            Result of search of the api-keys' resources.

        Examples
        --------
        from truvity_sdk import TruvityApi

        client = TruvityApi(
            api_key="YOUR_API_KEY",
        )
        client.api_keys.api_key_search()
        """
        _response = self._client_wrapper.httpx_client.request(
            "api-keys/search",
            method="POST",
            json={"filter": filter, "sort": sort},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(ApiKeyList, parse_obj_as(type_=ApiKeyList, object_=_response.json()))  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(BadRequestErrorBody, parse_obj_as(type_=BadRequestErrorBody, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(ProblemUnauthorized, parse_obj_as(type_=ProblemUnauthorized, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(ProblemForbidden, parse_obj_as(type_=ProblemForbidden, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    typing.cast(ProblemUnsupportedMediaType, parse_obj_as(type_=ProblemUnsupportedMediaType, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(ProblemInternalServerError, parse_obj_as(type_=ProblemInternalServerError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def api_key_latest(
        self,
        id: ResourceId,
        *,
        if_none_match: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ApiKeyResource:
        """
        Read the latest revision of the api-key's resource.

        Parameters
        ----------
        id : ResourceId
            Take a look to documentation about #/components/schemas/ResourceID.

        if_none_match : typing.Optional[str]
            From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
            The **If-None-Match header** field is used to declare a list of identifiers
            that are required to fail matching all the current resource version
            identifiers as a pre-condition for executing the request on the server
            side. This is especially used in conjunction with an **\*** (asterix) that
            is matching all possible resource identifiers to ensure the initial
            creation of a resource. Other use cases are possible but rare.

            If the pre-condition fails the server will respond with status code **412**
            (Precondition Failed). See [RFC 9110 Section 13.1.2][rfc-9110-13.1.2] as
            well as [API Guideline Rule #182][api-182] for further details.

            [rfc-9110-13.1.2]: https://tools.ietf.org/html/rfc9110#section-13.1.2

            [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ApiKeyResource
            Result of api-key's resource Create or Update or Restore.

        Examples
        --------
        from truvity_sdk import TruvityApi

        client = TruvityApi(
            api_key="YOUR_API_KEY",
        )
        client.api_keys.api_key_latest(
            id="id",
            if_none_match="5db68c06-1a68-11e9-8341-68f728c1ba70",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api-keys/{jsonable_encoder(id)}",
            method="GET",
            headers={"If-None-Match": str(if_none_match) if if_none_match is not None else None},
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(ApiKeyResource, parse_obj_as(type_=ApiKeyResource, object_=_response.json()))  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(BadRequestErrorBody, parse_obj_as(type_=BadRequestErrorBody, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(ProblemUnauthorized, parse_obj_as(type_=ProblemUnauthorized, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(ProblemForbidden, parse_obj_as(type_=ProblemForbidden, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(typing.Any, parse_obj_as(type_=typing.Any, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(ProblemInternalServerError, parse_obj_as(type_=ProblemInternalServerError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def api_key_delete(
        self,
        id: ResourceId,
        *,
        if_match: str,
        idempotency_key: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Delete api-key's resource.

        Parameters
        ----------
        id : ResourceId
            Take a look to documentation about #/components/schemas/ResourceID.

        if_match : str
            From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
            The **If-Match** header field is used to declare a list of identifiers that
            are required to match the current resource version identifier in at least
            one position as a pre-condition for executing the request on the server
            side. This behavior is used to validate and reject optimistic updates, by
            checking if the resource version a consumer has based his changes on is
            outdated on arrival of the change request to prevent lost updates.

            If the pre-condition fails the server will respond with status code **412**
            (Precondition Failed). See [RFC 9110 Section 13.1.1][rfc-9110-13.1.1] as
            well as [API Guideline Rule #182][api-182] for further details.

            [rfc-9110-13.1.1]: https://tools.ietf.org/html/rfc9110#section-13.1.1

            [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.

        idempotency_key : typing.Optional[str]
            From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
            The **Idempotency-Key** is a free identifier created by the client to
            identify a request. It is used by the service to identify repeated request
            to ensure idempotent behavior by sending the same (or a similar) response
            without executing the request a second time.

            Clients should be careful as any subsequent requests with the same key may
            return the same response without further check. Thus, it is recommended to
            use a UUID version 4 (random) or any other random string with enough
            entropy to avoid collisions.

            Keys expire after 24 hours. Clients are responsible to stay within this
            limit, if they require idempotent behavior.

            See [API Guideline Rule #181][api-230] for further details.

            [api-230]: <https://opensource.zalando.com/restful-api-guidelines/#230>.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from truvity_sdk import TruvityApi

        client = TruvityApi(
            api_key="YOUR_API_KEY",
        )
        client.api_keys.api_key_delete(
            id="id",
            idempotency_key="7da7a728-f910-11e6-942a-68f728c1ba70",
            if_match="5db68c06-1a68-11e9-8341-68f728c1ba70",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api-keys/{jsonable_encoder(id)}",
            method="DELETE",
            headers={
                "Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None,
                "If-Match": str(if_match) if if_match is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(BadRequestErrorBody, parse_obj_as(type_=BadRequestErrorBody, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(ProblemUnauthorized, parse_obj_as(type_=ProblemUnauthorized, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(ProblemForbidden, parse_obj_as(type_=ProblemForbidden, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(typing.Any, parse_obj_as(type_=typing.Any, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    typing.cast(typing.Any, parse_obj_as(type_=typing.Any, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 412:
                raise PreconditionFailedError(
                    typing.cast(ProblemConflictResource, parse_obj_as(type_=ProblemConflictResource, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(ProblemInternalServerError, parse_obj_as(type_=ProblemInternalServerError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def api_key_update(
        self,
        id: ResourceId,
        *,
        if_match: str,
        idempotency_key: typing.Optional[str] = None,
        annotations: typing.Optional[Annotations] = OMIT,
        labels: typing.Optional[Labels] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ApiKeyResource:
        """
        Update api-key's resource.

        Parameters
        ----------
        id : ResourceId
            Take a look to documentation about #/components/schemas/ResourceID.

        if_match : str
            From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
            The **If-Match** header field is used to declare a list of identifiers that
            are required to match the current resource version identifier in at least
            one position as a pre-condition for executing the request on the server
            side. This behavior is used to validate and reject optimistic updates, by
            checking if the resource version a consumer has based his changes on is
            outdated on arrival of the change request to prevent lost updates.

            If the pre-condition fails the server will respond with status code **412**
            (Precondition Failed). See [RFC 9110 Section 13.1.1][rfc-9110-13.1.1] as
            well as [API Guideline Rule #182][api-182] for further details.

            [rfc-9110-13.1.1]: https://tools.ietf.org/html/rfc9110#section-13.1.1

            [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.

        idempotency_key : typing.Optional[str]
            From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
            The **Idempotency-Key** is a free identifier created by the client to
            identify a request. It is used by the service to identify repeated request
            to ensure idempotent behavior by sending the same (or a similar) response
            without executing the request a second time.

            Clients should be careful as any subsequent requests with the same key may
            return the same response without further check. Thus, it is recommended to
            use a UUID version 4 (random) or any other random string with enough
            entropy to avoid collisions.

            Keys expire after 24 hours. Clients are responsible to stay within this
            limit, if they require idempotent behavior.

            See [API Guideline Rule #181][api-230] for further details.

            [api-230]: <https://opensource.zalando.com/restful-api-guidelines/#230>.

        annotations : typing.Optional[Annotations]

        labels : typing.Optional[Labels]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ApiKeyResource
            Result of api-key's resource Create or Update or Restore.

        Examples
        --------
        from truvity_sdk import TruvityApi

        client = TruvityApi(
            api_key="YOUR_API_KEY",
        )
        client.api_keys.api_key_update(
            id="id",
            idempotency_key="7da7a728-f910-11e6-942a-68f728c1ba70",
            if_match="5db68c06-1a68-11e9-8341-68f728c1ba70",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api-keys/{jsonable_encoder(id)}",
            method="PATCH",
            json={"annotations": annotations, "labels": labels},
            headers={
                "Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None,
                "If-Match": str(if_match) if if_match is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(ApiKeyResource, parse_obj_as(type_=ApiKeyResource, object_=_response.json()))  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(BadRequestErrorBody, parse_obj_as(type_=BadRequestErrorBody, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(ProblemUnauthorized, parse_obj_as(type_=ProblemUnauthorized, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(ProblemForbidden, parse_obj_as(type_=ProblemForbidden, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(typing.Any, parse_obj_as(type_=typing.Any, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    typing.cast(typing.Any, parse_obj_as(type_=typing.Any, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 412:
                raise PreconditionFailedError(
                    typing.cast(ProblemConflictResource, parse_obj_as(type_=ProblemConflictResource, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    typing.cast(ProblemUnsupportedMediaType, parse_obj_as(type_=ProblemUnsupportedMediaType, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(ProblemInternalServerError, parse_obj_as(type_=ProblemInternalServerError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def api_key_restore(
        self,
        id: ResourceId,
        *,
        if_match: str,
        idempotency_key: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ApiKeyResource:
        """
        Restore api-key's resource.

        Parameters
        ----------
        id : ResourceId
            Take a look to documentation about #/components/schemas/ResourceID.

        if_match : str
            From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
            The **If-Match** header field is used to declare a list of identifiers that
            are required to match the current resource version identifier in at least
            one position as a pre-condition for executing the request on the server
            side. This behavior is used to validate and reject optimistic updates, by
            checking if the resource version a consumer has based his changes on is
            outdated on arrival of the change request to prevent lost updates.

            If the pre-condition fails the server will respond with status code **412**
            (Precondition Failed). See [RFC 9110 Section 13.1.1][rfc-9110-13.1.1] as
            well as [API Guideline Rule #182][api-182] for further details.

            [rfc-9110-13.1.1]: https://tools.ietf.org/html/rfc9110#section-13.1.1

            [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.

        idempotency_key : typing.Optional[str]
            From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
            The **Idempotency-Key** is a free identifier created by the client to
            identify a request. It is used by the service to identify repeated request
            to ensure idempotent behavior by sending the same (or a similar) response
            without executing the request a second time.

            Clients should be careful as any subsequent requests with the same key may
            return the same response without further check. Thus, it is recommended to
            use a UUID version 4 (random) or any other random string with enough
            entropy to avoid collisions.

            Keys expire after 24 hours. Clients are responsible to stay within this
            limit, if they require idempotent behavior.

            See [API Guideline Rule #181][api-230] for further details.

            [api-230]: <https://opensource.zalando.com/restful-api-guidelines/#230>.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ApiKeyResource
            Result of api-key's resource Create or Update or Restore.

        Examples
        --------
        from truvity_sdk import TruvityApi

        client = TruvityApi(
            api_key="YOUR_API_KEY",
        )
        client.api_keys.api_key_restore(
            id="id",
            idempotency_key="7da7a728-f910-11e6-942a-68f728c1ba70",
            if_match="5db68c06-1a68-11e9-8341-68f728c1ba70",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api-keys/{jsonable_encoder(id)}/restore",
            method="POST",
            headers={
                "Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None,
                "If-Match": str(if_match) if if_match is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(ApiKeyResource, parse_obj_as(type_=ApiKeyResource, object_=_response.json()))  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(BadRequestErrorBody, parse_obj_as(type_=BadRequestErrorBody, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(ProblemUnauthorized, parse_obj_as(type_=ProblemUnauthorized, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(ProblemForbidden, parse_obj_as(type_=ProblemForbidden, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(typing.Any, parse_obj_as(type_=typing.Any, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    typing.cast(typing.Any, parse_obj_as(type_=typing.Any, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 412:
                raise PreconditionFailedError(
                    typing.cast(ProblemConflictResource, parse_obj_as(type_=ProblemConflictResource, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(ProblemInternalServerError, parse_obj_as(type_=ProblemInternalServerError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def api_key_history(
        self,
        id: ResourceId,
        *,
        if_none_match: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ApiKeyList:
        """
        History of the api-keys' resources.

        Parameters
        ----------
        id : ResourceId
            Take a look to documentation about #/components/schemas/ResourceID.

        if_none_match : typing.Optional[str]
            From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
            The **If-None-Match header** field is used to declare a list of identifiers
            that are required to fail matching all the current resource version
            identifiers as a pre-condition for executing the request on the server
            side. This is especially used in conjunction with an **\*** (asterix) that
            is matching all possible resource identifiers to ensure the initial
            creation of a resource. Other use cases are possible but rare.

            If the pre-condition fails the server will respond with status code **412**
            (Precondition Failed). See [RFC 9110 Section 13.1.2][rfc-9110-13.1.2] as
            well as [API Guideline Rule #182][api-182] for further details.

            [rfc-9110-13.1.2]: https://tools.ietf.org/html/rfc9110#section-13.1.2

            [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ApiKeyList
            History of the api-keys' resources.

        Examples
        --------
        from truvity_sdk import TruvityApi

        client = TruvityApi(
            api_key="YOUR_API_KEY",
        )
        client.api_keys.api_key_history(
            id="id",
            if_none_match="5db68c06-1a68-11e9-8341-68f728c1ba70",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api-keys/{jsonable_encoder(id)}/revisions",
            method="GET",
            headers={"If-None-Match": str(if_none_match) if if_none_match is not None else None},
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(ApiKeyList, parse_obj_as(type_=ApiKeyList, object_=_response.json()))  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(BadRequestErrorBody, parse_obj_as(type_=BadRequestErrorBody, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(ProblemUnauthorized, parse_obj_as(type_=ProblemUnauthorized, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(ProblemForbidden, parse_obj_as(type_=ProblemForbidden, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(typing.Any, parse_obj_as(type_=typing.Any, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(ProblemInternalServerError, parse_obj_as(type_=ProblemInternalServerError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def api_key_revision(
        self,
        id: ResourceId,
        revision: Revision,
        *,
        if_none_match: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ApiKeyResource:
        """
        Read the specific version of the api-key's resource.

        Parameters
        ----------
        id : ResourceId
            Take a look to documentation about #/components/schemas/ResourceID.

        revision : Revision
            We could refer to the specific version of the resource.
            Take a look to documentation about #/components/schemas/Revision.

        if_none_match : typing.Optional[str]
            From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
            The **If-None-Match header** field is used to declare a list of identifiers
            that are required to fail matching all the current resource version
            identifiers as a pre-condition for executing the request on the server
            side. This is especially used in conjunction with an **\*** (asterix) that
            is matching all possible resource identifiers to ensure the initial
            creation of a resource. Other use cases are possible but rare.

            If the pre-condition fails the server will respond with status code **412**
            (Precondition Failed). See [RFC 9110 Section 13.1.2][rfc-9110-13.1.2] as
            well as [API Guideline Rule #182][api-182] for further details.

            [rfc-9110-13.1.2]: https://tools.ietf.org/html/rfc9110#section-13.1.2

            [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ApiKeyResource
            Result of api-key's resource Create or Update or Restore.

        Examples
        --------
        from truvity_sdk import TruvityApi

        client = TruvityApi(
            api_key="YOUR_API_KEY",
        )
        client.api_keys.api_key_revision(
            id="id",
            revision=1,
            if_none_match="5db68c06-1a68-11e9-8341-68f728c1ba70",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api-keys/{jsonable_encoder(id)}/revisions/{jsonable_encoder(revision)}",
            method="GET",
            headers={"If-None-Match": str(if_none_match) if if_none_match is not None else None},
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(ApiKeyResource, parse_obj_as(type_=ApiKeyResource, object_=_response.json()))  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(BadRequestErrorBody, parse_obj_as(type_=BadRequestErrorBody, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(ProblemUnauthorized, parse_obj_as(type_=ProblemUnauthorized, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(ProblemForbidden, parse_obj_as(type_=ProblemForbidden, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(typing.Any, parse_obj_as(type_=typing.Any, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(ProblemInternalServerError, parse_obj_as(type_=ProblemInternalServerError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncApiKeysClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def api_key_create(
        self,
        *,
        idempotency_key: typing.Optional[str] = None,
        annotations: typing.Optional[Annotations] = OMIT,
        labels: typing.Optional[Labels] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ApiKeyCreateOutput:
        """
        Create api-key's resource.

        Parameters
        ----------
        idempotency_key : typing.Optional[str]
            From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
            The **Idempotency-Key** is a free identifier created by the client to
            identify a request. It is used by the service to identify repeated request
            to ensure idempotent behavior by sending the same (or a similar) response
            without executing the request a second time.

            Clients should be careful as any subsequent requests with the same key may
            return the same response without further check. Thus, it is recommended to
            use a UUID version 4 (random) or any other random string with enough
            entropy to avoid collisions.

            Keys expire after 24 hours. Clients are responsible to stay within this
            limit, if they require idempotent behavior.

            See [API Guideline Rule #181][api-230] for further details.

            [api-230]: <https://opensource.zalando.com/restful-api-guidelines/#230>.

        annotations : typing.Optional[Annotations]

        labels : typing.Optional[Labels]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ApiKeyCreateOutput
            Result of api-key's resource Create or Update or Restore.

        Examples
        --------
        import asyncio

        from truvity_sdk import AsyncTruvityApi

        client = AsyncTruvityApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.api_keys.api_key_create(
                idempotency_key="7da7a728-f910-11e6-942a-68f728c1ba70",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api-keys",
            method="POST",
            json={"annotations": annotations, "labels": labels},
            headers={"Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(ApiKeyCreateOutput, parse_obj_as(type_=ApiKeyCreateOutput, object_=_response.json()))  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(BadRequestErrorBody, parse_obj_as(type_=BadRequestErrorBody, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(ProblemUnauthorized, parse_obj_as(type_=ProblemUnauthorized, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(ProblemForbidden, parse_obj_as(type_=ProblemForbidden, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    typing.cast(ProblemUnsupportedMediaType, parse_obj_as(type_=ProblemUnsupportedMediaType, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(ProblemInternalServerError, parse_obj_as(type_=ProblemInternalServerError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def api_key_search(
        self,
        *,
        filter: typing.Optional[typing.Sequence[ApiKeyFilter]] = OMIT,
        sort: typing.Optional[typing.Sequence[ApiKeySort]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ApiKeyList:
        """
        Take a look at [GET with body payload](https://opensource.zalando.com/restful-api-guidelines/#get-with-body)

        - no resources created: Returns all api-keys matching the query passed as request input payload.

        Parameters
        ----------
        filter : typing.Optional[typing.Sequence[ApiKeyFilter]]
            Filter for the api-keys' resources.

        sort : typing.Optional[typing.Sequence[ApiKeySort]]
            Sort of the api-keys' resources.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ApiKeyList
            Result of search of the api-keys' resources.

        Examples
        --------
        import asyncio

        from truvity_sdk import AsyncTruvityApi

        client = AsyncTruvityApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.api_keys.api_key_search()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api-keys/search",
            method="POST",
            json={"filter": filter, "sort": sort},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(ApiKeyList, parse_obj_as(type_=ApiKeyList, object_=_response.json()))  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(BadRequestErrorBody, parse_obj_as(type_=BadRequestErrorBody, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(ProblemUnauthorized, parse_obj_as(type_=ProblemUnauthorized, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(ProblemForbidden, parse_obj_as(type_=ProblemForbidden, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    typing.cast(ProblemUnsupportedMediaType, parse_obj_as(type_=ProblemUnsupportedMediaType, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(ProblemInternalServerError, parse_obj_as(type_=ProblemInternalServerError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def api_key_latest(
        self,
        id: ResourceId,
        *,
        if_none_match: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ApiKeyResource:
        """
        Read the latest revision of the api-key's resource.

        Parameters
        ----------
        id : ResourceId
            Take a look to documentation about #/components/schemas/ResourceID.

        if_none_match : typing.Optional[str]
            From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
            The **If-None-Match header** field is used to declare a list of identifiers
            that are required to fail matching all the current resource version
            identifiers as a pre-condition for executing the request on the server
            side. This is especially used in conjunction with an **\*** (asterix) that
            is matching all possible resource identifiers to ensure the initial
            creation of a resource. Other use cases are possible but rare.

            If the pre-condition fails the server will respond with status code **412**
            (Precondition Failed). See [RFC 9110 Section 13.1.2][rfc-9110-13.1.2] as
            well as [API Guideline Rule #182][api-182] for further details.

            [rfc-9110-13.1.2]: https://tools.ietf.org/html/rfc9110#section-13.1.2

            [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ApiKeyResource
            Result of api-key's resource Create or Update or Restore.

        Examples
        --------
        import asyncio

        from truvity_sdk import AsyncTruvityApi

        client = AsyncTruvityApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.api_keys.api_key_latest(
                id="id",
                if_none_match="5db68c06-1a68-11e9-8341-68f728c1ba70",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api-keys/{jsonable_encoder(id)}",
            method="GET",
            headers={"If-None-Match": str(if_none_match) if if_none_match is not None else None},
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(ApiKeyResource, parse_obj_as(type_=ApiKeyResource, object_=_response.json()))  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(BadRequestErrorBody, parse_obj_as(type_=BadRequestErrorBody, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(ProblemUnauthorized, parse_obj_as(type_=ProblemUnauthorized, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(ProblemForbidden, parse_obj_as(type_=ProblemForbidden, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(typing.Any, parse_obj_as(type_=typing.Any, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(ProblemInternalServerError, parse_obj_as(type_=ProblemInternalServerError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def api_key_delete(
        self,
        id: ResourceId,
        *,
        if_match: str,
        idempotency_key: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Delete api-key's resource.

        Parameters
        ----------
        id : ResourceId
            Take a look to documentation about #/components/schemas/ResourceID.

        if_match : str
            From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
            The **If-Match** header field is used to declare a list of identifiers that
            are required to match the current resource version identifier in at least
            one position as a pre-condition for executing the request on the server
            side. This behavior is used to validate and reject optimistic updates, by
            checking if the resource version a consumer has based his changes on is
            outdated on arrival of the change request to prevent lost updates.

            If the pre-condition fails the server will respond with status code **412**
            (Precondition Failed). See [RFC 9110 Section 13.1.1][rfc-9110-13.1.1] as
            well as [API Guideline Rule #182][api-182] for further details.

            [rfc-9110-13.1.1]: https://tools.ietf.org/html/rfc9110#section-13.1.1

            [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.

        idempotency_key : typing.Optional[str]
            From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
            The **Idempotency-Key** is a free identifier created by the client to
            identify a request. It is used by the service to identify repeated request
            to ensure idempotent behavior by sending the same (or a similar) response
            without executing the request a second time.

            Clients should be careful as any subsequent requests with the same key may
            return the same response without further check. Thus, it is recommended to
            use a UUID version 4 (random) or any other random string with enough
            entropy to avoid collisions.

            Keys expire after 24 hours. Clients are responsible to stay within this
            limit, if they require idempotent behavior.

            See [API Guideline Rule #181][api-230] for further details.

            [api-230]: <https://opensource.zalando.com/restful-api-guidelines/#230>.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from truvity_sdk import AsyncTruvityApi

        client = AsyncTruvityApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.api_keys.api_key_delete(
                id="id",
                idempotency_key="7da7a728-f910-11e6-942a-68f728c1ba70",
                if_match="5db68c06-1a68-11e9-8341-68f728c1ba70",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api-keys/{jsonable_encoder(id)}",
            method="DELETE",
            headers={
                "Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None,
                "If-Match": str(if_match) if if_match is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(BadRequestErrorBody, parse_obj_as(type_=BadRequestErrorBody, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(ProblemUnauthorized, parse_obj_as(type_=ProblemUnauthorized, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(ProblemForbidden, parse_obj_as(type_=ProblemForbidden, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(typing.Any, parse_obj_as(type_=typing.Any, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    typing.cast(typing.Any, parse_obj_as(type_=typing.Any, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 412:
                raise PreconditionFailedError(
                    typing.cast(ProblemConflictResource, parse_obj_as(type_=ProblemConflictResource, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(ProblemInternalServerError, parse_obj_as(type_=ProblemInternalServerError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def api_key_update(
        self,
        id: ResourceId,
        *,
        if_match: str,
        idempotency_key: typing.Optional[str] = None,
        annotations: typing.Optional[Annotations] = OMIT,
        labels: typing.Optional[Labels] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ApiKeyResource:
        """
        Update api-key's resource.

        Parameters
        ----------
        id : ResourceId
            Take a look to documentation about #/components/schemas/ResourceID.

        if_match : str
            From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
            The **If-Match** header field is used to declare a list of identifiers that
            are required to match the current resource version identifier in at least
            one position as a pre-condition for executing the request on the server
            side. This behavior is used to validate and reject optimistic updates, by
            checking if the resource version a consumer has based his changes on is
            outdated on arrival of the change request to prevent lost updates.

            If the pre-condition fails the server will respond with status code **412**
            (Precondition Failed). See [RFC 9110 Section 13.1.1][rfc-9110-13.1.1] as
            well as [API Guideline Rule #182][api-182] for further details.

            [rfc-9110-13.1.1]: https://tools.ietf.org/html/rfc9110#section-13.1.1

            [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.

        idempotency_key : typing.Optional[str]
            From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
            The **Idempotency-Key** is a free identifier created by the client to
            identify a request. It is used by the service to identify repeated request
            to ensure idempotent behavior by sending the same (or a similar) response
            without executing the request a second time.

            Clients should be careful as any subsequent requests with the same key may
            return the same response without further check. Thus, it is recommended to
            use a UUID version 4 (random) or any other random string with enough
            entropy to avoid collisions.

            Keys expire after 24 hours. Clients are responsible to stay within this
            limit, if they require idempotent behavior.

            See [API Guideline Rule #181][api-230] for further details.

            [api-230]: <https://opensource.zalando.com/restful-api-guidelines/#230>.

        annotations : typing.Optional[Annotations]

        labels : typing.Optional[Labels]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ApiKeyResource
            Result of api-key's resource Create or Update or Restore.

        Examples
        --------
        import asyncio

        from truvity_sdk import AsyncTruvityApi

        client = AsyncTruvityApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.api_keys.api_key_update(
                id="id",
                idempotency_key="7da7a728-f910-11e6-942a-68f728c1ba70",
                if_match="5db68c06-1a68-11e9-8341-68f728c1ba70",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api-keys/{jsonable_encoder(id)}",
            method="PATCH",
            json={"annotations": annotations, "labels": labels},
            headers={
                "Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None,
                "If-Match": str(if_match) if if_match is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(ApiKeyResource, parse_obj_as(type_=ApiKeyResource, object_=_response.json()))  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(BadRequestErrorBody, parse_obj_as(type_=BadRequestErrorBody, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(ProblemUnauthorized, parse_obj_as(type_=ProblemUnauthorized, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(ProblemForbidden, parse_obj_as(type_=ProblemForbidden, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(typing.Any, parse_obj_as(type_=typing.Any, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    typing.cast(typing.Any, parse_obj_as(type_=typing.Any, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 412:
                raise PreconditionFailedError(
                    typing.cast(ProblemConflictResource, parse_obj_as(type_=ProblemConflictResource, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    typing.cast(ProblemUnsupportedMediaType, parse_obj_as(type_=ProblemUnsupportedMediaType, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(ProblemInternalServerError, parse_obj_as(type_=ProblemInternalServerError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def api_key_restore(
        self,
        id: ResourceId,
        *,
        if_match: str,
        idempotency_key: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ApiKeyResource:
        """
        Restore api-key's resource.

        Parameters
        ----------
        id : ResourceId
            Take a look to documentation about #/components/schemas/ResourceID.

        if_match : str
            From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
            The **If-Match** header field is used to declare a list of identifiers that
            are required to match the current resource version identifier in at least
            one position as a pre-condition for executing the request on the server
            side. This behavior is used to validate and reject optimistic updates, by
            checking if the resource version a consumer has based his changes on is
            outdated on arrival of the change request to prevent lost updates.

            If the pre-condition fails the server will respond with status code **412**
            (Precondition Failed). See [RFC 9110 Section 13.1.1][rfc-9110-13.1.1] as
            well as [API Guideline Rule #182][api-182] for further details.

            [rfc-9110-13.1.1]: https://tools.ietf.org/html/rfc9110#section-13.1.1

            [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.

        idempotency_key : typing.Optional[str]
            From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
            The **Idempotency-Key** is a free identifier created by the client to
            identify a request. It is used by the service to identify repeated request
            to ensure idempotent behavior by sending the same (or a similar) response
            without executing the request a second time.

            Clients should be careful as any subsequent requests with the same key may
            return the same response without further check. Thus, it is recommended to
            use a UUID version 4 (random) or any other random string with enough
            entropy to avoid collisions.

            Keys expire after 24 hours. Clients are responsible to stay within this
            limit, if they require idempotent behavior.

            See [API Guideline Rule #181][api-230] for further details.

            [api-230]: <https://opensource.zalando.com/restful-api-guidelines/#230>.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ApiKeyResource
            Result of api-key's resource Create or Update or Restore.

        Examples
        --------
        import asyncio

        from truvity_sdk import AsyncTruvityApi

        client = AsyncTruvityApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.api_keys.api_key_restore(
                id="id",
                idempotency_key="7da7a728-f910-11e6-942a-68f728c1ba70",
                if_match="5db68c06-1a68-11e9-8341-68f728c1ba70",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api-keys/{jsonable_encoder(id)}/restore",
            method="POST",
            headers={
                "Idempotency-Key": str(idempotency_key) if idempotency_key is not None else None,
                "If-Match": str(if_match) if if_match is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(ApiKeyResource, parse_obj_as(type_=ApiKeyResource, object_=_response.json()))  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(BadRequestErrorBody, parse_obj_as(type_=BadRequestErrorBody, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(ProblemUnauthorized, parse_obj_as(type_=ProblemUnauthorized, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(ProblemForbidden, parse_obj_as(type_=ProblemForbidden, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(typing.Any, parse_obj_as(type_=typing.Any, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    typing.cast(typing.Any, parse_obj_as(type_=typing.Any, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 412:
                raise PreconditionFailedError(
                    typing.cast(ProblemConflictResource, parse_obj_as(type_=ProblemConflictResource, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(ProblemInternalServerError, parse_obj_as(type_=ProblemInternalServerError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def api_key_history(
        self,
        id: ResourceId,
        *,
        if_none_match: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ApiKeyList:
        """
        History of the api-keys' resources.

        Parameters
        ----------
        id : ResourceId
            Take a look to documentation about #/components/schemas/ResourceID.

        if_none_match : typing.Optional[str]
            From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
            The **If-None-Match header** field is used to declare a list of identifiers
            that are required to fail matching all the current resource version
            identifiers as a pre-condition for executing the request on the server
            side. This is especially used in conjunction with an **\*** (asterix) that
            is matching all possible resource identifiers to ensure the initial
            creation of a resource. Other use cases are possible but rare.

            If the pre-condition fails the server will respond with status code **412**
            (Precondition Failed). See [RFC 9110 Section 13.1.2][rfc-9110-13.1.2] as
            well as [API Guideline Rule #182][api-182] for further details.

            [rfc-9110-13.1.2]: https://tools.ietf.org/html/rfc9110#section-13.1.2

            [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ApiKeyList
            History of the api-keys' resources.

        Examples
        --------
        import asyncio

        from truvity_sdk import AsyncTruvityApi

        client = AsyncTruvityApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.api_keys.api_key_history(
                id="id",
                if_none_match="5db68c06-1a68-11e9-8341-68f728c1ba70",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api-keys/{jsonable_encoder(id)}/revisions",
            method="GET",
            headers={"If-None-Match": str(if_none_match) if if_none_match is not None else None},
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(ApiKeyList, parse_obj_as(type_=ApiKeyList, object_=_response.json()))  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(BadRequestErrorBody, parse_obj_as(type_=BadRequestErrorBody, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(ProblemUnauthorized, parse_obj_as(type_=ProblemUnauthorized, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(ProblemForbidden, parse_obj_as(type_=ProblemForbidden, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(typing.Any, parse_obj_as(type_=typing.Any, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(ProblemInternalServerError, parse_obj_as(type_=ProblemInternalServerError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def api_key_revision(
        self,
        id: ResourceId,
        revision: Revision,
        *,
        if_none_match: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ApiKeyResource:
        """
        Read the specific version of the api-key's resource.

        Parameters
        ----------
        id : ResourceId
            Take a look to documentation about #/components/schemas/ResourceID.

        revision : Revision
            We could refer to the specific version of the resource.
            Take a look to documentation about #/components/schemas/Revision.

        if_none_match : typing.Optional[str]
            From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
            The **If-None-Match header** field is used to declare a list of identifiers
            that are required to fail matching all the current resource version
            identifiers as a pre-condition for executing the request on the server
            side. This is especially used in conjunction with an **\*** (asterix) that
            is matching all possible resource identifiers to ensure the initial
            creation of a resource. Other use cases are possible but rare.

            If the pre-condition fails the server will respond with status code **412**
            (Precondition Failed). See [RFC 9110 Section 13.1.2][rfc-9110-13.1.2] as
            well as [API Guideline Rule #182][api-182] for further details.

            [rfc-9110-13.1.2]: https://tools.ietf.org/html/rfc9110#section-13.1.2

            [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ApiKeyResource
            Result of api-key's resource Create or Update or Restore.

        Examples
        --------
        import asyncio

        from truvity_sdk import AsyncTruvityApi

        client = AsyncTruvityApi(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.api_keys.api_key_revision(
                id="id",
                revision=1,
                if_none_match="5db68c06-1a68-11e9-8341-68f728c1ba70",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api-keys/{jsonable_encoder(id)}/revisions/{jsonable_encoder(revision)}",
            method="GET",
            headers={"If-None-Match": str(if_none_match) if if_none_match is not None else None},
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(ApiKeyResource, parse_obj_as(type_=ApiKeyResource, object_=_response.json()))  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(BadRequestErrorBody, parse_obj_as(type_=BadRequestErrorBody, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(ProblemUnauthorized, parse_obj_as(type_=ProblemUnauthorized, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(ProblemForbidden, parse_obj_as(type_=ProblemForbidden, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(typing.Any, parse_obj_as(type_=typing.Any, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(ProblemInternalServerError, parse_obj_as(type_=ProblemInternalServerError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
