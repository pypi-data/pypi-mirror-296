def unlzw_chunked(file_obj, chunk_size=1024 * 1024):
    """
    This function decompresses data generated by the Unix compress utility (LZW compression, files with .Z suffix)
    in a chunked manner to handle large files efficiently.

    Args:
    file_obj (file-like object): The file-like object to read compressed data from.
    chunk_size (int): The size of the chunks to read from the file.

    Yields:
    bytes: Decompressed data chunks.
    """
    # Initialize variables
    prefix = [None] * 65536  # index to LZW prefix string
    suffix = [None] * 65536  # one-character LZW suffix

    # Process header
    header = file_obj.read(3)
    if len(header) < 3:
        raise ValueError("Invalid Input: Length of input too short for processing")

    if (header[0] != 0x1F) or (header[1] != 0x9D):
        raise ValueError("Invalid Header Flags Byte: Incorrect magic bytes")

    flags = header[2]

    if flags & 0x60:
        raise ValueError("Invalid Header Flags Byte: Flag byte contains invalid data")

    max_ = flags & 0x1F
    if (max_ < 9) or (max_ > 16):
        raise ValueError("Invalid Header Flags Byte: Max code size bits out of range")

    if max_ == 9:
        max_ = 10  # 9 doesn't really mean 9

    flags &= 0x80  # true if block compressed

    # Clear table, start at nine bits per symbol
    bits = 9
    mask = 0x1FF
    end = 256 if flags else 255

    # Set up: get the first 9-bit code, which is the first decompressed byte
    buf = int.from_bytes(file_obj.read(2), "little")
    final = prev = buf & mask  # code
    buf >>= bits
    left = 16 - bits
    if prev > 255:
        raise ValueError("Invalid Data: First code must be a literal")

    # We have output - yield the first byte
    yield bytes([final])

    # Decode codes
    mark = 3  # start of compressed data
    nxt = 5  # consumed five bytes so far
    while True:
        chunk = file_obj.read(chunk_size)
        if not chunk:
            break

        ba_in = bytearray(chunk)
        inlen = len(ba_in)
        nxt_start = 0

        while nxt_start < inlen:
            # If the table will be full after this, increment the code size
            if (end >= mask) and (bits < max_):
                # Flush unused input bits and bytes to next 8*bits bit boundary
                rem = (nxt - mark) % bits
                if rem:
                    rem = bits - rem
                    if rem >= inlen - nxt_start:
                        break
                    nxt_start += rem

                buf = 0
                left = 0

                # mark this new location for computing the next flush
                mark = nxt

                # increment the number of bits per symbol
                bits += 1
                mask <<= 1
                mask += 1

            # Get a code of bits
            buf += ba_in[nxt_start] << left
            nxt_start += 1
            left += 8
            if left < bits:
                if nxt_start == inlen:
                    break
                buf += ba_in[nxt_start] << left
                nxt_start += 1
                left += 8
            code = buf & mask
            buf >>= bits
            left -= bits

            # process clear code (256)
            if (code == 256) and flags:
                # Flush unused input bits and bytes to next 8*bits bit boundary
                rem = (nxt - mark) % bits
                if rem:
                    rem = bits - rem
                    if rem > inlen - nxt_start:
                        break
                    nxt_start += rem
                buf = 0
                left = 0

                # Mark this location for computing the next flush
                mark = nxt

                # Go back to nine bits per symbol
                bits = 9  # initialize bits and mask
                mask = 0x1FF
                end = 255  # empty table
                continue  # get next code

            # Process LZW code
            temp = code  # save the current code
            stack = []  # buffer for reversed match - empty stack

            # Special code to reuse last match
            if code > end:
                # Be picky on the allowed code here, and make sure that the
                # code we drop through (prev) will be a valid index so that
                # random input does not cause an exception
                if (code != end + 1) or (prev > end):
                    raise ValueError("Invalid Data: Invalid code detected")
                stack.append(final)
                code = prev

            # Walk through linked list to generate output in reverse order
            while code >= 256:
                stack.append(suffix[code])
                code = prefix[code]

            stack.append(code)
            final = code

            # Link new table entry
            if end < mask:
                end += 1
                prefix[end] = prev
                suffix[end] = final

            # Set previous code for next iteration
            prev = temp

            # Yield stack to output in forward order
            yield bytes(stack[::-1])

            nxt += nxt_start - (left // 8)
