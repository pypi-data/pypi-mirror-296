glossary_prompt = """
This is an array of Apache Atlas entities: {{entities}}. 

Review all entities and derive a single glossary entry that encompasses the principal topics referenced in the 
entities. Add this into the response as the value of the "glossary" key.

Review all entities and derive a list of relevant terms and relevant categories.

Associate the terms with a category by the category guid and with a glossary by the glossary guid.
Associate the categories with a glossary by the glossary guid.

Add the terms into the response as the value of the "terms" key.

Add the categories into the response as the value of the "categories" key.

Associate the terms with one or more collections, object_types, queries, columns, or fields using an 
AtlasGlossarySemanticAssignment.

Add the term-entity associations into the response as the value of the "relationships" key.

Review entities with a "typeName" of either "field" or "column" and assign any relevant data governance classifications, then add those to the 
"classification" entry. The classification entry should be a dictionary of entity qualified names whose value is an 
array of "PII","Confidential","Internal","Public","Restricted".

Use these definitions when considering classification:

Public Data: Information that is freely available to the public and poses no risk if disclosed. Examples include 
press releases and publicly available reports.

Internal Data: Data intended for internal use within the organization. While not highly sensitive, it should still be 
protected to avoid misuse. Examples include internal memos and internal project documents.

Confidential Data: Sensitive information that, if disclosed, could harm the organization or individuals. This data 
requires strict access controls. Examples include employee records, financial data, and proprietary information.

Restricted Data: Highly sensitive data that requires the highest level of protection due to its critical nature. 
Unauthorized access could lead to severe consequences. Examples include trade secrets, classified government 
information, and personal health information (PHI).

Personally Identifiable Information (PII): Data that can be used to identify an individual, either on its own or when 
combined with other information. This includes names, addresses, social security numbers, email addresses, 
and phone numbers. PII requires stringent protection measures to prevent identity theft and ensure privacy.

Enter the classifications into the response as the value of the "classifications": key.

Review column entities and assign the best data type, using this list of self-describing data types:

[ 
    "aba",
    "add_provider",
    "address",
    "administrative_unit",
    "am_pm",
    "android_platform_token",
    "ascii_company_email",
    "ascii_email",
    "ascii_free_email",
    "ascii_safe_email",
    "bank_country",
    "basic_phone_number",
    "bban",
    "binary",
    "boolean",
    "bothify",
    "bs",
    "building_number",
    "cache_pattern",
    "catch_phrase",
    "century",
    "chrome",
    "city",
    "city_prefix",
    "city_suffix",
    "color",
    "color_hsl",
    "color_hsv",
    "color_name",
    "color_rgb",
    "color_rgb_float",
    "company",
    "company_email",
    "company_suffix",
    "coordinate",
    "country",
    "country_calling_code",
    "country_code",
    "credit_card_expire",
    "credit_card_full",
    "credit_card_number",
    "credit_card_provider",
    "credit_card_security_code",
    "cryptocurrency",
    "cryptocurrency_code",
    "cryptocurrency_name",
    "csv",
    "currency",
    "currency_code",
    "currency_name",
    "currency_symbol",
    "current_country",
    "current_country_code",
    "date",
    "date_between",
    "date_between_dates",
    "date_object",
    "date_of_birth",
    "date_this_century",
    "date_this_decade",
    "date_this_month",
    "date_this_year",
    "date_time",
    "date_time_ad",
    "date_time_between",
    "date_time_between_dates",
    "date_time_this_century",
    "date_time_this_decade",
    "date_time_this_month",
    "date_time_this_year",
    "day_of_month",
    "day_of_week",
    "del_arguments",
    "dga",
    "domain_name",
    "domain_word",
    "dsv",
    "ean",
    "ean13",
    "ean8",
    "ein",
    "email",
    "emoji",
    "enum",
    "factories",
    "file_extension",
    "file_name",
    "file_path",
    "firefox",
    "first_name",
    "first_name_female",
    "first_name_male",
    "first_name_nonbinary",
    "fixed_width",
    "format",
    "free_email",
    "free_email_domain",
    "future_date",
    "future_datetime",
    "generator_attrs",
    "get_arguments",
    "get_formatter",
    "get_providers",
    "get_words_list",
    "hex_color",
    "hexify",
    "hostname",
    "http_method",
    "http_status_code",
    "iana_id",
    "iban",
    "image",
    "image_url",
    "internet_explorer",
    "invalid_ssn",
    "ios_platform_token",
    "ipv4",
    "ipv4_network_class",
    "ipv4_private",
    "ipv4_public",
    "ipv6",
    "isbn10",
    "isbn13",
    "iso8601",
    "items",
    "itin",
    "job",
    "json",
    "json_bytes",
    "language_code",
    "language_name",
    "last_name",
    "last_name_female",
    "last_name_male",
    "last_name_nonbinary",
    "latitude",
    "latlng",
    "lexify",
    "license_plate",
    "linux_platform_token",
    "linux_processor",
    "local_latlng",
    "locale",
    "locales",
    "localized_ean",
    "localized_ean13",
    "localized_ean8",
    "location_on_land",
    "longitude",
    "mac_address",
    "mac_platform_token",
    "mac_processor",
    "md5",
    "military_apo",
    "military_dpo",
    "military_ship",
    "military_state",
    "mime_type",
    "month",
    "month_name",
    "msisdn",
    "name",
    "name_female",
    "name_male",
    "name_nonbinary",
    "nic_handle",
    "nic_handles",
    "null_boolean",
    "numerify",
    "opera",
    "optional",
    "paragraph",
    "paragraphs",
    "parse",
    "passport_dates",
    "passport_dob",
    "passport_full",
    "passport_gender",
    "passport_number",
    "passport_owner",
    "password",
    "past_date",
    "past_datetime",
    "phone_number",
    "port_number",
    "postalcode",
    "postalcode_in_state",
    "postalcode_plus4",
    "postcode",
    "postcode_in_state",
    "prefix",
    "prefix_female",
    "prefix_male",
    "prefix_nonbinary",
    "pricetag",
    "profile",
    "provider",
    "providers",
    "psv",
    "pybool",
    "pydecimal",
    "pydict",
    "pyfloat",
    "pyint",
    "pyiterable",
    "pylist",
    "pyobject",
    "pyset",
    "pystr",
    "pystr_format",
    "pystruct",
    "pytimezone",
    "pytuple",
    "random",
    "random_choices",
    "random_digit",
    "random_digit_above_two",
    "random_digit_not_null",
    "random_digit_not_null_or_empty",
    "random_digit_or_empty",
    "random_element",
    "random_elements",
    "random_int",
    "random_letter",
    "random_letters",
    "random_lowercase_letter",
    "random_number",
    "random_sample",
    "random_uppercase_letter",
    "randomize_nb_elements",
    "rgb_color",
    "rgb_css_color",
    "ripe_id",
    "safari",
    "safe_color_name",
    "safe_domain_name",
    "safe_email",
    "safe_hex_color",
    "sbn9",
    "secondary_address",
    "seed",
    "seed_instance",
    "seed_locale",
    "sentence",
    "sentences",
    "set_arguments",
    "set_formatter",
    "sha1",
    "sha256",
    "simple_profile",
    "slug",
    "ssn",
    "state",
    "state_abbr",
    "street_address",
    "street_name",
    "street_suffix",
    "suffix",
    "suffix_female",
    "suffix_male",
    "suffix_nonbinary",
    "swift",
    "swift11",
    "swift8",
    "tar",
    "text",
    "texts",
    "time",
    "time_delta",
    "time_object",
    "time_series",
    "timezone",
    "tld",
    "tsv",
    "unique",
    "unix_device",
    "unix_partition",
    "unix_time",
    "upc_a",
    "upc_e",
    "uri",
    "uri_extension",
    "uri_page",
    "uri_path",
    "url",
    "user_agent",
    "user_name",
    "uuid4",
    "vin",
    "weights",
    "windows_platform_token",
    "word",
    "words",
    "xml",
    "year",
    "zip",
    "zipcode",
    "zipcode_in_state",
    "zipcode_plus4"
]

Enter the data type into the response as the value of the "data_types": key.

Review entities with a "typeName" equal to "field" and assign the best data type, using this list of self-describing data types:

[ 
    "aba",
    "add_provider",
    "address",
    "administrative_unit",
    "am_pm",
    "android_platform_token",
    "ascii_company_email",
    "ascii_email",
    "ascii_free_email",
    "ascii_safe_email",
    "bank_country",
    "basic_phone_number",
    "bban",
    "binary",
    "boolean",
    "bothify",
    "bs",
    "building_number",
    "cache_pattern",
    "catch_phrase",
    "century",
    "chrome",
    "city",
    "city_prefix",
    "city_suffix",
    "color",
    "color_hsl",
    "color_hsv",
    "color_name",
    "color_rgb",
    "color_rgb_float",
    "company",
    "company_email",
    "company_suffix",
    "coordinate",
    "country",
    "country_calling_code",
    "country_code",
    "credit_card_expire",
    "credit_card_full",
    "credit_card_number",
    "credit_card_provider",
    "credit_card_security_code",
    "cryptocurrency",
    "cryptocurrency_code",
    "cryptocurrency_name",
    "csv",
    "currency",
    "currency_code",
    "currency_name",
    "currency_symbol",
    "current_country",
    "current_country_code",
    "date",
    "date_between",
    "date_between_dates",
    "date_object",
    "date_of_birth",
    "date_this_century",
    "date_this_decade",
    "date_this_month",
    "date_this_year",
    "date_time",
    "date_time_ad",
    "date_time_between",
    "date_time_between_dates",
    "date_time_this_century",
    "date_time_this_decade",
    "date_time_this_month",
    "date_time_this_year",
    "day_of_month",
    "day_of_week",
    "del_arguments",
    "dga",
    "domain_name",
    "domain_word",
    "dsv",
    "ean",
    "ean13",
    "ean8",
    "ein",
    "email",
    "emoji",
    "enum",
    "factories",
    "file_extension",
    "file_name",
    "file_path",
    "firefox",
    "first_name",
    "first_name_female",
    "first_name_male",
    "first_name_nonbinary",
    "fixed_width",
    "format",
    "free_email",
    "free_email_domain",
    "future_date",
    "future_datetime",
    "generator_attrs",
    "get_arguments",
    "get_formatter",
    "get_providers",
    "get_words_list",
    "hex_color",
    "hexify",
    "hostname",
    "http_method",
    "http_status_code",
    "iana_id",
    "iban",
    "image",
    "image_url",
    "internet_explorer",
    "invalid_ssn",
    "ios_platform_token",
    "ipv4",
    "ipv4_network_class",
    "ipv4_private",
    "ipv4_public",
    "ipv6",
    "isbn10",
    "isbn13",
    "iso8601",
    "items",
    "itin",
    "job",
    "json",
    "json_bytes",
    "language_code",
    "language_name",
    "last_name",
    "last_name_female",
    "last_name_male",
    "last_name_nonbinary",
    "latitude",
    "latlng",
    "lexify",
    "license_plate",
    "linux_platform_token",
    "linux_processor",
    "local_latlng",
    "locale",
    "locales",
    "localized_ean",
    "localized_ean13",
    "localized_ean8",
    "location_on_land",
    "longitude",
    "mac_address",
    "mac_platform_token",
    "mac_processor",
    "md5",
    "military_apo",
    "military_dpo",
    "military_ship",
    "military_state",
    "mime_type",
    "month",
    "month_name",
    "msisdn",
    "name",
    "name_female",
    "name_male",
    "name_nonbinary",
    "nic_handle",
    "nic_handles",
    "null_boolean",
    "numerify",
    "opera",
    "optional",
    "paragraph",
    "paragraphs",
    "parse",
    "passport_dates",
    "passport_dob",
    "passport_full",
    "passport_gender",
    "passport_number",
    "passport_owner",
    "password",
    "past_date",
    "past_datetime",
    "phone_number",
    "port_number",
    "postalcode",
    "postalcode_in_state",
    "postalcode_plus4",
    "postcode",
    "postcode_in_state",
    "prefix",
    "prefix_female",
    "prefix_male",
    "prefix_nonbinary",
    "pricetag",
    "profile",
    "provider",
    "providers",
    "psv",
    "pybool",
    "pydecimal",
    "pydict",
    "pyfloat",
    "pyint",
    "pyiterable",
    "pylist",
    "pyobject",
    "pyset",
    "pystr",
    "pystr_format",
    "pystruct",
    "pytimezone",
    "pytuple",
    "random",
    "random_choices",
    "random_digit",
    "random_digit_above_two",
    "random_digit_not_null",
    "random_digit_not_null_or_empty",
    "random_digit_or_empty",
    "random_element",
    "random_elements",
    "random_int",
    "random_letter",
    "random_letters",
    "random_lowercase_letter",
    "random_number",
    "random_sample",
    "random_uppercase_letter",
    "randomize_nb_elements",
    "rgb_color",
    "rgb_css_color",
    "ripe_id",
    "safari",
    "safe_color_name",
    "safe_domain_name",
    "safe_email",
    "safe_hex_color",
    "sbn9",
    "secondary_address",
    "seed",
    "seed_instance",
    "seed_locale",
    "sentence",
    "sentences",
    "set_arguments",
    "set_formatter",
    "sha1",
    "sha256",
    "simple_profile",
    "slug",
    "ssn",
    "state",
    "state_abbr",
    "street_address",
    "street_name",
    "street_suffix",
    "suffix",
    "suffix_female",
    "suffix_male",
    "suffix_nonbinary",
    "swift",
    "swift11",
    "swift8",
    "tar",
    "text",
    "texts",
    "time",
    "time_delta",
    "time_object",
    "time_series",
    "timezone",
    "tld",
    "tsv",
    "unique",
    "unix_device",
    "unix_partition",
    "unix_time",
    "upc_a",
    "upc_e",
    "uri",
    "uri_extension",
    "uri_page",
    "uri_path",
    "url",
    "user_agent",
    "user_name",
    "uuid4",
    "vin",
    "weights",
    "windows_platform_token",
    "word",
    "words",
    "xml",
    "year",
    "zip",
    "zipcode",
    "zipcode_in_state",
    "zipcode_plus4"
]

Enter the data type into the response as the value of the "data_types": key.

The complete answer must be a JSON dictionary following this format:

{
  "glossary": {
    "guid": "<temporary guid as a unique negative number>",
    "qualifiedName": "<<the name of the glossary in title case without spaces>@{{supergraph_name}}>",
    "name": "<the name of the glossary>",
    "shortDescription": "<a short description of the glossary>",
    "longDescription": "<a longer description of the glossary>",
    "language": "English",
    "usage": "<a short description of when to use this glossary>"
  },
  "categories": [
    {
      "guid": "<temporary guid as a unique negative number>",
      "qualifiedName": "<<the name of the term in category in title case without spaces>@.<glossary name in lower case>.{{supergraph_name}}>",
      "name": "<the category name>",
      "shortDescription": "<a short description of the category>",
      "longDescription": "<a long description of the category>",
      "anchor": {
        "glossaryGuid": "<the guid of the glossary>"
      }
    }
  ],
  "terms": [
    {
      "guid": "<temporary guid as a unique negative number>",
      "qualifiedName": "<<the name of the term in title case without spaces>@.<glossary name in lower case>.{{supergraph_name}}>",
      "name": "<the term>",
      "shortDescription": "<a short description of the term>",
      "longDescription": "<a long description of the term>",
      "examples": [
        "<an array of examples of using the term>"
      ],
      "abbreviation": "<an abbreviation of the term>",
      "usage": "<describe the scenarios where the term might be used>",
      "status": "ACTIVE",
      "anchor": {
        "glossaryGuid": "<the guid of the glossary>"
      },
      "categories": [
        {
          "categoryGuid": "<the category guid associated with the term>"
        }
      ]
    }
  ],
  "relationships": [
    {
      "typeName": "AtlasGlossarySemanticAssignment",
      "end1": {
        "typeName": "AtlasGlossaryTerm",
        "guid": "<glossary_term_guid>"
      },
      "end2": {
        "typeName": "<entity_type_name>",
        "uniqueAttributes": {
          "qualifiedName": "<entity_qualified_name>"
        }
      }
    }
  ],
  "classifications": {
    "<entity qualified name>": [
      "<classification category>"
    ]
  },
  "data_types": {
    "<entity qualified name>": "<data type>"
}
"""
