from typing import List

from ._bindings import BaseAlgorithm, Data, IncompatibleError


class Algorithm(BaseAlgorithm):
    """
    Base class for Algorithms.

    An Algorithm accepts certain Data as input and performs some
    computation on it.

    Example for an algorithm that takes exactly one image and prints
    its name:

    >>> class MyAlgorithm(Algorithm):
    ...     def __init__(self, image):
    ...         super().__init__()
    ...         self.image = image
    ...
    ...     @classmethod
    ...     def convert_input(cls, data):
    ...         images = data.images()
    ...         if len(images) == 1 and len(data) == 1:
    ...             return [images[0]]
    ...         raise IncompatibleError('Requires exactly one image')
    ...
    ...     def compute(self):
    ...         print(self.image.name)

    In order to make an Algorithm available to the ImFusion Suite (i.e. the
    context menu when right-clicking on selected data), it has to be registered to the
    ApplicationController:

    >>> imfusion.register_algorithm('Python.MyAlgorithm','My Algorithm', MyAlgorithm)  # DOCTEST: +skip

    If the Algorithm is created through the ImFusion Suite, the
    :meth:`convert_input` method is called to determine if the Algorithm
    is compatible with the desired input data.
    If this method does not raise an exception, the Algorithm is initialized
    with the data returned by :meth:`convert_input`. The implementation is
    similar to this:

    .. code-block:: python

       try:
           input = MyAlgorithm.convert_input(some_data)
           return MyAlgorithm(*input)
       except IncompatibleError:
           return None

    The Algorithm class also provides default implementations for the
    :meth:`configuration` and :meth:`configure` methods that automatically
    serialize attributes created with :meth:`add_param`.
    """
    def __init__(self):
        BaseAlgorithm.__init__(self)  # important to initialize the C++ backend
        self._params = []

    @classmethod
    def convert_input(cls, data: List[Data]) -> List[Data]:
        """
        Convert the given DataList to a valid input for the algorithm.

        Must be overridden in derived classes.
        Raise an :exc:`IncompatibleError` if the given data does not exactly
        match the required input of the algorithm.
        Should return a list, a dict or a generator.
        """
        raise NotImplementedError('The algorithm did not implement its convert_input class method.')

    def add_param(self, name, value, attributes=''):
        """
        Add a new parameter to the object.

        The parameter is available as a new attribute with the given name
        and value. The attribute will be configured automatically.

        >>> class MyAlgorithm(Algorithm):
        ...     def __init__(self):
        ...         super().__init__()
        ...         self.add_param('x', 5)
        >>> a = MyAlgorithm()
        >>> a.x
        5
        """
        setattr(self, name, value)
        self._params.append((name, attributes))

    def output(self):
        """
        Return the output generated by the previous call to :meth:`compute`.
        The returned type must be a list of Data objects!
        The default implementation returns an empty list.
        """
        return []

    def configuration(self, p):
        if not p:
            return

        for name, attributes in self._params:
            p[name] = getattr(self, name)
            if attributes:
                p.set_param_attributes(name, attributes)

    def configure(self, p):
        if not p:
            return

        for name, _ in self._params:
            value = p.param(name, getattr(self, name))
            if value is not None:
                setattr(self, name, value)
