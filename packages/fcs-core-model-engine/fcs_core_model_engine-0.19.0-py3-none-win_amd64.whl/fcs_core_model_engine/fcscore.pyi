
import enum
from typing import ( 
    List,
    Tuple
)

def get_backend_api_version() -> str: ...
def check_api_compatibility(client_version: str) -> bool: ...

# OpenCascade Legacy Types
class TopoDS_Shape: ...
class TopAbs_ShapeEnum(enum.Enum):
	COMPSOLID : TopAbs_ShapeEnum
	SOLID : TopAbs_ShapeEnum
	SHELL : TopAbs_ShapeEnum
	FACE : TopAbs_ShapeEnum
	WIRE : TopAbs_ShapeEnum
	EDGE : TopAbs_ShapeEnum
	VERTEX : TopAbs_ShapeEnum
	SHAPE : TopAbs_ShapeEnum

class ExplodeType(enum.Enum):
	EXPLODE_OLD_INCLUDE_MAIN : ExplodeType
	EXPLODE_NEW_INCLUDE_MAIN : ExplodeType
	EXPLODE_NEW_EXCLUDE_MAIN : ExplodeType

class ComparisonCondition(enum.Enum):
	CC_GT : ComparisonCondition
	CC_GE : ComparisonCondition
	CC_LT : ComparisonCondition
	CC_LE : ComparisonCondition

class ShapeKind(enum.Enum):
	SK_NO_SHAPE : ShapeKind 
	SK_COMPOUND : ShapeKind 
	SK_COMPSOLID : ShapeKind 
	SK_SHELL : ShapeKind 
	SK_WIRE : ShapeKind 
	SK_SPHERE : ShapeKind 
	SK_CYLINDER : ShapeKind 
	SK_BOX : ShapeKind
	SK_ROTATED_BOX : ShapeKind 
	SK_TORUS : ShapeKind
	SK_CONE : ShapeKind 
	SK_POLYHEDRON : ShapeKind 
	SK_SOLID : ShapeKind
	SK_SPHERE2D : ShapeKind
	SK_CYLINDER2D : ShapeKind
	SK_TORUS2D : ShapeKind
	SK_CONE2D : ShapeKind
	SK_DISK_CIRCLE : ShapeKind
	SK_DISK_ELLIPSE : ShapeKind
	SK_POLYGON : ShapeKind
	SK_PLANE : ShapeKind
	SK_PLANAR : ShapeKind
	SK_FACE : ShapeKind 
	SK_CIRCLE : ShapeKind
	SK_ARC_CIRCLE : ShapeKind
	SK_ELLIPSE : ShapeKind
	SK_ARC_ELLIPSE : ShapeKind
	SK_LINE : ShapeKind
	SK_SEGMENT : ShapeKind
	SK_EDGE : ShapeKind
	SK_VERTEX : ShapeKind
	SK_LCS : ShapeKind 
	SK_ADVANCED : ShapeKind

class SICheckLevel(enum.Enum):
	SI_V_V : SICheckLevel # only V/V interferences
	SI_V_E : SICheckLevel # V/V and V/E interferences
	SI_E_E : SICheckLevel # V/V, V/E and E/E interferences
	SI_V_F : SICheckLevel # V/V, V/E, E/E and V/F interferences
	SI_E_F : SICheckLevel # V/V, V/E, E/E, V/F and E/F interferences
	SI_ALL : SICheckLevel # All


class GEOM_Object: 
	def is_null(self) -> bool: ...
	def is_shape_null(self) -> bool: ...
	def get_shape_copy(self) -> TopoDS_Shape: ...
class TColStd_HSequenceOfTransient: ...
class GEOM_Field: ...
class GEOMAlgo_State(enum.Enum):
	GEOMAlgo_ST_UNKNOWN : GEOMAlgo_State
	GEOMAlgo_ST_IN : GEOMAlgo_State
	GEOMAlgo_ST_OUT : GEOMAlgo_State
	GEOMAlgo_ST_ON : GEOMAlgo_State
	GEOMAlgo_ST_ONIN : GEOMAlgo_State
	GEOMAlgo_ST_ONOUT : GEOMAlgo_State
	GEOMAlgo_ST_INOUT : GEOMAlgo_State

# Shared Core Classes

class XYZ:
    def __init__(self, x: float = 0, y: float = 0, z: float = 0):
        """
        Initializes the XYZ with the given coordinates.

        :param x: X-coordinate.
        :param y: Y-coordinate.
        :param z: Z-coordinate.
        """
        ...

    def X(self) -> float:
        """
        Gets the X-coordinate.

        :return: X-coordinate.
        """
        ...
        
    def Y(self) -> float:
        """
        Gets the Y-coordinate.

        :return: Y-coordinate.
        """
        ...

    def Z(self) -> float:
        """
        Gets the Z-coordinate.

        :return: Z-coordinate.
        """
        ...

    def __add__(self, other: 'XYZ') -> 'XYZ':
        """
        Adds two XYZ vectors.

        :param other: Another XYZ vector.
        :return: Resulting XYZ vector.
        """
        ...

    def __sub__(self, other: 'XYZ') -> 'XYZ':
        """
        Subtracts two XYZ vectors.

        :param other: Another XYZ vector.
        :return: Resulting XYZ vector.
        """
        ...

    def __mul__(self, scalar: float) -> 'XYZ':
        """
        Multiplies XYZ vector by a scalar.

        :param scalar: Scalar value.
        :return: Resulting XYZ vector.
        """
        ...

    def __eq__(self, other: 'XYZ') -> bool:
        """
        Checks equality of two XYZ vectors.

        :param other: Another XYZ vector.
        :return: True if equal, False otherwise.
        """
        ...

    def __ne__(self, other: 'XYZ') -> bool:
        """
        Checks inequality of two XYZ vectors.

        :param other: Another XYZ vector.
        :return: True if not equal, False otherwise.
        """
        ...

    def magnitude(self) -> float:
        """
        Computes the magnitude of the XYZ vector.

        :return: Magnitude.
        """
        ...

    def __repr__(self) -> str:
        """
        String representation of the XYZ vector.

        :return: String representation.
        """
        ...

class Color:
	R : int = ...
	G : int = ...
	B : int = ...

class ColorSelection(enum.Enum):
	DEFAULT : Color 
	RED : Color 
	LIME : Color 
	BLUE : Color 
	YELLOW : Color 
	CYAN : Color 
	MAGENTA  : Color 
	GRAY : Color
	MAROON : Color 
	OLIVE : Color
	GREEN : Color 
	PURPLE : Color 
	TEAL : Color	
	NAVY : Color

class Palette(object):
	@staticmethod
	def get_color(selection: ColorSelection) -> Color: ...
	@staticmethod
	def get_specific_color(red: int, green: int, blue: int) -> Color: ...
	@staticmethod
	def are_same(c1: Color, c2: Color) -> bool: ...


class SpecificElementType(enum.Enum):
	"""
	Specific element types that follow the GMSH convention.
	"""
	LINE_2NODE = 1
	TRIANGLE_3NODE = 2
	QUADRANGLE_4NODE = 3
	TETRAHEDRON_4NODE = 4
	HEXAHEDRON_8NODE = 5
	PRISM_6NODE = 6
	PYRAMID_5NODE = 7
	LINE_3NODE_SECOND_ORDER = 8
	TRIANGLE_6NODE_SECOND_ORDER = 9
	QUADRANGLE_9NODE_SECOND_ORDER = 10
	TETRAHEDRON_10NODE_SECOND_ORDER = 11
	HEXAHEDRON_27NODE_SECOND_ORDER = 12
	PRISM_18NODE_SECOND_ORDER = 13
	PYRAMID_14NODE_SECOND_ORDER = 14
	POINT_1NODE = 15
	QUADRANGLE_8NODE_SECOND_ORDER = 16
	HEXAHEDRON_20NODE = 17
	PRISM_15NODE_SECOND_ORDER = 18

class MeshElementOrder(enum.Enum):
	FIRST: MeshElementOrder
	SECOND: MeshElementOrder
      
class Target2DElementType(enum.Enum):
    """
	Available easy-to-understand 2D element type choice for meshing.
	"""
    TRIA: Target2DElementType
    QUAD: Target2DElementType

class Mesh2DAlgorithmChoice(enum.Enum):
	MESH_ADAPT: Mesh2DAlgorithmChoice
	DELAUNAY: Mesh2DAlgorithmChoice
	FRONTAL: Mesh2DAlgorithmChoice
	BAMG: Mesh2DAlgorithmChoice
	DELAUNAY_QUAD: Mesh2DAlgorithmChoice
      
class Target3DElementType(enum.Enum):
    """
	Available easy-to-understand 3D element type choice for meshing.
	"""
    TETRA: Target3DElementType
    HEXA: Target3DElementType
	
class Mesh3DAlgorithmChoice(enum.Enum):
	BASE_TETRAHEDRALIZATION: Mesh3DAlgorithmChoice

class Mesh2DSettings:
    def __init__(self,
                 element_size: float, 
				 element_type: Target2DElementType, 
				 algorithm_choice: Mesh2DAlgorithmChoice, 
				 element_order: MeshElementOrder):
        """
        Initializes the Mesh2DSettings with the given parameters.

        :param element_size: Size of the elements.
        :param element_type: Type of the 2D elements.
        :param algorithm_choice: Choice of 2D mesh algorithm.
        :param element_order: Order of the elements.
        """
        ...

    def set_element_size(self, element_size: float):
        """
        Sets the size of the elements.

        :param element_size: Size of the elements.
        """
        ...

    def set_element_type(self, element_type: Target2DElementType):
        """
        Sets the type of the 2D elements.

        :param element_type: Type of the 2D elements.
        """
        ...

    def set_element_order(self, element_order: MeshElementOrder):
        """
        Sets the order of the elements.

        :param element_order: Order of the elements.
        """
        ...

    def get_element_size(self) -> float:
        """
        Gets the size of the elements.

        :return: Size of the elements.
        """
        ...

    def get_element_type(self) -> Target2DElementType:
        """
        Gets the type of the 2D elements.

        :return: Type of the 2D elements.
        """
        ...

    def get_element_order(self) -> MeshElementOrder:
        """
        Gets the order of the elements.

        :return: Order of the elements.
        """
        ...

    def get_mesh_algorithm(self) -> Mesh2DAlgorithmChoice:
        """
        Gets the choice of 2D mesh algorithm.

        :return: Choice of 2D mesh algorithm.
        """
        ...

class Mesh3DSettings:
    def __init__(self, 
                 element_size: float, 
                 element_type: Target3DElementType, 
                 algorithm_choice: Mesh3DAlgorithmChoice, 
                 element_order: MeshElementOrder):
        """
        Initializes the Mesh3DSettings with the given parameters.

        :param element_size: Size of the elements.
        :param element_type: Type of the 3D elements.
        :param algorithm_choice: Choice of 3D mesh algorithm.
        :param element_order: Order of the elements.
        """
        ...

    def set_element_size(self, element_size: float):
        """
        Sets the size of the elements.

        :param element_size: Size of the elements.
        """
        ...

    def set_element_type(self, element_type: Target3DElementType):
        """
        Sets the type of the 3D elements.

        :param element_type: Type of the 3D elements.
        """
        ...

    def set_element_order(self, element_order: MeshElementOrder):
        """
        Sets the order of the elements.

        :param element_order: Order of the elements.
        """
        ...

    def get_element_size(self) -> float:
        """
        Gets the size of the elements.

        :return: Size of the elements.
        """
        ...

    def get_element_type(self) -> Target3DElementType:
        """
        Gets the type of the 3D elements.

        :return: Type of the 3D elements.
        """
        ...

    def get_element_order(self) -> MeshElementOrder:
        """
        Gets the order of the elements.

        :return: Order of the elements.
        """
        ...

    def get_mesh_algorithm(self) -> Mesh3DAlgorithmChoice:
        """
        Gets the choice of 3D mesh algorithm.

        :return: Choice of 3D mesh algorithm.
        """
        ...

class MeshFactory:
	def __init__(self): ...
	@staticmethod
	def set_export_directory(export_path: str): ...
	@staticmethod
	def get_export_directory() -> str: ...
	def create_2d_mesh(self, geom_object_face: GEOM_Object, mesh_settings: Mesh2DSettings) -> Mesh: ...

class Mesher3D:
	@staticmethod
	def generate_3d_mesh(boundary_element_ids: set, mesh_settings: Mesh3DSettings) -> Mesh: ...
	
class MeshReferenceType(enum.Enum):
	UNDETERMINED: MeshReferenceType
	ELEMENT_SET: MeshReferenceType
	NODE_SET: MeshReferenceType

class Node:
    def __init__(self, node_id: int, position: XYZ):
        """
        Initializes the Node with the given ID and position.

        :param node_id: ID of the node.
        :param position: Position of the node.
        """

    NodeId: int
    Position: XYZ


class Element:
    def __init__(self, element_id: int, nodes: list[Node], element_type: SpecificElementType):
        """
        Initializes the Element with the given ID, nodes, and element type.

        :param element_id: ID of the element.
        :param nodes: List of nodes in the element.
        :param element_type: Type of the element.
        """

    ElementId: int
    NodeIDs: list[int]
    ElementType: SpecificElementType

class MeshFileFormat(enum.Enum):
	MSH: MeshFileFormat
	MED: MeshFileFormat
	STL: MeshFileFormat
	INP: MeshFileFormat
	
class Mesh:
	def __init__(self, open_new_mesh_model: bool=False): ...
	def set_file_name(self, file_name: str) -> None: ...
	def get_file_name(self) -> str: ...
	def load_mesh(self, mesh_directory: str, mesh_file_format: MeshFileFormat) -> bool: ...
	def write_mesh(self, export_directory: str, mesh_file_format: MeshFileFormat) -> str: ...
	
class MasterMesh:
    @staticmethod
    def is_node_orphan(node_id: int) -> bool:
        """
        Places a standalone mesh and inserts it into the master mesh.
        :return: True, if the node is orphan.
        """
        ...

    @staticmethod
    def create_node_set(comp_id: int, node_ids: set[int]) -> NodeSet:
        """
        Constructs a node set from the provided node IDs.

        :param comp_id: Unique identifier of the mesh instance.
        :param node_ids: Element IDs that we need to group together.
        :return: Pointer to newly constructed node set.
        """
        ...

    @staticmethod
    def create_element_set(comp_id: int, element_ids: set[int]) -> ElementSet:
        """
        Constructs an element set from the provided element IDs.

        :param comp_id: Unique identifier of the mesh instance.
        :param element_ids: Element IDs that we need to group together.
        :return: Pointer to newly constructed element set.
        """
        ...

    @staticmethod
    def insert_mesh_reference(mesh_reference: MeshReference) -> bool:
        """
        Inserts a mesh reference into the master mesh.

        :param mesh_reference: Reference mesh to be inserted.
        :return: True if insertion was successful.
        """
        ...

    @staticmethod
    def delete_mesh_set(comp_id: int) -> bool:
        """
        Deletes the mesh reference for a given component ID.

        :param comp_id: Unique identifier of the mesh reference.
        :return: True if deletion was successful.
        """
        ...

    @staticmethod
    def add_node(xyz: XYZ) -> Node:
        """
        Adds a new node to the master mesh.

        :param XYZ: position of the node to be placed
        :return: Newly placed Node's definition
        """
        ...
        
    @staticmethod
    def get_node_definition(node_id: int) -> Node:
        ...

    @staticmethod
    def delete_nodes(
          node_ids: set[int],
          removed_associated_elements: set[int],
          removed_orphaned_node_ids: set[int]) -> bool:
        """
        Deletes nodes from the master mesh.

        :param mesh_component_id: Helper ID of the mesh component from which nodes were deleted.
        :param node_ids: Node IDs to be deleted.
        :param removed_associated_elements: Set to store IDs of removed associated elements.
        :param removed_orphaned_node_ids: Populates this empty list with the orphaned node IDs.
        :return: True if deletion was successful.
        """
        ...

    @staticmethod
    def add_element(mesh_component_id: int, spec_elem_type: SpecificElementType, node_ids: list[int]) -> Element:
        """
        Adds an element to the master mesh.

        :param mesh_component_id: The mesh component that was active when the element was created.
        :param spec_elem_type: Specific element type for the element.
        :param node_ids: Collection of node IDs used to construct the element.
        :return: Newly placed element information
        """
        ...

    @staticmethod
    def delete_elements(
		  element_ids: set[int],
          removed_orphaned_ids: list[int]) -> bool:
        """
        Deletes elements from the master mesh.

        :param element_ids: Element IDs to be deleted.
        :param removed_orphaned_ids: Will populate this list with NodeIDs that were removed
        :return: True if deletion was successful.
        """
        ...

    @staticmethod
    def merge_nodes(
        slave_node_component_id: int, 
        slave_node_id: int, 
        master_node_component_id: int, 
        master_node_id: int, 
        removed_element_ids: list[int], 
        remove_duplicates: bool
    ) -> list[Element]:
        """
        Merges the slave node with the master node. Optionally removes duplicates and modifies elements accordingly.

        :param slave_node_component_id: Component ID of the slave node.
        :param slave_node_id: ID of the slave node.
        :param master_node_component_id: Component ID of the master node.
        :param master_node_id: ID of the master node.
        :param removed_element_ids: List to store IDs of removed elements.
        :param remove_duplicates: Flag to indicate whether to remove duplicates.
        :return: List of added elements.
        """
        ...

    @staticmethod
    def reassign_elements_and_nodes(
        source_node_ids: set[int], 
        source_element_ids: set[int], 
        source_component_id: int, 
        target_component_id: int, 
        perform_cut_paste: bool
    ) -> tuple[list[Node], list[Element], list[int]]:
        """
        Reassigns elements and nodes from the source component to the target component.

        :param source_node_ids: Set of source node IDs.
        :param source_element_ids: Set of source element IDs.
        :param source_component_id: ID of the source component.
        :param target_component_id: ID of the target component.
        :param perform_cut_paste: Flag to indicate whether to perform cut-paste operation.
        :return: A tuple containing a list of new nodes, a list of new elements, 
            and a list of orphaned node IDs
        """
        ...

    @staticmethod
    def export_mesh_file(mesh_file_format: MeshFileFormat, mesh_component_id: int = -1) -> bool:
        """
        Exports a MED file with the sets defined there.

		:param mesh_file_format: The desired output format that we want to export the mesh as.
        :param mesh_component_id: If specified, writes out a mesh file for the corresponding component mesh ID.
        :return: True if the file export was successful.
        """
        ...

class MeshReference:
	def get_component_id(self) -> int: ...
	def add_node_id(self, node_id: int) -> None: ...
	def add_element_id(self, element_id: int) -> None: ...
	def get_node_ids(self) -> set: ...
	def set_node_ids(self, node_ids: set) -> None: ...
	def get_element_ids(self) -> set: ...
	def set_element_ids(self, element_ids: set) -> None: ...
	def get_mesh_reference_type(self) -> MeshReferenceType: ...
	def modify_constituent_ids(self, 
							added_element_ids: set,
							removed_element_ids: set,
							added_node_ids: set,
							removed_node_ids: set) -> bool: ...

class ComponentMesh(MeshReference):
	def write_mesh_asset_file(self) -> None: ...

class ElementSet(MeshReference): ...
class NodeSet(MeshReference): ...

# Model Operations
class StoredEntityType(enum.Enum):
    INVALID_ENTITY : StoredEntityType
    STORAGE_ONLY_ENTITY : StoredEntityType
    GEOMETRY_ENTITY : StoredEntityType
    MESH_COMPONENT_ENTITY : StoredEntityType
    MESH_SET_ENTITY : StoredEntityType
    ANALYSIS_ENTITY : StoredEntityType
    REFERENCE_ENTITY : StoredEntityType
    INFORMATION : StoredEntityType

class ItemType(enum.Enum):
    INVALID_ITEM: ItemType
    ITEM_TYPE_FILE: ItemType
    ITEM_TYPE_FOLDER: ItemType
    ITEM_TYPE_CONTAINER: ItemType

class ModelItemInstance:
    def is_valid(self) -> bool: ...
    def get_error_message(self) -> str: ...
    def get_instance_id(self) -> int: ...
    def has_visibility_control(self) -> bool: ...
    def get_is_visible(self) -> bool: ...
    def get_item_color(self) -> object: ...
    def get_item_display_name(self) -> str: ...
    def get_item_opacity(self) -> float: ...
    def get_stored_entity_type(self) -> StoredEntityType: ...
    def get_item_type(self) -> object: ...

    def set_item_id(self, item_id: int) -> bool: ...
    def get_parent_id(self) -> int: ...
    def get_directly_nested_item_ids(self) -> List[int]: ...
    def set_parent_id(self, parent_id: int) -> bool: ...

    def set_item_name(self, display_name: str) -> bool: ...
    def set_item_visibility(self, is_visible: bool) -> bool: ...
    def set_item_color(self, target_color: Color) -> bool: ...

class GeometryInstance(ModelItemInstance):
    def is_sub_shape(self) -> bool: ...
    def get_shape(self) -> TopoDS_Shape: ...
    def get_geometry(self) -> GEOM_Object: ...
    def get_shape_type(self) -> TopAbs_ShapeEnum: ...
    def get_t2g_file_name(self) -> str: ...
    
    def set_shape(self, shape: TopoDS_Shape, shape_type: TopAbs_ShapeEnum) -> bool: ...
    def set_t2g_file_name(self, file_path: str) -> bool: ...

class MeshComponentInstance(ModelItemInstance):
    def save_updated_mesh_component(self, mesh_reference: MeshReference) -> bool: ...
    def get_mesh_component(self) -> MeshReference: ...

class MeshSetInstance(ModelItemInstance):
    def save_updated_mesh_reference(self, mesh_reference: MeshReference) -> bool: ...
    def get_mesh_reference(self) -> MeshReference: ...

class Model:
    def __init__(self, modelFileName: str) -> None: ...
    
    def set_geometry_exports_path(self, geomExportDirectory: str) -> None: ...
    
    def get_model_item_instance(self, instanceID: int) -> ModelItemInstance: ...
    def get_geometry_instance(self, instanceID: int) -> GeometryInstance: ...
    def get_geometry_shape_by_id(self, instance_id: int) -> GEOM_Object: ...
    def get_mesh_component_instance(self, instanceID: int) -> MeshComponentInstance: ...
    
    def add_container(self, containerName: str) -> ModelItemInstance: ...
    def add_folder(self, folderName: str, parentId: int) -> ModelItemInstance: ...
    def add_file(self, displayName: str, parentId: int) -> ModelItemInstance: ...
    
    def add_geometry(self, fileId: int, geometry: GEOM_Object, addWithFineResolution: bool = True) -> GeometryInstance: ...
    def add_mesh(self, fileId: int, mesh: Mesh) -> MeshComponentInstance: ...
    def add_mesh_set(self, file_id: int, element_ids: set, node_ids: set) -> MeshComponentInstance: ...

    def delete_model_instance(self, instanceId: int) -> List[int]: ...
    def delete_subshape_instance(self, instance_id: int) -> List[int]: ...
    def move_shape(self, source_shape_id: int, target_file_id: int, perform_copy_paste: bool=True) -> List[int]: ...
    
    def get_container_id_by_name(self, containerName: str) -> int: ...
    def get_added_item_ids(self) -> List[int]: ...
    def get_nested_component_ids(self, instanceId: int) -> List[int]: ...
    def get_all_nested_component_ids(self, instanceId: int) -> List[int]: ...
    def get_item_parent_id(self, instanceId: int) -> int: ...
    def get_all_ancestors(self, instanceId: int) -> List[int]: ...
    def get_item_nesting_level(self, instanceId: int) -> int: ...
    
    def set_model_name(self, modelFileName: str) -> bool: ...
    def get_model_name(self) -> str: ...
    def get_model_version(self) -> str: ...
    def set_model_version(self, docVersion: str) -> None: ...
    def save_model(self, pathToFolder: str) -> bool: ...
    def clear_model(self) -> bool: ...
    def load_model(self, modelFilePath: str) -> bool: ...

class Geometry3DPrimitives:
	def __init__(self): ...
	def make_box_dx_dy_dz(self,  the_d_x: float, the_d_y: float, the_d_z: float) -> GEOM_Object: ... 
	def make_box_two_pnt(self,  the_pnt1: GEOM_Object, the_pnt2: GEOM_Object) -> GEOM_Object: ... 
	def make_face_h_w(self,  the_h: float, the_w: float, the_orientation: int) -> GEOM_Object: ... 
	def make_face_obj_h_w(self,  the_obj: GEOM_Object, the_h: float, the_w: float) -> GEOM_Object: ... 
	def make_disk_three_pnt(self,  the_pnt1: GEOM_Object, the_pnt2: GEOM_Object, the_pnt3: GEOM_Object) -> GEOM_Object: ... 
	def make_disk_pnt_vec_r(self,  the_pnt1: GEOM_Object, the_vec: GEOM_Object, the_r: float) -> GEOM_Object: ... 
	def make_disk_r(self,  the_r: float, the_orientation: int) -> GEOM_Object: ... 
	def make_cylinder_r_h(self,  the_r: float, the_h: float) -> GEOM_Object: ... 
	def make_cylinder_pnt_vec_r_h(self,  the_pnt: GEOM_Object, the_vec: GEOM_Object, the_r: float, the_h: float) -> GEOM_Object: ... 
	def make_cylinder_r_h_a(self,  the_r: float, the_h: float, the_a: float) -> GEOM_Object: ... 
	def make_cylinder_pnt_vec_r_h_a(self,  the_pnt: GEOM_Object, the_vec: GEOM_Object, the_r: float, the_h: float, the_a: float) -> GEOM_Object: ... 
	def make_cone_r1_r2_h(self,  the_r1: float, the_r2: float, the_h: float) -> GEOM_Object: ... 
	def make_cone_pnt_vec_r1_r2_h(self,  the_pnt: GEOM_Object, the_vec: GEOM_Object, the_r1: float, the_r2: float, the_h: float) -> GEOM_Object: ... 
	def make_sphere_r(self,  the_r: float) -> GEOM_Object: ... 
	def make_sphere_pnt_r(self,  the_pnt: GEOM_Object, the_r: float) -> GEOM_Object: ... 
	def make_torus_r_r(self,  the_r_major: float, the_r_minor: float) -> GEOM_Object: ... 
	def make_torus_pnt_vec_r_r(self,  the_pnt: GEOM_Object, the_vec: GEOM_Object, the_r_major: float, the_r_minor: float) -> GEOM_Object: ... 
	def make_prism_vec_h(self,  the_base: GEOM_Object, the_vec: GEOM_Object, the_h: float, the_scale_factor=-1) -> GEOM_Object: ... 
	def make_prism_vec_h2_ways(self,  the_base: GEOM_Object, the_vec: GEOM_Object, the_h: float) -> GEOM_Object: ... 
	def make_prism_two_pnt(self,  the_base: GEOM_Object, the_point1: GEOM_Object, the_point2: GEOM_Object, the_scale_factor=-1) -> GEOM_Object: ... 
	def make_prism_two_pnt2_ways(self,  the_base: GEOM_Object, the_point1: GEOM_Object, the_point2: GEOM_Object) -> GEOM_Object: ... 
	def make_prism_d_x_d_y_d_z(self,  the_base: GEOM_Object, the_d_x: float, the_d_y: float, the_d_z: float, the_scale_factor=-1) -> GEOM_Object: ... 
	def make_prism_d_x_d_y_d_z2_ways(self,  the_base: GEOM_Object, the_d_x: float, the_d_y: float, the_d_z: float) -> GEOM_Object: ... 
	def make_draft_prism(self,  the_init_shape: GEOM_Object, the_base: GEOM_Object, the_height: float, the_angle: float, the_fuse: bool, invert=False) -> GEOM_Object: ... 
	def make_pipe(self,  the_base: GEOM_Object, the_path: GEOM_Object, is_generate_groups: bool) -> TColStd_HSequenceOfTransient: ... 
	def make_revolution_axis_angle(self,  the_base: GEOM_Object, the_axis: GEOM_Object, the_angle: float) -> GEOM_Object: ... 
	def make_revolution_axis_angle2_ways(self,  the_base: GEOM_Object, the_axis: GEOM_Object, the_angle: float) -> GEOM_Object: ... 
	def make_filling(self,  the_contours: list, the_min_deg: int, the_max_deg: int, the_tol2_d: float, the_tol3_d: float, the_nb_iter: int, the_method: int, is_approx: bool) -> GEOM_Object: ... 
	def make_thru_sections(self,  the_seq_sections: TColStd_HSequenceOfTransient, the_mode_solid: bool, the_preci: float, the_ruled: bool) -> GEOM_Object: ... 
	def make_pipe_with_different_sections(self,  the_bases: TColStd_HSequenceOfTransient, the_locations: TColStd_HSequenceOfTransient, the_path: GEOM_Object, the_with_contact: bool, the_with_corrections: bool, is_by_steps: bool, is_generate_groups: bool) -> TColStd_HSequenceOfTransient: ... 
	def make_pipe_with_shell_sections(self,  the_bases: TColStd_HSequenceOfTransient, the_sub_bases: TColStd_HSequenceOfTransient, the_locations: TColStd_HSequenceOfTransient, the_path: GEOM_Object, the_with_contact: bool, the_with_corrections: bool, is_generate_groups: bool) -> TColStd_HSequenceOfTransient: ... 
	def make_pipe_shells_without_path(self,  the_bases: TColStd_HSequenceOfTransient, the_locations: TColStd_HSequenceOfTransient, is_generate_groups: bool) -> TColStd_HSequenceOfTransient: ... 
	def make_thickening(self,  the_object: GEOM_Object, the_faces_id_s: list, the_offset: float, is_copy: bool, inside: bool) -> GEOM_Object: ... 
	def restore_path(self,  the_shape: GEOM_Object, the_base1: GEOM_Object, the_base2: GEOM_Object) -> GEOM_Object: ... 
	# def restore_path(self,  the_shape: GEOM_Object, the_base1: TColStd_HSequenceOfTransient, the_base2) -> GEOM_Object: ... 

class ExtGeometry3DPrimitives:
	def __init__(self, operator: Geometry3DPrimitives): ...
	def make_pipe_bi_normal_along_vector(self,  the_base: GEOM_Object, the_path: GEOM_Object, the_vec: GEOM_Object, is_generate_groups: bool) -> List[GEOM_Object]: ... 

class GeometryBasicOperations:
	def __init__(self): ...
	def make_point_xyz(self,  d__x: float, d__y: float, d__z: float) -> GEOM_Object: ... 
	def make_point_with_reference(self,  the_reference: GEOM_Object, the_x: float, the_y: float, the_z: float) -> GEOM_Object: ... 
	def make_point_on_curve(self,  the_curve: GEOM_Object, the_parameter: float, take_orientation_into_account: bool) -> GEOM_Object: ... 
	def make_point_on_curve_by_length(self,  the_curve: GEOM_Object, the_start_point: GEOM_Object, the_length: float) -> GEOM_Object: ... 
	def make_point_on_curve_by_coord(self,  the_curve: GEOM_Object, the_x_param: float, the_y_param: float, the_z_param: float) -> GEOM_Object: ... 
	def make_point_on_lines_intersection(self,  the_line1: GEOM_Object, the_line2: GEOM_Object) -> GEOM_Object: ... 
	def make_point_on_surface(self,  the_surface: GEOM_Object, the_u_parameter: float, the_v_parameter: float) -> GEOM_Object: ... 
	def make_point_on_surface_by_coord(self,  the_surface: GEOM_Object, the_x_param: float, the_y_param: float, the_z_param: float) -> GEOM_Object: ... 
	def make_point_on_face(self,  the_face: GEOM_Object) -> GEOM_Object: ... 
	def make_vector(self,  the_d_x: float, the_d_y: float, the_d_z: float) -> GEOM_Object: ... 
	def make_vector_two_pnt(self,  the_pnt1: GEOM_Object, the_pnt2: GEOM_Object) -> GEOM_Object: ... 
	def make_tangent_on_curve(self,  the_curve: GEOM_Object, the_parameter: float) -> GEOM_Object: ... 
	def make_line_two_pnt(self,  the_pnt1: GEOM_Object, the_pnt2: GEOM_Object) -> GEOM_Object: ... 
	def make_line_two_faces(self,  the_face1: GEOM_Object, the_face2: GEOM_Object) -> GEOM_Object: ... 
	def make_line(self,  the_pnt: GEOM_Object, the_dir: GEOM_Object) -> GEOM_Object: ... 
	def make_plane_three_points(self,  the_pnt1: GEOM_Object, the_pnt2: GEOM_Object, the_pnt3: GEOM_Object, the_size: float) -> GEOM_Object: ... 
	def make_plane_point_vector(self,  the_pnt: GEOM_Object, the_vec: GEOM_Object, the_size: float) -> GEOM_Object: ... 
	def make_plane_face(self,  the_face: GEOM_Object, the_size: float) -> GEOM_Object: ... 
	def make_plane_two_vectors(self,  the_vec1: GEOM_Object, the_vec2: GEOM_Object, the_size: float) -> GEOM_Object: ... 
	def make_plane_lcs(self,  the_face: GEOM_Object, the_size: float, the_orientation: int) -> GEOM_Object: ... 
	def make_marker(self,  the_o_x: float, the_o_y: float, the_o_z: float, the_x_d_x: float, the_x_d_y: float, the_x_d_z: float, the_y_d_x: float, the_y_d_y: float, the_y_d_z: float) -> GEOM_Object: ... 
	def make_marker_from_shape(self,  the_shape: GEOM_Object) -> GEOM_Object: ... 
	def make_marker_point_two_vectors(self,  the_origin: GEOM_Object, the_x_vec: GEOM_Object, the_y_vec: GEOM_Object) -> GEOM_Object: ... 
	def make_tangent_plane_on_face(self,  the_face: GEOM_Object, the_param_u: float, the_param_v: float, the_size: float) -> GEOM_Object: ...
	
class GeometryBlockOperations:
	def __init__(self): ...
	def make_quad(self,  the_edge1: GEOM_Object,  the_edge2: GEOM_Object,  the_edge3: GEOM_Object,  the_edge4: GEOM_Object) -> GEOM_Object: ... 
	def make_quad2_edges(self,  the_edge1: GEOM_Object,  the_edge2: GEOM_Object) -> GEOM_Object: ... 
	def make_quad4_vertices(self,  the_point1: GEOM_Object,  the_point2: GEOM_Object,  the_point3: GEOM_Object,  the_point4: GEOM_Object) -> GEOM_Object: ... 
	def make_hexa(self,  the_face1: GEOM_Object,  the_face2: GEOM_Object,  the_face3: GEOM_Object,  the_face4: GEOM_Object,  the_face5: GEOM_Object,  the_face6: GEOM_Object) -> GEOM_Object: ... 
	def make_hexa2_faces(self,  the_face1: GEOM_Object,  the_face2: GEOM_Object) -> GEOM_Object: ... 
	def make_block_compound(self,  the_compound: GEOM_Object) -> GEOM_Object: ... 
	def get_point(self,  the_shape: GEOM_Object,  the_x: float,  the_y: float,  the_z: float,  the_epsilon: float) -> GEOM_Object: ... 
	def get_vertex_near_point(self,  the_shape: GEOM_Object,  the_point: GEOM_Object) -> GEOM_Object: ... 
	def get_edge(self,  the_shape: GEOM_Object,  the_point1: GEOM_Object,  the_point2: GEOM_Object) -> GEOM_Object: ... 
	def get_edge_near_point(self,  the_block: GEOM_Object,  the_point: GEOM_Object) -> GEOM_Object: ... 
	def get_face_by_points(self,  the_shape: GEOM_Object,  the_point1: GEOM_Object,  the_point2: GEOM_Object,  the_point3: GEOM_Object,  the_point4: GEOM_Object) -> GEOM_Object: ... 
	def get_face_by_edges(self,  the_shape: GEOM_Object,  the_edge1: GEOM_Object,  the_edge2: GEOM_Object) -> GEOM_Object: ... 
	def get_opposite_face(self,  the_block: GEOM_Object,  the_face: GEOM_Object) -> GEOM_Object: ... 
	def get_face_near_point(self,  the_block: GEOM_Object,  the_point: GEOM_Object) -> GEOM_Object: ... 
	def get_face_by_normale(self,  the_block: GEOM_Object,  the_vector: GEOM_Object) -> GEOM_Object: ... 
	def get_shapes_near_point(self,  the_shape: GEOM_Object,  the_point: GEOM_Object,  the_shape_type: int,  the_tolerance: float) -> GEOM_Object: ... 
	def is_compound_of_blocks(self,  the_compound: GEOM_Object,  the_min_nb_faces: int,  the_max_nb_faces: int,  the_nb_blocks: int) -> bool: ... 
	def check_compound_of_blocks(self,  the_compound: GEOM_Object,  the_tolerance_c1: float,  the_errors: list) -> bool: ... 
	def print_b_c_errors(self,  the_compound: GEOM_Object,  the_errors: list) -> str: ... 
	def get_non_blocks(self,  the_shape: GEOM_Object,  the_tolerance_c1: float,  the_non_quads: GEOM_Object) -> GEOM_Object: ... 
	def remove_extra_edges(self,  the_shape: GEOM_Object,  theOptimumNbFaces = 6) -> GEOM_Object: ... 
	def union_faces(self,  the_shape: GEOM_Object) -> GEOM_Object: ... 
	def check_and_improve(self,  the_compound: GEOM_Object) -> GEOM_Object: ... 
	def explode_compound_of_blocks(self,  the_compound: GEOM_Object,  the_min_nb_faces: int,  the_max_nb_faces: int) -> TColStd_HSequenceOfTransient: ... 
	def get_block_near_point(self,  the_compound: GEOM_Object,  the_point: GEOM_Object) -> GEOM_Object: ... 
	def get_block_by_parts(self,  the_compound: GEOM_Object,  the_parts: TColStd_HSequenceOfTransient) -> GEOM_Object: ... 
	def get_blocks_by_parts(self,  the_compound: GEOM_Object,  the_parts: TColStd_HSequenceOfTransient) -> TColStd_HSequenceOfTransient: ... 
	def make_multi_transformation1_d(self,  the_block: GEOM_Object,  the_dir_face1: int,  the_dir_face2: int,  the_nb_times: int) -> GEOM_Object: ... 
	def make_multi_transformation2_d(self,  the_block: GEOM_Object,  the_dir_face1_u: int,  the_dir_face2_u: int,  the_nb_times_u: int,  the_dir_face1_v: int,  the_dir_face2_v: int,  the_nb_times_v: int) -> GEOM_Object: ... 
	def propagate(self,  the_shape: GEOM_Object) -> TColStd_HSequenceOfTransient: ... 

class GeometryBooleanOperations:
	def __init__(self): ...
	def make_boolean(self,  the_shape1: GEOM_Object,  the_shape2: GEOM_Object,  the_op: int,  is_check_self_inte: bool) -> GEOM_Object: ... 
	def make_fuse(self,  the_shape1: GEOM_Object,  the_shape2: GEOM_Object,  is_check_self_inte: bool,  is_rm_extra_edges: bool) -> GEOM_Object: ... 
	def make_fuse_list(self,  the_shapes: TColStd_HSequenceOfTransient,  is_check_self_inte: bool,  is_rm_extra_edges: bool) -> GEOM_Object: ... 
	def make_common_list(self,  the_shapes: TColStd_HSequenceOfTransient,  is_check_self_inte: bool) -> GEOM_Object: ... 
	def make_cut_list(self,  the_main_shape: GEOM_Object,  the_shapes: TColStd_HSequenceOfTransient,  is_check_self_inte: bool) -> GEOM_Object: ... 
	def make_half_partition(self,  the_shape: GEOM_Object,  the_plane: GEOM_Object) -> GEOM_Object: ... 

class ExtGeometryBooleanOperations:
	def __init__(self, engine: GeometryBooleanOperations): ...
	def make_partition(self,  the_shapes: TColStd_HSequenceOfTransient,  the_tools: TColStd_HSequenceOfTransient,  the_keep_inside: TColStd_HSequenceOfTransient,  the_remove_inside: TColStd_HSequenceOfTransient,  the_limit: int,  the_remove_webs: bool,  the_materials: list,  the_keep_nonlimit_shapes: int,  the_perform_self_intersections: bool,  is_check_self_inte: bool) -> GEOM_Object: ... 

class GeometryCurveOperations:
	def __init__(self): ...
	def make_circle_three_pnt(self,  the_pnt1: GEOM_Object,  the_pnt2: GEOM_Object,  the_pnt3: GEOM_Object) -> GEOM_Object: ... 
	def make_circle_center2_pnt(self,  the_pnt1: GEOM_Object,  the_pnt2: GEOM_Object,  the_pnt3: GEOM_Object) -> GEOM_Object: ... 
	def make_circle_pnt_vec_r(self,  the_pnt: GEOM_Object,  the_vec: GEOM_Object,  the_r: float) -> GEOM_Object: ... 
	def make_ellipse(self,  the_pnt: GEOM_Object,  the_vec: GEOM_Object,  the_r_major: float,  the_r_minor: float,  the_vec_maj: GEOM_Object) -> GEOM_Object: ... 
	def make_arc(self,  the_pnt1: GEOM_Object,  the_pnt2: GEOM_Object,  the_pnt3: GEOM_Object) -> GEOM_Object: ... 
	def make_arc_center(self,  the_pnt1: GEOM_Object,  the_pnt2: GEOM_Object,  the_pnt3: GEOM_Object,  the_sense: bool) -> GEOM_Object: ... 
	def make_arc_of_ellipse(self,  the_pnt1: GEOM_Object,  the_pnt2: GEOM_Object,  the_pnt3: GEOM_Object) -> GEOM_Object: ... 
	def make_polyline(self,  the_points: list,  is_closed=False) -> GEOM_Object: ... 
	def make_spline_bezier(self,  the_points: list,  is_closed=False) -> GEOM_Object: ... 
	def make_spline_interpolation(self,  the_points: list,  is_closed=False,  reorder=False) -> GEOM_Object: ... 
	def make_spline_interpol_with_tangents(self,  the_points: list,  the_first_vec: GEOM_Object,  the_last_vec: GEOM_Object) -> GEOM_Object: ... 
	def make3_d_sketcher(self,  the_coordinates: list) -> GEOM_Object: ... 
	def make_isoline(self,  the_face: GEOM_Object,  is_u_iso: bool,  the_parameter: float) -> GEOM_Object: ... 
	def make_polyline2_d(self,  the_coords: list,  the_names: list,  the_types: list,  the_closeds: list,  the_working_plane: list) -> GEOM_Object: ... 
	def make_polyline2_d_on_plane(self,  the_coords: list,  the_names: list,  the_types: list,  the_closeds: list,  the_working_plane: GEOM_Object) -> GEOM_Object: ... 

class GeometryFieldOperations:
	def __init__(self): ...
	def create_field(self,  the_shape: GEOM_Object,  the_name: str,  the_type: int,  the_dimension: int,  the_component_names: list) -> GEOM_Field: ... 
	def count_fields(self,  shape: GEOM_Object) -> int: ... 
	def get_fields(self,  shape: GEOM_Object) -> TColStd_HSequenceOfTransient: ... 
	def get_field(self,  shape: GEOM_Object,  name: str) -> GEOM_Field: ... 

class GeometryGroupOperations:
	def __init__(self): ...
	def create_group(self,  the_main_shape: GEOM_Object,  the_shape_type: TopAbs_ShapeEnum) -> GEOM_Object: ... 
	def add_object(self,  the_group: GEOM_Object,  the_sub_shape_i_d: int) -> None: ... 
	def remove_object(self,  the_group: GEOM_Object,  the_sub_shape_i_d: int) -> None: ... 
	def union_list(self,  the_group: GEOM_Object,  the_sub_shapes: TColStd_HSequenceOfTransient) -> None: ... 
	def difference_list(self,  the_group: GEOM_Object,  the_sub_shapes: TColStd_HSequenceOfTransient) -> None: ... 
	def union_i_ds(self,  the_group: GEOM_Object,  the_sub_shapes: list) -> None: ... 
	def difference_i_ds(self,  the_group: GEOM_Object,  the_sub_shapes: list) -> None: ... 
	def union_groups(self,  the_group1: GEOM_Object,  the_group2: GEOM_Object) -> GEOM_Object: ... 
	def intersect_groups(self,  the_group1: GEOM_Object,  the_group2: GEOM_Object) -> GEOM_Object: ... 
	def cut_groups(self,  the_group1: GEOM_Object,  the_group2: GEOM_Object) -> GEOM_Object: ... 
	def union_list_of_groups(self,  the_g_list: TColStd_HSequenceOfTransient) -> GEOM_Object: ... 
	def intersect_list_of_groups(self,  the_g_list: TColStd_HSequenceOfTransient) -> GEOM_Object: ... 
	def cut_list_of_groups(self,  the_g_list1: TColStd_HSequenceOfTransient,  the_g_list2: TColStd_HSequenceOfTransient) -> GEOM_Object: ... 
	def get_type(self,  the_group: GEOM_Object) -> TopAbs_ShapeEnum: ... 
	def get_main_shape(self,  the_group: GEOM_Object) -> GEOM_Object: ... 
	def get_objects(self,  the_group: GEOM_Object) -> list: ... 

class GeometryHealingOperations:
	def __init__(self): ...
	def shape_process(self,  the_object: GEOM_Object,  the_operations: list,  the_params: list,  the_values: list) -> GEOM_Object: ... 
	def get_shape_process_parameters(self,  the_operations: list,  the_params: list,  the_values: list) -> None: ... 
	def get_operator_parameters(self,  the_operation: str,  the_params: list,  the_values: list) -> bool: ... 
	#def get_parameters(self,  the_operation: str,  the_params: list) -> list: ... 
	def suppress_faces(self,  the_object: GEOM_Object,  the_faces: list) -> GEOM_Object: ... 
	def close_contour(self,  the_object: GEOM_Object,  the_wires: list,  is_common_vertex: bool) -> GEOM_Object: ... 
	def remove_int_wires(self,  the_object: GEOM_Object,  the_wires: list) -> GEOM_Object: ... 
	def sew(self,  the_object: list,  the_tolerance: float,  is_allow_non_manifold: bool) -> GEOM_Object: ... 
	def remove_internal_faces(self,  the_solids: list) -> GEOM_Object: ... 
	def divide_edge(self,  the_object: GEOM_Object,  the_index: int,  the_value: float,  is_by_parameter: bool) -> GEOM_Object: ... 
	def divide_edge_by_point(self,  the_object: GEOM_Object,  the_index: int,  the_point: list) -> GEOM_Object: ... 
	def fuse_collinear_edges_within_wire(self,  the_wire: GEOM_Object,  the_vertices: list) -> GEOM_Object: ... 
	def change_orientation(self,  the_object: GEOM_Object) -> GEOM_Object: ... 
	def change_orientation_copy(self,  the_object: GEOM_Object) -> GEOM_Object: ... 
	def limit_tolerance(self,  the_object: GEOM_Object,  the_tolerance: float,  shape_type: TopAbs_ShapeEnum) -> GEOM_Object: ...

class ExtGeometryHealingOperations:
	def __init__(self, operator: GeometryHealingOperations): ...
	def fill_holes(self, the_object: GEOM_Object) -> GEOM_Object: ...
	def get_free_boundary(self,  the_object: GEOM_Object) -> GEOM_Object: ... 

class GeometryInsertOperations:
	def __init__(self): ...
	def make_copy(self,  the_original: GEOM_Object) -> GEOM_Object: ... 
	def import_file(self,  the_file_name: str,  the_format_type: str) -> TColStd_HSequenceOfTransient: ... 
	def read_value(self,  the_file_name: str,  the_format_type: str,  the_parameter_name: str) -> str: ... 
	def export(self,  the_original: GEOM_Object,  the_file_name: str,  the_format_type: str) -> None: ... 
	def restore_shape(self,  the_stream: str) -> GEOM_Object: ... 
	def load_texture(self,  the_texture_file: str) -> int: ... 
	def add_texture(self,  the_width: int,  the_height: int,  the_texture: list) -> int: ... 
	def get_texture(self,  the_texture_id: int,  the_width: int,  the_height: int) -> list: ... 
	def get_all_textures(self) -> list: ... 
	def transfer_data(self,  the_object_from: GEOM_Object,  the_object_to: GEOM_Object,  the_find_method: int,  the_result: list ) -> bool: ... 

class GeometryLocalOperations:
	def __init__(self): ...
	def make_fillet_all(self,  the_shape: GEOM_Object,  the_r: float) -> GEOM_Object: ... 
	def make_fillet_edges(self,  the_shape: GEOM_Object,  the_r: float,  the_edges: list) -> GEOM_Object: ... 
	def make_fillet_edges_r1_r2(self,  the_shape: GEOM_Object,  the_r1: float,  the_r2: float,  the_edges: list) -> GEOM_Object: ... 
	def make_fillet_faces(self,  the_shape: GEOM_Object,  the_r: float,  the_faces: list) -> GEOM_Object: ... 
	def make_fillet_faces_r1_r2(self,  the_shape: GEOM_Object,  the_r1: float,  the_r2: float,  the_faces: list) -> GEOM_Object: ... 
	def make_fillet2_d(self,  the_shape: GEOM_Object,  the_r: float,  the_vertices: list) -> GEOM_Object: ... 
	def make_fillet1_d(self,  the_shape: GEOM_Object,  the_r: float,  the_vertexes: list,  do_ignore_secant_vertices: bool) -> GEOM_Object: ... 
	def make_chamfer_all(self,  the_shape: GEOM_Object,  the_d: float) -> GEOM_Object: ... 
	def make_chamfer_edge(self,  the_shape: GEOM_Object,  the_d1: float,  the_d2: float,  the_face1: int,  the_face2: int) -> GEOM_Object: ... 
	def make_chamfer_edge_a_d(self,  the_shape: GEOM_Object,  the_d: float,  the_angle: float,  the_face1: int,  the_face2: int) -> GEOM_Object: ... 
	def make_chamfer_faces(self,  the_shape: GEOM_Object,  the_d1: float,  the_d2: float,  the_faces: list) -> GEOM_Object: ... 
	def make_chamfer_faces_a_d(self,  the_shape: GEOM_Object,  the_d: float,  the_angle: float,  the_faces: list) -> GEOM_Object: ... 
	def make_chamfer_edges(self,  the_shape: GEOM_Object,  the_d1: float,  the_d2: float,  the_edges: list) -> GEOM_Object: ... 
	def make_chamfer_edges_a_d(self,  the_shape: GEOM_Object,  the_d: float,  the_angle: float,  the_edges: list) -> GEOM_Object: ... 
	def make_archimede(self,  the_shape: GEOM_Object,  the_weight: float,  the_water_density: float,  the_meshing_deflection: float) -> GEOM_Object: ... 
	def get_sub_shape_index(self,  the_shape: GEOM_Object,  the_sub_shape: GEOM_Object) -> int: ... 

class GeometryMeasureOperations:
	def __init__(self): ...
	def kind_of_shape(self,  the_shape: GEOM_Object,  the_integers: list,  the_floats: list) -> ShapeKind: ... 
	def get_position(self,  the_shape: GEOM_Object,  ox: float,  oy: float,  oz: float,  zx: float,  zy: float,  zz: float,  xx: float,  xy: float,  xz: float) -> None: ... 
	def get_centre_of_mass(self,  the_shape: GEOM_Object) -> GEOM_Object: ... 
	def get_vertex_by_index(self,  the_shape: GEOM_Object,  the_index: int,  the_use_ori: bool) -> GEOM_Object: ... 
	def get_normal_ref_point(self,  the_face: GEOM_Object,  the_optional_point: GEOM_Object) -> GEOM_Object: ... 	
	def get_normal(self,  the_face: GEOM_Object) -> GEOM_Object: ... 
	def get_basic_properties(self,  the_shape: GEOM_Object,  the_tolerance: float,  the_length: float,  the_surf_area: float,  the_volume: float) -> None: ... 
	def get_inertia(self,  the_shape: GEOM_Object,  i11: float,  i12: float,  i13: float,  i21: float,  i22: float,  i23: float,  i31: float,  i32: float,  i33: float,  ix: float,  iy: float,  iz: float) -> None: ... 
	def get_bounding_box(self,  the_shape: GEOM_Object,  precise: bool,  xmin: float,  xmax: float,  ymin: float,  ymax: float,  zmin: float,  zmax: float) -> None: ... 
	def get_bounding_box_shape(self,  the_shape: GEOM_Object,  precise: bool) -> GEOM_Object: ... 
	def get_tolerance(self,  the_shape: GEOM_Object,  face_min: float,  face_max: float,  edge_min: float,  edge_max: float,  vert_min: float,  vert_max: float) -> None: ... 
	def check_shape(self,  the_shape: GEOM_Object,  the_is_check_geom: bool,  the_errors: list) -> bool: ... 
	def print_shape_errors(self,  the_shape: GEOM_Object,  the_errors: list) -> str: ... 
	def check_self_intersections(self,  the_shape: GEOM_Object,  the_check_level: SICheckLevel,  the_intersections: list) -> bool: ... 
	def check_self_intersections_fast(self,  the_shape: GEOM_Object,  deflection: float,  tolerance: float,  the_intersections: list) -> bool: ... 
	def check_b_o_p_arguments(self,  the_shape: GEOM_Object) -> bool: ... 
	def fast_intersect(self,  the_shape1: GEOM_Object,  the_shape2: GEOM_Object,  tolerance: float,  deflection: float,  the_intersections1: list,  the_intersections2: list) -> bool: ... 
	def is_good_for_solid(self,  the_shape: GEOM_Object) -> str: ... 
	def what_is(self,  the_shape: GEOM_Object) -> str: ... 
	def are_coords_inside(self,  the_shape: GEOM_Object,  coords: list,  tolerance: float) -> list: ... 
	def get_min_distance(self,  the_shape1: GEOM_Object,  the_shape2: GEOM_Object,  x1: float,  y1: float,  z1: float,  x2: float,  y2: float,  z2: float) -> float: ... 
	def closest_points(self,  the_shape1: GEOM_Object,  the_shape2: GEOM_Object,  the_floats: list) -> int: ... 
	# def point_coordinates(self,  the_shape: GEOM_Object) -> None: ... 
	def get_angle(self,  the_line1: GEOM_Object,  the_line2: GEOM_Object) -> float: ... 
	def get_angle_btw_vectors(self,  the_vec1: GEOM_Object,  the_vec2: GEOM_Object) -> float: ... 
	def curve_curvature_by_param(self,  the_curve: GEOM_Object,  the_param: float) -> float: ... 
	def curve_curvature_by_point(self,  the_curve: GEOM_Object,  the_point: GEOM_Object) -> float: ... 
	def max_surface_curvature_by_param(self,  the_surf: GEOM_Object,  the_u_param: float,  the_v_param: float) -> float: ... 
	def max_surface_curvature_by_point(self,  the_surf: GEOM_Object,  the_point: GEOM_Object) -> float: ... 
	def min_surface_curvature_by_param(self,  the_surf: GEOM_Object,  the_u_param: float,  the_v_param: float) -> float: ... 
	def min_surface_curvature_by_point(self,  the_surf: GEOM_Object,  the_point: GEOM_Object) -> float: ... 

# Extension class to measure operations
class ExtGeometryMeasureOperations:
	def __init__(self, operator: GeometryMeasureOperations): ...
	def get_basic_properties(self, the_shape: GEOM_Object, the_tolerance = 1e-6) -> list: ...
	def kind_of_shape(self, the_shape: GEOM_Object) -> list: ...
	def closest_points(self, the_shape1: GEOM_Object, the_shape2: GEOM_Object) -> list: ...
	def get_min_distance(self, the_shape1: GEOM_Object, the_shape2: GEOM_Object) -> list: ...
	def point_coordinates(self, the_point: GEOM_Object) -> list: ...
	def fast_intersect(self, the_shape1: GEOM_Object, the_shape2: GEOM_Object, tolerance = 0.0, deflection = 1e-6) -> list: ... 
	def get_inertia(self, the_shape: GEOM_Object) -> list: ...
	def get_position(self, the_shape: GEOM_Object) -> list: ...
	def bounding_box(self, the_shape: GEOM_Object, is_precise: bool) -> list: ... 
	def oriented_bounding_box(self, the_shape: GEOM_Object, is_precise: bool) -> list: ...

class GeometryShapeOperations:
	def __init__(self): ...
	def make_edge(self,  the_point1: GEOM_Object,  the_point2: GEOM_Object) -> GEOM_Object: ... 
	def make_edge_on_curve_by_length(self,  the_curve: GEOM_Object,  the_length: float,  the_start_point: GEOM_Object) -> GEOM_Object: ... 
	def make_edge_wire(self,  the_wire: GEOM_Object,  the_linear_tolerance: float,  the_angular_tolerance: float) -> GEOM_Object: ... 
	def make_wire(self,  the_edges_and_wires: list,  the_tolerance: float) -> GEOM_Object: ... 
	def make_face(self,  the_wire: GEOM_Object,  is_planar_wanted: bool) -> GEOM_Object: ... 
	def make_face_wires(self,  the_wires: list,  is_planar_wanted: bool) -> GEOM_Object: ... 
	def make_face_from_surface(self,  the_face: GEOM_Object,  the_wire: GEOM_Object) -> GEOM_Object: ... 
	def make_face_with_constraints(self,  the_constraints: list) -> GEOM_Object: ... 
	def make_shell(self,  the_shapes: list) -> GEOM_Object: ... 
	def make_solid_shells(self,  the_shells: list) -> GEOM_Object: ... 
	def make_compound(self,  the_shapes: list) -> GEOM_Object: ... 
	def make_solid_from_connected_faces(self,  the_faces_or_shells: list,  is_intersect: bool) -> GEOM_Object: ... 
	def make_glue_faces(self,  the_shapes: list,  the_tolerance: float,  do_keep_non_solids: bool) -> GEOM_Object: ... 
	def make_glue_faces_by_list(self,  the_shapes: list,  the_tolerance: float,  the_faces: list,  do_keep_non_solids: bool,  do_glue_all_edges: bool) -> GEOM_Object: ... 
	def make_glue_edges(self,  the_shapes: list,  the_tolerance: float) -> GEOM_Object: ... 
	def get_glue_shapes(self,  the_shapes: list,  the_tolerance: float,  the_type: TopAbs_ShapeEnum) -> TColStd_HSequenceOfTransient: ... 
	def make_glue_edges_by_list(self,  the_shapes: list,  the_tolerance: float,  the_edges: list) -> GEOM_Object: ... 
	def get_existing_sub_objects_groups(self,  the_shape: GEOM_Object,  the_groups_only: bool) -> TColStd_HSequenceOfTransient: ... 
	def get_existing_sub_objects(self,  the_shape: GEOM_Object, the_types: int) -> TColStd_HSequenceOfTransient: ... 
	def make_explode(self,  the_shape: GEOM_Object,  the_shape_type: TopAbs_ShapeEnum,  is_sorted: bool,  the_explode_type: ExplodeType) -> TColStd_HSequenceOfTransient: ... 
	def sub_shape_all_i_ds(self,  the_shape: GEOM_Object,  the_shape_type: int,  is_sorted: bool,  the_explode_type: ExplodeType) -> list: ... 
	def get_sub_shape(self,  the_main_shape: GEOM_Object,  the_i_d: int) -> GEOM_Object: ... 
	def make_sub_shapes(self,  the_main_shape: GEOM_Object,  the_indices: list) -> TColStd_HSequenceOfTransient: ... 
	def get_sub_shape_index(self,  the_main_shape: GEOM_Object,  the_sub_shape: GEOM_Object) -> int: ... 
	def get_sub_shapes_indices(self,  the_main_shape: GEOM_Object,  the_sub_shapes: list) -> list: ... 
	def get_topology_index(self,  the_main_shape: GEOM_Object,  the_sub_shape: GEOM_Object) -> int: ... 
	def get_shape_type_string(self,  the_shape: GEOM_Object) -> str: ... 
	def is_sub_shape_belongs_to(self,  the_sub_object: GEOM_Object,  the_sub_object_index: int,  the_object: GEOM_Object,  the_object_index: int) -> bool: ... 
	def number_of_sub_shapes(self,  the_shape: GEOM_Object,  the_shape_type: int) -> int: ... 
	def reverse_shape(self,  the_shapes: GEOM_Object) -> GEOM_Object: ... 
	def get_free_faces_i_ds(self,  the_shape: GEOM_Object) -> list: ... 
	def get_shared_shapes(self,  the_shape1: GEOM_Object,  the_shape2: GEOM_Object,  the_shape_type: int) -> TColStd_HSequenceOfTransient: ... 
	def get_multi_shared_shapes(self,  the_shapes: list,  the_shape_type: int,  multi_share = True) -> TColStd_HSequenceOfTransient: ... 
	def get_shapes_on_plane(self,  the_shape: GEOM_Object,  the_shape_type: int,  the_ax1: GEOM_Object,  the_state: GEOMAlgo_State) -> TColStd_HSequenceOfTransient: ... 
	def get_shapes_on_plane_with_location(self,  the_shape: GEOM_Object,  the_shape_type: int,  the_ax1: GEOM_Object,  the_pnt: GEOM_Object,  the_state: GEOMAlgo_State) -> TColStd_HSequenceOfTransient: ... 
	def get_shapes_on_cylinder(self,  the_shape: GEOM_Object,  the_shape_type: int,  the_axis: GEOM_Object,  the_radius: float,  the_state: GEOMAlgo_State) -> TColStd_HSequenceOfTransient: ... 
	def get_shapes_on_cylinder_with_location(self,  the_shape: GEOM_Object,  the_shape_type: int,  the_axis: GEOM_Object,  the_pnt: GEOM_Object,  the_radius: float,  the_state: GEOMAlgo_State) -> TColStd_HSequenceOfTransient: ... 
	def get_shapes_on_sphere(self,  the_shape: GEOM_Object,  the_shape_type: int,  the_center: GEOM_Object,  the_radius: float,  the_state: GEOMAlgo_State) -> TColStd_HSequenceOfTransient: ... 
	def get_shapes_on_plane_i_ds(self,  the_shape: GEOM_Object,  the_shape_type: int,  the_ax1: GEOM_Object,  the_state: GEOMAlgo_State) -> list: ... 
	def get_shapes_on_plane_with_location_i_ds(self,  the_shape: GEOM_Object,  the_shape_type: int,  the_ax1: GEOM_Object,  the_pnt: GEOM_Object,  the_state: GEOMAlgo_State) -> list: ... 
	def get_shapes_on_cylinder_i_ds(self,  the_shape: GEOM_Object,  the_shape_type: int,  the_axis: GEOM_Object,  the_radius: float,  the_state: GEOMAlgo_State) -> list: ... 
	def get_shapes_on_cylinder_with_location_i_ds(self,  the_shape: GEOM_Object,  the_shape_type: int,  the_axis: GEOM_Object,  the_pnt: GEOM_Object,  the_radius: float,  the_state: GEOMAlgo_State) -> list: ... 
	def get_shapes_on_sphere_i_ds(self,  the_shape: GEOM_Object,  the_shape_type: int,  the_center: GEOM_Object,  the_radius: float,  the_state: GEOMAlgo_State) -> list: ... 
	def get_shapes_on_quadrangle(self,  the_shape: GEOM_Object,  the_shape_type: int,  the_top_left_point: GEOM_Object,  the_top_right_point: GEOM_Object,  the_bottom_left_point: GEOM_Object,  the_bottom_right_point: GEOM_Object,  the_state: GEOMAlgo_State) -> TColStd_HSequenceOfTransient: ... 
	def get_shapes_on_quadrangle_i_ds(self,  the_shape: GEOM_Object,  the_shape_type: int,  the_top_left_point: GEOM_Object,  the_top_right_point: GEOM_Object,  the_bottom_left_point: GEOM_Object,  the_bottom_right_point: GEOM_Object,  the_state: GEOMAlgo_State) -> list: ... 
	def get_shapes_on_cylinder_old(self,  the_shape: GEOM_Object,  the_shape_type: int,  the_axis: GEOM_Object,  the_radius: float) -> GEOM_Object: ... 
	def get_shapes_on_sphere_old(self,  the_shape: GEOM_Object,  the_shape_type: int,  the_center: GEOM_Object,  the_radius: float) -> GEOM_Object: ... 
	def get_in_place(self,  the_shape_where: GEOM_Object,  the_shape_what: GEOM_Object) -> GEOM_Object: ... 
	def get_in_place_old(self,  the_shape_where: GEOM_Object,  the_shape_what: GEOM_Object) -> GEOM_Object: ... 
	def get_in_place_by_history(self,  the_shape_where: GEOM_Object,  the_shape_what: GEOM_Object) -> GEOM_Object: ... 
	def get_in_place_map(self,  the_shape_where: GEOM_Object,  the_shape_what: GEOM_Object,  the_res_vec: list) -> None: ... 
	def get_same(self,  the_shape_where: GEOM_Object,  the_shape_what: GEOM_Object) -> GEOM_Object: ... 
	def get_same_i_ds(self,  the_shape_where: GEOM_Object,  the_shape_what: GEOM_Object) -> list: ... 
	def get_shapes_on_box_i_ds(self,  the_box: GEOM_Object,  the_shape: GEOM_Object,  the_shape_type: int,  the_state: GEOMAlgo_State) -> list: ... 
	def get_shapes_on_box(self,  the_box: GEOM_Object,  the_shape: GEOM_Object,  the_shape_type: int,  the_state: GEOMAlgo_State) -> TColStd_HSequenceOfTransient: ... 
	def get_shapes_on_shape_i_ds(self,  the_check_shape: GEOM_Object,  the_shape: GEOM_Object,  the_shape_type: int,  the_state: GEOMAlgo_State) -> list: ... 
	def get_shapes_on_shape(self,  the_check_shape: GEOM_Object,  the_shape: GEOM_Object,  the_shape_type: int,  the_state: GEOMAlgo_State) -> TColStd_HSequenceOfTransient: ... 
	def get_shapes_on_shape_as_compound(self,  the_check_shape: GEOM_Object,  the_shape: GEOM_Object,  the_shape_type: int,  the_state: GEOMAlgo_State) -> GEOM_Object: ... 
	def extend_edge(self,  the_edge: GEOM_Object,  the_min: float,  the_max: float) -> GEOM_Object: ... 
	def extend_face(self,  the_face: GEOM_Object,  the_u_min: float,  the_u_max: float,  the_v_min: float,  the_v_max: float) -> GEOM_Object: ... 
	def make_surface_from_face(self,  the_face: GEOM_Object) -> GEOM_Object: ... 
	def get_sub_shape_edge_sorted(self,  the_shape: GEOM_Object,  the_start_point: GEOM_Object) -> TColStd_HSequenceOfTransient: ... 
	def get_sub_shapes_with_tolerance(self,  the_shape: GEOM_Object,  the_shape_type: int,  the_condition: ComparisonCondition,  the_tolerance: float) -> TColStd_HSequenceOfTransient: ... 
	#def make_extraction(self,  the_shape: GEOM_Object,  the_sub_shape_i_ds: list,  the_stats: list) -> GEOM_Object: ... 

	# Extension class to shape operations
class ExtGeometryShapeOperations:
	def __init__(self, shape_operations: GeometryShapeOperations): ...
	def extract_shapes(self, the_shape: GEOM_Object, the_shape_type: TopAbs_ShapeEnum, is_sorted: bool): ...  
	def get_sub_shapes_indices(self, main_shape: GEOM_Object, sub_shapes: list) -> list: ...
	def get_visible_and_hidden_edges(self, main_shape: GEOM_Object, camera_position: list, camera_direction: list, should_include_hidden: bool) -> list: ...

class GeometryTransformOperations:
	def __init__(self): ...
	def translate_two_points(self,  the_object: GEOM_Object,  the_point1: GEOM_Object,  the_point2: GEOM_Object) -> GEOM_Object: ... 
	def translate_two_points_copy(self,  the_object: GEOM_Object,  the_point1: GEOM_Object,  the_point2: GEOM_Object) -> GEOM_Object: ... 
	def translate_d_x_d_y_d_z(self,  the_object: GEOM_Object,  the_x: float,  the_y: float,  the_z: float) -> GEOM_Object: ... 
	def translate_d_x_d_y_d_z_copy(self,  the_object: GEOM_Object,  the_x: float,  the_y: float,  the_z: float) -> GEOM_Object: ... 
	def translate_vector(self,  the_object: GEOM_Object,  the_vector: GEOM_Object) -> GEOM_Object: ... 
	def translate_vector_copy(self,  the_object: GEOM_Object,  the_vector: GEOM_Object) -> GEOM_Object: ... 
	def translate_vector_distance(self,  the_object: GEOM_Object,  the_vector: GEOM_Object,  the_distance: float,  the_copy: bool) -> GEOM_Object: ... 
	def translate1_d(self,  the_object: GEOM_Object,  the_vector: GEOM_Object,  the_step: float,  the_nb_times: int) -> GEOM_Object: ... 
	def translate2_d(self,  the_object: GEOM_Object,  the_vector: GEOM_Object,  the_step1: float,  the_nb_times1: int,  the_vector2: GEOM_Object,  the_step2: float,  the_nb_times2: int) -> GEOM_Object: ... 
	def mirror_plane(self,  the_object: GEOM_Object,  the_plane: GEOM_Object) -> GEOM_Object: ... 
	def mirror_plane_copy(self,  the_object: GEOM_Object,  the_plane: GEOM_Object) -> GEOM_Object: ... 
	def mirror_axis(self,  the_object: GEOM_Object,  the_axis: GEOM_Object) -> GEOM_Object: ... 
	def mirror_axis_copy(self,  the_object: GEOM_Object,  the_axis: GEOM_Object) -> GEOM_Object: ... 
	def mirror_point(self,  the_object: GEOM_Object,  the_point: GEOM_Object) -> GEOM_Object: ... 
	def mirror_point_copy(self,  the_object: GEOM_Object,  the_point: GEOM_Object) -> GEOM_Object: ... 
	def offset_shape(self,  the_object: GEOM_Object,  the_offset: float,  the_join_by_pipes: bool) -> GEOM_Object: ... 
	def offset_shape_copy(self,  the_object: GEOM_Object,  the_offset: float,  the_join_by_pipes: bool) -> GEOM_Object: ... 
	def project_shape_copy(self,  the_source: GEOM_Object,  the_target: GEOM_Object) -> GEOM_Object: ... 
	def project_point_on_wire(self,  the_point: GEOM_Object,  the_wire: GEOM_Object,  the_point_on_edge: GEOM_Object,  the_edge_in_wire_index: int) -> float: ... 
	def scale_shape(self,  the_object: GEOM_Object,  the_point: GEOM_Object,  the_factor: float) -> GEOM_Object: ... 
	def scale_shape_copy(self,  the_object: GEOM_Object,  the_point: GEOM_Object,  the_factor: float) -> GEOM_Object: ... 
	def scale_shape_along_axes(self,  the_object: GEOM_Object,  the_point: GEOM_Object,  the_factor_x: float,  the_factor_y: float,  the_factor_z: float,  do_copy: bool) -> GEOM_Object: ... 
	def position_shape(self,  the_object: GEOM_Object,  the_start_l_c_s: GEOM_Object,  the_end_l_c_s: GEOM_Object) -> GEOM_Object: ... 
	def position_shape_copy(self,  the_object: GEOM_Object,  the_start_l_c_s: GEOM_Object,  the_end_l_c_s: GEOM_Object) -> GEOM_Object: ... 
	def position_along_path(self,  the_object: GEOM_Object,  the_path: GEOM_Object,  the_distance: float,  the_copy: bool,  the_reverse: bool) -> GEOM_Object: ... 
	def rotate(self,  the_object: GEOM_Object,  the_axis: GEOM_Object,  the_angle: float) -> GEOM_Object: ... 
	def rotate_copy(self,  the_object: GEOM_Object,  the_axis: GEOM_Object,  the_angle: float) -> GEOM_Object: ... 
	def rotate1_d(self,  the_object: GEOM_Object,  the_axis: GEOM_Object,  the_nb_times: int) -> GEOM_Object: ... 
	def rotate1_d_steps(self,  the_object: GEOM_Object,  the_axis: GEOM_Object,  the_angle_step: float,  the_nb_steps: int) -> GEOM_Object: ... 
	def rotate2_d(self,  the_object: GEOM_Object,  the_axis: GEOM_Object,  the_nb_objects: int,  the_radial_step: float,  the_nb_steps: int) -> GEOM_Object: ... 
	def rotate2_d_steps(self,  the_object: GEOM_Object,  the_axis: GEOM_Object,  the_angle: float,  the_nb_times1: int,  the_step: float,  the_nb_times2: int) -> GEOM_Object: ... 
	def rotate_three_points(self,  the_object: GEOM_Object,  the_cent_point: GEOM_Object,  the_point1: GEOM_Object,  the_point2: GEOM_Object) -> GEOM_Object: ... 
	def rotate_three_points_copy(self,  the_object: GEOM_Object,  the_cent_point: GEOM_Object,  the_point1: GEOM_Object,  the_point2: GEOM_Object) -> GEOM_Object: ... 
	def transform_like_other_copy(self,  the_object: GEOM_Object,  the_sample: GEOM_Object) -> GEOM_Object: ... 
	def make_projection_on_cylinder(self,  the_object: GEOM_Object,  the_radius: float,  the_start_angle: float,  the_angle_length: float,  the_angle_rotation: float) -> GEOM_Object: ... 
	def deep_copy(self, the_object: GEOM_Object) -> GEOM_Object: ...

class ImportOperations:
	def __init__(self): ...
	def import_step(self, complete_path: str, assembly_info: bool) -> GEOM_Object: ...
	def import_step_by_hierarchy(self, complete_path: str) -> list: ...

class ExportOperations:
	def __init__(self): ...
	def export_step(self, model: GEOM_Object, exp_file: str) -> None: ...
	def export_stl(self, model: GEOM_Object, exp_file: str, is_binary: bool) -> None: ...
	def export_stl_for_viewer(self, model: GEOM_Object, exp_file: str, is_binary: bool) -> None: ...
	def get_default_stl_size(self, model: GEOM_Object) -> float: ...
	def get_refined_stl_size(self, model: GEOM_Object) -> float: ...
	def get_t2g_file_path(self) -> str: ...
	def get_stl_file_path(self) -> str: ...