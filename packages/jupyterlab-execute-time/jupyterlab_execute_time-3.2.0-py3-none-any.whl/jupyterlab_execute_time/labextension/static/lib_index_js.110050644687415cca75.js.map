{"version":3,"file":"lib_index_js.110050644687415cca75.js","mappings":";;;;;;;;;AAAa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB;AACnB,kBAAkB,mBAAO,CAAC,wEAAiB;AAC3C,oBAAoB,mBAAO,CAAC,4EAAmB;AAC/C,qBAAqB,mBAAO,CAAC,yCAAc;AAC3C,mBAAmB,mBAAO,CAAC,mEAAU;AACrC,mBAAmB,mBAAO,CAAC,kFAAsB;AACjD,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,wCAAwC,gBAAgB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,qBAAqB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,UAAU;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,mBAAmB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,mBAAmB;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,YAAY;AAClD;AACA,wCAAwC,mBAAmB,eAAe,2BAA2B;AACrG,yCAAyC,mBAAmB,YAAY,4BAA4B;AACpG,6CAA6C,oBAAoB,EAAE,kBAAkB,EAAE,kBAAkB;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,eAAe,IAAI,0BAA0B;AAClF;AACA;AACA;AACA;AACA;AACA,sCAAsC,oEAAoE;AAC1G;AACA,kCAAkC,cAAc;AAChD;AACA;AACA;AACA,oCAAoC,iBAAiB,QAAQ,iCAAiC;AAC9F,sCAAsC,4BAA4B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,eAAe,EAAE,kBAAkB,YAAY,QAAQ;AAClI;AACA,qBAAqB;AACrB;AACA,8CAA8C,sEAAsE;AACpH;AACA;AACA;AACA;AACA,wEAAwE,YAAY;AACpF;AACA,6CAA6C,uEAAuE;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,mBAAmB;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;;;;;;;;;;;AC5YF;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB,GAAG,qBAAqB,GAAG,0BAA0B;AACxE,mBAAmB,mBAAO,CAAC,mEAAU;AACrC;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,yBAAyB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,GAAG;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,KAAK;AAC5B;AACA;AACA,uBAAuB,MAAM;AAC7B;AACA;AACA,uBAAuB,KAAK;AAC5B;AACA;AACA;AACA;AACA,uBAAuB,4BAA4B;AACnD;AACA;AACA;AACA,mBAAmB;;;;;;;;;;;ACpEN;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB,mBAAO,CAAC,kFAAsB;AACjD,0BAA0B,mBAAO,CAAC,gGAA6B;AAC/D,yCAAyC,mBAAO,CAAC,uDAAqB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,gCAAgC;AACrF;AACA;AACA,iGAAiG,gCAAgC,IAAI,IAAI;AACzI;AACA;AACA;AACA;AACA;AACA;AACA,8FAA8F,IAAI;AAClG,aAAa;AACb;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,kBAAe","sources":["webpack://jupyterlab-execute-time/./lib/ExecuteTimeWidget.js","webpack://jupyterlab-execute-time/./lib/formatters.js","webpack://jupyterlab-execute-time/./lib/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PLUGIN_NAME = void 0;\nconst widgets_1 = require(\"@lumino/widgets\");\nconst coreutils_1 = require(\"@lumino/coreutils\");\nconst formatters_1 = require(\"./formatters\");\nconst date_fns_1 = require(\"date-fns\");\nconst apputils_1 = require(\"@jupyterlab/apputils\");\nexports.PLUGIN_NAME = 'jupyterlab-execute-time';\nconst EXECUTE_TIME_CLASS = 'execute-time';\nconst TOOLTIP_PREFIX = 'Previous Runs:';\nconst PREV_DATA_EXECUTION_TIME_ATTR = 'data-prev-execution-time';\n// How long do we animate the color for\nconst ANIMATE_TIME_MS = 1000;\nconst ANIMATE_CSS = `executeHighlight ${ANIMATE_TIME_MS}ms`;\nclass ExecuteTimeWidget extends widgets_1.Widget {\n    constructor(panel, tracker, settings) {\n        super();\n        /**\n         * The counter of updates ever scheduled for each existing cell.\n         */\n        this._updateCounter = new WeakMap();\n        this._cellSlotMap = {};\n        this._settings = {\n            enabled: false,\n            highlight: true,\n            positioning: 'left',\n            minTime: 0,\n            textContrast: 'high',\n            showLiveExecutionTime: true,\n            showDate: true,\n            historyCount: 5,\n            dateFormat: 'yyy-MM-dd HH:mm:ss',\n            showOutputsPerSecond: false,\n        };\n        this._panel = panel;\n        this._tracker = tracker;\n        this.updateConnectedCell = this.updateConnectedCell.bind(this);\n        this._updateSettings(settings);\n        settings.changed.connect(this._updateSettings.bind(this));\n    }\n    /**\n     * Handle `CellList.changed` signal.\n     */\n    updateConnectedCell(sender, changed) {\n        // When a cell is moved it's model gets re-created so we need to update\n        // the `metadataChanged` listeners.\n        // When cells are moved around the `CellList.changed` signal is first\n        // emitted with \"add\" type and the cell model information and then\n        // with \"remove\" type but lacking the old model (it is `undefined`).\n        // This causes a problem for the sequence of registering and deregistering\n        // listeners for the `metadataChanged` signal (register can be called when\n        // the cell was no yet removed from `this._cellSlotMap`, and deregister\n        // could be called with `undefined` value hence unable to remove it).\n        // There are two possible solutions:\n        // - (a) go over the list of cells and compare it with `cellSlotMap` (slow)\n        // - (b) deregister the cell model as it gets disposed just before\n        //      `CellList.changed` signals are emitted; we can do this by\n        //       listening to the `ICellModel.sharedModel.disposed` signal.\n        // The (b) solution is implemented in `_registerMetadataChanges` method.\n        // Reference:\n        // https://github.com/jupyterlab/jupyterlab/blob/4.0.x/packages/notebook/src/celllist.ts#L131-L159\n        changed.oldValues.forEach(this._deregisterMetadataChanges.bind(this));\n        changed.newValues.forEach(this._registerMetadataChanges.bind(this));\n    }\n    _registerMetadataChanges(cellModel) {\n        if (!(cellModel.id in this._cellSlotMap)) {\n            // Register signal handler with `cellModel` stored in closure.\n            const fn = () => this._cellMetadataChanged(cellModel);\n            this._cellSlotMap[cellModel.id] = fn;\n            cellModel.metadataChanged.connect(fn);\n            // Copy cell model identifier and store a reference to `metadataChanged`\n            // signal to keep them available even during cell model disposal.\n            const id = cellModel.id;\n            const metadataChanged = cellModel.metadataChanged;\n            // Register a model disposal handler on the underlying shared model,\n            // see the explanation in `updateConnectedCell()` method.\n            const deregisterOnDisposal = () => {\n                this._deregisterMetadataChanges({ metadataChanged, id });\n                cellModel.sharedModel.disposed.disconnect(deregisterOnDisposal);\n            };\n            cellModel.sharedModel.disposed.connect(deregisterOnDisposal);\n        }\n        // Always re-render cells.\n        // In case there was already metadata: do not highlight on first load.\n        this._cellMetadataChanged(cellModel, true);\n    }\n    _deregisterMetadataChanges(cellModel) {\n        if (cellModel !== undefined) {\n            const fn = this._cellSlotMap[cellModel.id];\n            if (fn) {\n                cellModel.metadataChanged.disconnect(fn);\n                const codeCell = this._getCodeCell(cellModel);\n                if (codeCell) {\n                    this._removeExecuteNode(codeCell);\n                }\n            }\n            delete this._cellSlotMap[cellModel.id];\n        }\n    }\n    _cellMetadataChanged(cellModel, disableHighlight = false) {\n        const codeCell = this._getCodeCell(cellModel);\n        if (codeCell) {\n            this._updateCodeCell(codeCell, disableHighlight).catch(console.error);\n        }\n        else {\n            if (cellModel.type === 'code') {\n                console.error(`Could not find code cell for model: ${cellModel}`);\n            }\n        }\n    }\n    /**\n     * Return a codeCell for this model if there is one. This will return null\n     * in cases of non-code cells.\n     *\n     * @param cellModel\n     * @private\n     */\n    _getCodeCell(cellModel) {\n        if (cellModel.type === 'code') {\n            const cell = this._panel.content.widgets.find((widget) => widget.model === cellModel);\n            return cell;\n        }\n        return null;\n    }\n    /**\n     * If there was a executeTime node added, remove it\n     * @param cell\n     * @private\n     */\n    _removeExecuteNode(cell) {\n        const executionTimeNode = cell.node.querySelector(`.${EXECUTE_TIME_CLASS}`);\n        if (executionTimeNode) {\n            executionTimeNode.remove();\n        }\n    }\n    /**\n     * Update the code cell to reflect the metadata\n     * @param cell\n     * @private\n     */\n    async _updateCodeCell(cell, disableHighlight) {\n        var _a;\n        // First update and store current update number.\n        const updateNumber = this._increaseUpdateCounter(cell);\n        // Cells don't have inputArea attributes until they are ready; wait for this.\n        // Cells can be in the viewport but not yet ready when the `defer` mode is used.\n        await cell.ready;\n        // Wait until the cell is in the viewport before querying for the node,\n        // as otherwise it would not be found as contents are detached from DOM.\n        if (!cell.inViewport) {\n            const shouldContinue = await this._cellInViewport(cell, updateNumber);\n            if (!shouldContinue) {\n                return;\n            }\n        }\n        const executionMetadata = cell.model.getMetadata('execution');\n        if (executionMetadata && coreutils_1.JSONExt.isObject(executionMetadata)) {\n            let executionTimeNode = cell.node.querySelector(`.${EXECUTE_TIME_CLASS}`);\n            const parentNode = this._settings.positioning === 'hover'\n                ? cell.inputArea.node.parentNode\n                : cell.inputArea.editorWidget.node;\n            if (!executionTimeNode) {\n                executionTimeNode = document.createElement('div');\n                executionTimeNode.appendChild(document.createElement('span'));\n                // Use this over gap as hover is not a flexbox\n                const spacer = document.createElement('div');\n                spacer.style.minWidth = '12px';\n                executionTimeNode.appendChild(spacer);\n                executionTimeNode.appendChild(document.createElement('span'));\n                if (!cell.inputHidden) {\n                    parentNode.append(executionTimeNode);\n                }\n            }\n            else if (executionTimeNode.parentNode !== parentNode) {\n                executionTimeNode.remove();\n                parentNode.append(executionTimeNode);\n            }\n            // Ensure that the current cell onclick actives the current cell\n            executionTimeNode.onclick = () => {\n                // This check makes sure that range selections (mostly) work\n                // activate breaks the range selection otherwise\n                if (this._tracker.activeCell !== cell) {\n                    cell.activate();\n                }\n            };\n            let positioning;\n            switch (this._settings.positioning) {\n                case 'left':\n                    positioning = 'left';\n                    break;\n                case 'right':\n                    positioning = 'right';\n                    break;\n                case 'hover':\n                    positioning = 'hover';\n                    break;\n                default:\n                    console.error(`'${positioning}' is not a valid type for the setting 'positioning'`);\n            }\n            const positioningClass = `${EXECUTE_TIME_CLASS}-positioning-${this._settings.positioning}`;\n            const textContrastClass = `${EXECUTE_TIME_CLASS}-contrast-${this._settings.textContrast}`;\n            executionTimeNode.className = `${EXECUTE_TIME_CLASS} ${positioningClass} ${textContrastClass}`;\n            // More info about timing: https://jupyter-client.readthedocs.io/en/stable/messaging.html#messages-on-the-shell-router-dealer-channel\n            // A cell is queued when the kernel has received the message\n            // A cell is running when the kernel has started executing\n            // A cell is done when the execute_reply has has finished\n            const queuedTimeStr = executionMetadata['iopub.status.busy'];\n            const queuedTime = queuedTimeStr ? new Date(queuedTimeStr) : null;\n            const startTimeStr = (executionMetadata['shell.execute_reply.started'] ||\n                executionMetadata['iopub.execute_input']);\n            // Using started is more accurate, but we don't get this until after the cell has finished executing\n            const startTime = startTimeStr ? new Date(startTimeStr) : null;\n            // This is the time the kernel is done processing and starts replying\n            const failed = executionMetadata['execution_failed'];\n            const endTimeStr = ((_a = executionMetadata['shell.execute_reply']) !== null && _a !== void 0 ? _a : failed);\n            const endTime = endTimeStr ? new Date(endTimeStr) : null;\n            // shell.execute_reply can be one of:  One of: 'ok' OR 'error' OR 'aborted'\n            // We want to remove the cases where it's not 'ok', but that's not in the metadata\n            // So we assume that if iopub.execute_input never happened, the cell never ran, thus not ok.\n            // This is assumed to be true because per the spec below, the code being executed should be sent to all frontends\n            // See: https://jupyter-client.readthedocs.io/en/stable/messaging.html#messages-on-the-shell-router-dealer-channel\n            // See: https://jupyter-client.readthedocs.io/en/stable/messaging.html#code-inputs\n            const isLikelyAborted = endTimeStr && !executionMetadata['iopub.execute_input'];\n            let msg = '';\n            if (isLikelyAborted) {\n                msg = '';\n            }\n            else if (endTime) {\n                const executionTimeMillis = (0, date_fns_1.differenceInMilliseconds)(endTime, startTime);\n                if (this._settings.minTime <= executionTimeMillis / 1000.0) {\n                    const executionTime = (0, formatters_1.getTimeDiff)(endTime, startTime);\n                    const executionsPerSecond = 1000.0 / executionTimeMillis;\n                    const lastExecutionTime = executionTimeNode.getAttribute(PREV_DATA_EXECUTION_TIME_ATTR);\n                    // Store the last execution time in the node to be used for various options\n                    executionTimeNode.setAttribute(PREV_DATA_EXECUTION_TIME_ATTR, executionTime);\n                    // Only add a tooltip for all non-displayed execution times.\n                    if (this._settings.historyCount > 0 && lastExecutionTime) {\n                        let tooltip = executionTimeNode.getAttribute('title');\n                        const executionTimes = [lastExecutionTime];\n                        if (tooltip) {\n                            executionTimes.push(...tooltip.substring(TOOLTIP_PREFIX.length + 1).split('\\n'));\n                            // JS does the right thing of having empty items if extended\n                            executionTimes.length = this._settings.historyCount;\n                        }\n                        tooltip = `${TOOLTIP_PREFIX}\\n${executionTimes.join('\\n')}`;\n                        executionTimeNode.setAttribute('title', tooltip);\n                    }\n                    executionTimeNode.children[2].textContent = '';\n                    msg = failed ? 'Failed' : 'Last executed';\n                    if (this._settings.showDate) {\n                        msg += ` at ${(0, formatters_1.getTimeString)(endTime, this._settings.dateFormat)}`;\n                    }\n                    msg += ` in ${executionTime}`;\n                    const numberOfOutputs = cell.model.outputs.length;\n                    if (this._settings.showOutputsPerSecond && numberOfOutputs > 0) {\n                        const outputsPerSecond = executionsPerSecond / numberOfOutputs;\n                        msg += `, ${numberOfOutputs} output${numberOfOutputs === 1 ? '' : 's'}`;\n                        msg += ` at ${outputsPerSecond.toFixed(2)}/s`;\n                    }\n                }\n            }\n            else if (startTime) {\n                if (this._settings.showLiveExecutionTime) {\n                    const lastRunTime = executionTimeNode.getAttribute('data-prev-execution-time');\n                    const workingTimer = setInterval(() => {\n                        if (!executionTimeNode.children[0].textContent.startsWith('Execution started at')) {\n                            clearInterval(workingTimer);\n                            return;\n                        }\n                        const executionMetadata = cell.model.getMetadata('execution');\n                        if (!executionMetadata || executionMetadata['execution_failed']) {\n                            // (if cell got re-scheduled the metadata will be empty too)\n                            clearInterval(workingTimer);\n                            return this._updateCodeCell(cell, disableHighlight);\n                        }\n                        if (this._settings.minTime <=\n                            (0, date_fns_1.differenceInMilliseconds)(new Date(), startTime) / 1000.0) {\n                            const executionTime = (0, formatters_1.getTimeDiff)(new Date(), startTime);\n                            executionTimeNode.children[2].textContent = `${executionTime} ${lastRunTime ? `(${lastRunTime})` : ''}`;\n                        }\n                    }, 100);\n                }\n                msg = `Execution started at ${(0, formatters_1.getTimeString)(startTime, this._settings.dateFormat)}`;\n            }\n            else if (queuedTime) {\n                const lastRunTime = executionTimeNode.getAttribute('data-prev-execution-time');\n                if (this._settings.showLiveExecutionTime && lastRunTime) {\n                    executionTimeNode.children[2].textContent = `N/A (${lastRunTime})`;\n                }\n                msg = `Execution queued at ${(0, formatters_1.getTimeString)(queuedTime, this._settings.dateFormat)}`;\n            }\n            if (executionTimeNode.textContent !== msg) {\n                executionTimeNode.children[0].textContent = msg;\n                if (!disableHighlight && this._settings.highlight && endTimeStr) {\n                    executionTimeNode.style.setProperty('animation', ANIMATE_CSS);\n                    setTimeout(() => executionTimeNode.style.removeProperty('animation'), ANIMATE_TIME_MS);\n                }\n            }\n        }\n        else {\n            // Hide it if data was removed (e.g. clear output).\n            // Don't remove as element store history, which are useful for later showing past runtime.\n            const executionTimeNode = cell.node.querySelector(`.${EXECUTE_TIME_CLASS}`);\n            if (executionTimeNode) {\n                executionTimeNode.classList.add('execute-time-hidden');\n            }\n        }\n    }\n    _updateSettings(settings) {\n        this._settings.enabled = settings.get('enabled').composite;\n        this._settings.highlight = settings.get('highlight').composite;\n        this._settings.positioning = settings.get('positioning')\n            .composite;\n        this._settings.minTime = settings.get('minTime').composite;\n        this._settings.textContrast = settings.get('textContrast')\n            .composite;\n        this._settings.showLiveExecutionTime = settings.get('showLiveExecutionTime')\n            .composite;\n        this._settings.showDate = settings.get('showDate').composite;\n        this._settings.historyCount = settings.get('historyCount')\n            .composite;\n        const dateFormat = settings.get('dateFormat').composite;\n        const formatValidationResult = (0, formatters_1.validateDateFormat)(dateFormat);\n        if (formatValidationResult.isValid) {\n            this._settings.dateFormat = dateFormat;\n        }\n        else {\n            // fallback to default\n            this._settings.dateFormat = 'yyy-MM-dd HH:mm:ss';\n            // warn user once\n            void (0, apputils_1.showErrorMessage)('Invalid date format in Execute Time extension setting', formatValidationResult.message);\n        }\n        this._settings.showOutputsPerSecond = settings.get('showOutputsPerSecond')\n            .composite;\n        const cells = this._panel.context.model.cells;\n        if (this._settings.enabled) {\n            cells.changed.connect(this.updateConnectedCell);\n            for (let i = 0; i < cells.length; ++i) {\n                this._registerMetadataChanges(cells.get(i));\n            }\n        }\n        else {\n            cells.changed.disconnect(this.updateConnectedCell);\n            for (let i = 0; i < cells.length; ++i) {\n                this._deregisterMetadataChanges(cells.get(i));\n            }\n        }\n    }\n    /**\n     * Generate a promise which resolves to `true` when cell enters the viewport,\n     * or to `false` when an update newer than given `updateNumber` arrives.\n     */\n    _cellInViewport(cell, updateNumber) {\n        return new Promise((resolved) => {\n            const clearHandlers = () => {\n                cell.inViewportChanged.disconnect(handler);\n                cell.disposed.disconnect(disposedHandler);\n                this._panel.disposed.disconnect(disposedHandler);\n            };\n            const handler = (_emitter, attached) => {\n                const currentNumber = this._updateCounter.get(cell);\n                if (updateNumber !== currentNumber) {\n                    clearHandlers();\n                    return resolved(false);\n                }\n                if (attached) {\n                    clearHandlers();\n                    return resolved(true);\n                }\n            };\n            const disposedHandler = () => {\n                // Disconnect handlers and resolve promise on cell/notebook disposal.\n                clearHandlers();\n                return resolved(false);\n            };\n            cell.inViewportChanged.connect(handler);\n            // Listen to `dispose` signal of individual cells to clear promise\n            // when cells get deleted before entering the viewport (ctrl + a, dd).\n            cell.disposed.connect(disposedHandler);\n            // Listen to notebook too because the `disposed` signal of individual\n            // cells is not fired when closing the entire notebook.\n            this._panel.disposed.connect(disposedHandler);\n        });\n    }\n    /**\n     * Increase counter of updates ever scheduled for a given `cell`.\n     * Returns the current counter value for the given `cell`.\n     */\n    _increaseUpdateCounter(cell) {\n        var _a;\n        const newValue = ((_a = this._updateCounter.get(cell)) !== null && _a !== void 0 ? _a : 0) + 1;\n        this._updateCounter.set(cell, newValue);\n        return newValue;\n    }\n}\nexports.default = ExecuteTimeWidget;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getTimeDiff = exports.getTimeString = exports.validateDateFormat = void 0;\nconst date_fns_1 = require(\"date-fns\");\n/**\n * Checks if a given date format string is valid.\n *\n * This function checks if the input date format string is valid.\n *\n * @param {string} dateFormat - The date format string to validate.\n * @returns {IFormatValidationResult} Returns validation result.\n */\nconst validateDateFormat = (dateFormat) => {\n    const testDate = new Date();\n    try {\n        (0, date_fns_1.format)(testDate, dateFormat);\n        return {\n            isValid: true,\n        };\n    }\n    catch (error) {\n        return {\n            isValid: false,\n            message: error.message,\n        };\n    }\n};\nexports.validateDateFormat = validateDateFormat;\nconst getTimeString = (date, dateFormat = 'yyy-MM-dd HH:mm:ss') => {\n    return (0, date_fns_1.format)(date, dateFormat);\n};\nexports.getTimeString = getTimeString;\nconst getTimeDiff = (end, start) => {\n    // Human format based on loosely on ideas from:\n    // https://github.com/ipython-contrib/jupyter_contrib_nbextensions/blob/master/src/jupyter_contrib_nbextensions/nbextensions/execute_time/ExecuteTime.js#L194\n    const MS_IN_SEC = 1000;\n    const MS_IN_MIN = 60 * MS_IN_SEC;\n    const MS_IN_HR = 60 * MS_IN_MIN;\n    const MS_IN_DAY = 24 * MS_IN_HR;\n    let ms = (0, date_fns_1.differenceInMilliseconds)(end, start);\n    if (ms < MS_IN_SEC) {\n        return `${ms}ms`;\n    }\n    const days = Math.floor(ms / MS_IN_DAY);\n    ms = ms % MS_IN_DAY;\n    const hours = Math.floor(ms / MS_IN_HR);\n    ms = ms % MS_IN_HR;\n    const mins = Math.floor(ms / MS_IN_MIN);\n    ms = ms % MS_IN_MIN;\n    // We want to show this as fractional\n    const secs = ms / MS_IN_SEC;\n    let timeDiff = '';\n    if (days) {\n        timeDiff += `${days}d `;\n    }\n    if (days || hours) {\n        timeDiff += `${hours}h `;\n    }\n    if (days || hours || mins) {\n        timeDiff += `${mins}m `;\n    }\n    // Only show s if its < 1 day\n    if (!days) {\n        // Only show ms if is < 1 hr\n        timeDiff += `${secs.toFixed(hours ? 0 : 2)}s`;\n    }\n    return timeDiff.trim();\n};\nexports.getTimeDiff = getTimeDiff;\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst notebook_1 = require(\"@jupyterlab/notebook\");\nconst settingregistry_1 = require(\"@jupyterlab/settingregistry\");\nconst ExecuteTimeWidget_1 = __importStar(require(\"./ExecuteTimeWidget\"));\nclass ExecuteTimeWidgetExtension {\n    constructor(tracker, settings) {\n        this._settings = settings;\n        this._tracker = tracker;\n    }\n    // We get a notebook panel because of addWidgetExtension('Notebook', ...) below\n    createNew(panel, context) {\n        return new ExecuteTimeWidget_1.default(panel, this._tracker, this._settings);\n    }\n}\n/**\n * Initialization data for the jupyterlab-execute-time extension.\n */\nconst extension = {\n    id: ExecuteTimeWidget_1.PLUGIN_NAME,\n    autoStart: true,\n    requires: [notebook_1.INotebookTracker, settingregistry_1.ISettingRegistry],\n    activate: async (app, tracker, settingRegistry) => {\n        let settings;\n        try {\n            settings = await settingRegistry.load(`${ExecuteTimeWidget_1.PLUGIN_NAME}:settings`);\n        }\n        catch (err) {\n            console.error(`jupyterlab-execute-time: Could not load settings, so did not active ${ExecuteTimeWidget_1.PLUGIN_NAME}: ${err}`);\n            return;\n        }\n        // If the plugin is enabled, force recording of timing\n        // We only do this once (not on every settings update) in case the user tries to turn it off\n        if (settings.get('enabled').composite) {\n            settingRegistry.load('@jupyterlab/notebook-extension:tracker').then((nbSettings) => nbSettings.set('recordTiming', true), (err) => {\n                console.error(`jupyterlab-execute-time: Could not force metadata recording: ${err}`);\n            });\n        }\n        app.docRegistry.addWidgetExtension('Notebook', new ExecuteTimeWidgetExtension(tracker, settings));\n        // eslint-disable-next-line no-console\n        console.log('JupyterLab extension jupyterlab-execute-time is activated!');\n    },\n};\nexports.default = extension;\n"],"names":[],"sourceRoot":""}