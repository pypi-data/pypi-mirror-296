from .calc import parse_boolean_environment as parse_boolean_environment
from _typeshed import Incomplete
from functools import reduce as reduce
from math import gcd as gcd

class ExpressionProperties:
    """
    A class to store and manage properties of various expressions.
    Currently used to store information about parenthesis.
    """
    force_parenthesis: Incomplete
    def __init__(self, force_parenthesis: bool = False) -> None: ...
    def can_unify(self, o): ...
    def can_unify_not_expression(self): ...
    def unify(self, o): ...
    def unify_not_expression(self): ...

class Expression:
    """
    A general class for boolean/mathematical expressions.
    It is the most general class.
    An expression can be: A constant, a variable, a constraint, or an operation.
    """
    def __init__(self) -> None: ...
    def __bool__(self) -> bool: ...
    def exactly_equals(self, o): ...
    def find_exactly_equals(self, o): ...
    def with_properties(self, properties): ...
    def __eq__(self, o): ...
    def __and__(self, o): ...
    def __rand__(self, o): ...
    def __or__(self, o): ...
    def __ror__(self, o): ...
    def __lt__(self, o): ...
    def __le__(self, o): ...
    def __gt__(self, o): ...
    def __ge__(self, o): ...
    def __add__(self, o): ...
    def __radd__(self, o): ...
    def __xor__(self, o): ...
    def __rxor__(self, o): ...
    def __sub__(self, o): ...
    def __rsub__(self, o): ...
    def __invert__(self): ...
    def __neg__(self): ...
    def __mul__(self, o): ...
    def __rmul__(self, o): ...
    def __pow__(self, o): ...
    def __rpow__(self, o): ...
    def unify(self, o, cls, is_primary) -> None: ...
    def list_operands(self) -> None: ...
    def map_tree(self, fn): ...
    def map_tree_convergence(self, fn): ...
    def map_convergence(self, fn): ...
    def __hash__(self): ...
    def rec_list_operands(self): ...
    def is_fully_boolean(self) -> None: ...
    def distributive_cnf(self, debug: bool = False): ...
    def assert_boolean_operands(self) -> None: ...
    def represent(self, parenthesis: Incomplete | None = None, latex: bool = False): ...
    def represent_by_step(self): ...
    def is_clause(self): ...
    def is_literal(self): ...
    def is_unitary(self): ...
    def try_simplify_constants(self): ...
    def try_flatten(self): ...
    @classmethod
    def operate(cls, *ops) -> None: ...

class Operation(Expression): ...

class AbelianSemiGroup(Operation):
    """
    A class representing an Abelian semi-group, a fancy term for expressions that have associative and commutative operations (like addition).
    It is used to represent N-operands operations.
    """
    def __init__(self, *args, **kwargs) -> None: ...
    def try_flatten(self): ...
    def flatten(self): ...
    def try_simplify_constants(self): ...
    def list_operands(self): ...
    def unify(self, o, cls, is_primary): ...

class Add(AbelianSemiGroup):
    """
    A class for addition expressions.
    """
    symbol: str
    operands: Incomplete
    def __init__(self, *args) -> None: ...
    def evaluate(self, interpretation): ...
    def is_fully_boolean(self): ...
    @staticmethod
    def operate(*ops): ...

class And(AbelianSemiGroup):
    """
    A class for conjunction expressions.
    """
    symbol: str
    operands: Incomplete
    def __init__(self, *args) -> None: ...
    def is_fully_boolean(self): ...
    def evaluate(self, interpretation): ...
    @staticmethod
    def operate(*ops): ...

class Xor(AbelianSemiGroup):
    """
    A class for exclusive disjunction expressions.
    """
    symbol: str
    operands: Incomplete
    def __init__(self, *args) -> None: ...
    def is_fully_boolean(self): ...
    def evaluate(self, interpretation): ...
    @staticmethod
    def operate(*ops): ...

class Or(AbelianSemiGroup):
    """
    A class for disjunction expressions.
    """
    symbol: str
    operands: Incomplete
    def __init__(self, *args) -> None: ...
    def evaluate(self, interpretation): ...
    def is_clause(self): ...
    def is_fully_boolean(self): ...
    @staticmethod
    def operate(*ops): ...

class Iff(AbelianSemiGroup):
    """
    A class for equivalence expressions.
    Notice that Iff is a semi-group, not a bi-expression.
    """
    symbol: str
    operands: Incomplete
    def __init__(self, *args) -> None: ...
    def evaluate(self, interpretation): ...
    def is_fully_boolean(self): ...
    @staticmethod
    def operate(a, b): ...

class Multiply(AbelianSemiGroup):
    """
    A class for multiplication expressions.
    """
    symbol: str
    operands: Incomplete
    def __init__(self, *args) -> None: ...
    def evaluate(self, interpretation): ...
    @staticmethod
    def operate(*ops): ...
    def is_fully_boolean(self): ...

class UnitaryExpression(Operation):
    """
    A class for expressions with only one operand
    """
    def __init__(self, *args, **kwargs) -> None: ...
    def is_unitary(self): ...
    def list_operands(self): ...

class Not(UnitaryExpression):
    """
    A class for negation expressions.
    """
    symbol: str
    operand: Incomplete
    def __init__(self, operand) -> None: ...
    def is_literal(self): ...
    def is_fully_boolean(self): ...
    def evaluate(self, interpretation): ...
    @staticmethod
    def operate(a): ...

class Minus(UnitaryExpression):
    """
    A class for negation expressions.
    """
    symbol: str
    operand: Incomplete
    def __init__(self, operand) -> None: ...
    def evaluate(self, interpretation): ...
    @staticmethod
    def operate(a): ...
    def is_fully_boolean(self): ...

class BiExpression(Operation):
    """
    A class for expressions with two operands (like If, Power).
    Used for operations that do not fit the AbelianSemiGroup definition.
    """
    def __init__(self, left, right, *args, **kwargs) -> None: ...
    def list_operands(self): ...

class Substract(BiExpression):
    """
    A class for substraction expressions.
    """
    symbol: str
    def evaluate(self, interpretation): ...
    @staticmethod
    def operate(a, b): ...

class If(BiExpression):
    """
    A class for implication expressions.
    """
    symbol: str
    def __init__(self, *args, **kwargs) -> None: ...
    def evaluate(self, interpretation): ...
    def is_fully_boolean(self): ...
    @staticmethod
    def operate(a, b): ...

class Power(BiExpression):
    """
    A class for power expressions.
    """
    symbol: str
    def evaluate(self, interpretation): ...
    @staticmethod
    def operate(a, b): ...
    def is_fully_boolean(self): ...

class PseudoBooleanExpression(BiExpression):
    """
    A class for pseudo boolean expressions (like LessOrEqual, GreaterOrEqual, etc.)
    """
    def is_fully_boolean(self): ...
    def negate(self) -> None: ...
    def to_less_than(self) -> None: ...

class Equality(PseudoBooleanExpression):
    """
    A class for equality constraints
    """
    symbol: str
    def evaluate(self, interpretation): ...
    def negate(self): ...
    def to_less_than(self) -> None: ...

class LessThan(PseudoBooleanExpression):
    """
    A class for less than constraints
    """
    symbol: str
    def evaluate(self, interpretation): ...
    def negate(self): ...
    def to_less_than(self): ...

class LessOrEqual(PseudoBooleanExpression):
    """
    A class for less or equal constraints
    """
    symbol: str
    def evaluate(self, interpretation): ...
    def negate(self): ...
    def to_less_than(self): ...

class GreaterThan(PseudoBooleanExpression):
    """
    A class for greater than constraints
    """
    symbol: str
    def evaluate(self, interpretation): ...
    def negate(self): ...
    def to_less_than(self): ...

class GreaterOrEqual(PseudoBooleanExpression):
    """
    A class for greater or equal constraints
    """
    symbol: str
    def evaluate(self, interpretation): ...
    def negate(self): ...
    def to_less_than(self): ...

class Atom(Expression):
    """
    A class for atoms in expressions.
    An atom is a variable or a constant.
    """
    def try_simplify_constants(self): ...

class AtomVariable(Atom):
    """
    A class for variables in expressions.
    This class represents actual variables of the problem.
    """
    name_pattern: Incomplete
    name: Incomplete
    def __init__(self, name, *args, **kwargs) -> None: ...
    def exactly_equals(self, o): ...
    def evaluate(self, interpretation): ...
    def __hash__(self): ...
    def list_operands(self): ...
    def map_tree(self, fn): ...

class Bool(AtomVariable):
    """
    A class for Boolean variables.
    """
    def __init__(self, name) -> None: ...
    @staticmethod
    def parse(txt): ...
    def is_literal(self): ...
    def is_fully_boolean(self): ...
    @staticmethod
    def get_constant(value): ...
    def evaluate(self, interpretation): ...

class Int(AtomVariable):
    """
    A class for integer variables.
    """
    def __init__(self, name) -> None: ...
    def is_fully_boolean(self): ...

class IntConstant(Atom):
    """
    A class for constants in expressions.
    """
    constant: Incomplete
    def __init__(self, constant, *args, **kwargs) -> None: ...
    def exactly_equals(self, o): ...
    def evaluate(self, interpretation): ...
    def list_operands(self): ...
    def map_tree(self, fn): ...
    def is_negative(self): ...
    def negate(self): ...
    def __hash__(self): ...

class ExactDictionaryComparator:
    """
    A class to compare two dictionaries for exact matching of the objects.
    Used to implement the translation cache.
    """
    obj: Incomplete
    def __init__(self, obj) -> None: ...
    def __eq__(self, o): ...
    def __hash__(self): ...

class Representor:
    """
    A class to represent expressions or constraints in a human-readable way.
    This class has all the logic to print the expressions on the terminal.
    Many constraints have to be considered (printing in python priority of operands, maintain parenthesis if provided by the user, provide options for printing with the maximum amount of parenthesis and the minimum amount, etc.)
    """
    priorities: Incomplete
    associative_rules: Incomplete
    @staticmethod
    def get_priority(op): ...
    @staticmethod
    def should_have_parens(father, son, is_primary_operand, parenthesis): ...
    @staticmethod
    def represent(root, father: Incomplete | None = None, is_primary_operand: bool = True, parenthesis: Incomplete | None = None, latex: bool = False): ...
    @staticmethod
    def to_latex(str_repr): ...
    @staticmethod
    def represent_by_step(root): ...
    @staticmethod
    def generate_str(root, operands, parenthesis): ...

class DistributiveCNF:
    """
    A class for CNF representation using distributive properties.
    This class has the same logic that students would use in class to apply the distributive properties to reduce a formula to CNF.
    """
    @staticmethod
    def first_step(c): ...
    @staticmethod
    def second_step(c): ...
    @staticmethod
    def third_step(c): ...
    @staticmethod
    def to_cnf(c, debug: bool = False): ...
