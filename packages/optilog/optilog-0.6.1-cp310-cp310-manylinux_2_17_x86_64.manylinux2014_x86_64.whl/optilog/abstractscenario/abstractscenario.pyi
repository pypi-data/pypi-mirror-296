from _typeshed import Incomplete
from optilog.blackbox import ExecutionConstraints as ExecutionConstraints
from optilog.internalutils import ErrorHandlerParser as ErrorHandlerParser, get_program as get_program, path_or_err as path_or_err
from pathlib import Path
from typing import Any

class GlobalAbstractScenarioAnnotation:
    execution: bool
    def __init__(self) -> None: ...
    def set_execution_flag(self) -> None: ...

abstract_scenario_annotation: Incomplete
SCENARIO_ENTRYPOINT_NAME: str

class AbstractScenario:
    PKL_NAME: str
    JSON_NAME: str
    runnables: Incomplete
    scenario_entrypoint: Incomplete
    at_creation_cwd: Incomplete
    constraints: Incomplete
    def __init__(self, runnables, constraints, scenario_entrypoint) -> None: ...
    @property
    def scenario_dir(self): ...
    def run_raw(self, runnable_id: Any, *args, **kwargs): ...
    def get_command(self, runnable_id: Any, instance: str, seed: int = None): ...
    def generate_abstract_scenario(self, path: str | Path): ...
    def save_pickle(self, path: str | Path): ...
    @staticmethod
    def load_pickle(module_path, scenario_path) -> AbstractScenario: ...
    @staticmethod
    def load_from_path(path): ...
    @staticmethod
    def run_main_template(scenario_path: Path): ...

class AbstractScenarioContext:
    original_wd: Incomplete
    scenario_path: Incomplete
    kwargs: Incomplete
    def __init__(self, original_wd, scenario_path, **kwargs) -> None: ...

def abstract_scenario_entrypoint(context: AbstractScenarioContext): ...

class CliAbstractScenario:
    def parse_args(self): ...

def abstract_scenario_cli() -> None: ...
