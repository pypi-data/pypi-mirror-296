from typing import Tuple


class FastAPIMetricsManager:
    """
    A manager class for handling FastAPI application metrics using OpenTelemetry.

    This class sets up various metrics related to FastAPI applications, such as request counts,
    response counts, request processing times, exceptions, and requests in progress.

    Attributes:
        meter: The OpenTelemetry meter used for creating and recording metrics.
    """

    def __init__(self, meter):
        """
        Initializes the FastAPIMetricsManager with the provided OpenTelemetry meter.

        Args:
            meter: An OpenTelemetry meter instance for creating metrics.
        """
        self.meter = meter
        self._setup()

    def _setup(self):
        """
        Sets up the various metrics for monitoring FastAPI applications.

        This method creates counters, histograms, and gauges for tracking FastAPI-related metrics.
        """
        self.app_info = self.meter.create_up_down_counter(
            name="fastapi_app_info",
            description="FastAPI application information.",
        )

        self.requests_total_metric = self.meter.create_counter(
            name="fastapi_requests_total",
            description="Total count of requests by method and path.",
        )

        self.responses_total_metric = self.meter.create_counter(
            name="fastapi_responses_total",
            description="Total count of responses by method, path, and status codes.",
        )

        self.requests_processing_time_metric = self.meter.create_histogram(
            name="fastapi_requests_duration_seconds",
            description="Histogram of request processing time by path (in seconds).",
        )

        self.exceptions_metric = self.meter.create_counter(
            name="fastapi_exceptions_total",
            description="Total count of exceptions raised by path and exception type.",
        )

        self.requests_in_progress_metrics = self.meter.create_up_down_counter(
            name="fastapi_requests_in_progress",
            description="Gauge of requests by method and path currently being processed.",
        )

    def register_for_metrics(self, app, app_name: str):
        """
        Registers the FastAPI application for metrics tracking using the provided app name.

        Args:
            app: The FastAPI application instance.
            app_name (str): The name of the FastAPI application.
        """
        import time
        from opentelemetry import trace
        from starlette.middleware.base import BaseHTTPMiddleware, RequestResponseEndpoint
        from starlette.types import ASGIApp
        from starlette.requests import Request
        from starlette.responses import Response
        from starlette.routing import Match
        from starlette.status import HTTP_500_INTERNAL_SERVER_ERROR

        class OpenTelemetryMiddleware(BaseHTTPMiddleware):
            """
            Middleware class to collect and record metrics for each request and response in a FastAPI application.
            """

            def __init__(self, app: ASGIApp, app_name: str, metrics_manager: FastAPIMetricsManager) -> None:
                super().__init__(app)
                self.app_name = app_name
                self.metrics_manager = metrics_manager
                self.metrics_manager.app_info.add(1, {"app_name": self.app_name, "service_name": self.app_name})

            def get_attributes(self, request: Request, extra_attributes: dict = {}) -> dict:
                """
                Constructs the attributes dictionary for a given request.

                Args:
                    request (Request): The incoming HTTP request.
                    extra_attributes (dict): Additional attributes to include.

                Returns:
                    dict: A dictionary of attributes for the metrics.
                """
                attributes = {
                    "method": request.method,
                    "path": request.url.path,
                    "app_name": self.app_name,
                    "service_name": self.app_name
                }
                attributes.update(extra_attributes)
                return attributes

            async def dispatch(self, request: Request, call_next: RequestResponseEndpoint) -> Response:
                """
                Processes the incoming request, records metrics, and forwards it to the next handler.

                Args:
                    request (Request): The incoming HTTP request.
                    call_next (RequestResponseEndpoint): The next handler in the middleware chain.

                Returns:
                    Response: The HTTP response generated by the application.
                """
                method = request.method
                path, is_handled_path = self.get_path(request)

                if not is_handled_path:
                    return await call_next(request)

                self.metrics_manager.requests_in_progress_metrics.add(1, self.get_attributes(request))
                self.metrics_manager.requests_total_metric.add(1, self.get_attributes(request))
                before_time = time.perf_counter()

                try:
                    response = await call_next(request)
                except BaseException as e:
                    status_code = HTTP_500_INTERNAL_SERVER_ERROR
                    self.metrics_manager.exceptions_metric.add(
                        1, self.get_attributes(request, {"exception_type": type(e).__name__})
                    )
                    raise e from None
                else:
                    status_code = response.status_code
                    after_time = time.perf_counter()

                    # Retrieve trace id for linking metrics to traces
                    span = trace.get_current_span()
                    trace_id = trace.format_trace_id(span.get_span_context().trace_id)

                    self.metrics_manager.requests_processing_time_metric.record(
                        after_time - before_time,
                        self.get_attributes(request, {"TraceID": trace_id})
                    )
                finally:
                    self.metrics_manager.responses_total_metric.add(
                        1, self.get_attributes(request, {"status_code": status_code})
                    )
                    self.metrics_manager.requests_in_progress_metrics.add(-1, self.get_attributes(request))

                return response

            @staticmethod
            def get_path(request: Request) -> Tuple[str, bool]:
                """
                Determines the route path for the given request.

                Args:
                    request (Request): The incoming HTTP request.

                Returns:
                    Tuple[str, bool]: A tuple containing the route path and a boolean indicating if it's handled.
                """
                for route in request.app.routes:
                    match, child_scope = route.matches(request.scope)
                    if match == Match.FULL:
                        return route.path, True

                return request.url.path, False

        app.add_middleware(OpenTelemetryMiddleware, app_name=app_name, metrics_manager=self)
