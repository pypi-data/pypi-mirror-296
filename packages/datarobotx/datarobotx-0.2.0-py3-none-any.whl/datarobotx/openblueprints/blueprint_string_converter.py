#
# Copyright 2023 DataRobot, Inc. and its affiliates.
#
# All rights reserved.
#
# DataRobot, Inc.
#
# This is proprietary source code of DataRobot, Inc. and its
# affiliates.
#
# Released under the terms of DataRobot Tool and Utility Agreement.
from __future__ import annotations

import logging
from typing import List, Optional, Tuple

from datarobotx.openblueprints.enums import COPYRIGHT_STRING

logger = logging.getLogger("drx")


class BlueprintStringConverter:
    """BlueprintStringConverter handles common object to string conversions
    This is a static Mixin Class that is separated for readability.
    """

    DEFAULT_IMPORTS = ["numpy", "pandas", "sklearn"]
    STANDARD_INPUT_TEMPLATE = """
        from sklearn.pipeline import Pipeline
        from sklearn.compose import ColumnTransformer, make_column_selector

        # Load data into variable df
        try:
            input_data
        except NameError:
            raise ValueError("input_data must be defined by the users")
        df = pandas.DataFrame(input_data)
    """
    CATEGORICAL_COLUMN_TEMPLATE = """
        # Identify and tag categorical columns
        object_type_columns = df.select_dtypes(object).columns
        if len(object_type_columns)>0:
            category_by_length = (
                numpy.vectorize(len)(df[object_type_columns].values.astype(str)).max(axis=0) < 20
            )
            category_by_unique = numpy.array(
                df[object_type_columns].apply(pandas.Series.value_counts, normalize=True).max()
                > 0.05
            )
            categorical_indexes = category_by_unique & category_by_length
            categorical_columns = object_type_columns[categorical_indexes]
            df[categorical_columns] = df[categorical_columns].astype("category")
    """

    @staticmethod
    def format_code_block_with_black(code_block: str) -> str:
        try:
            import black

            return str(black.format_file_contents(code_block, fast=False, mode=black.FileMode()))

        except ImportError:
            logger.warning(
                "datarobotx.openblueprints() uses additional dependencies; consider using "
                "`pip install 'datarobotx[openblueprints]'`\n"
                "Converted code cannot be reformatted if `black` is missing."
            )
            return code_block

    @classmethod
    def make_blueprint(
        cls,
        blueprint_imports: List[str],
        preprocessor_pipeline: List[str],
        estimator_element: Tuple[str, str],
    ) -> str:
        """Construct and format code to create a code representation of a blueprint.

        Parameters
        ----------
        blueprint_imports : list[str]
            List of imports that should be added to the header
        preprocessor_pipeline : list[str]
            Column Transformer code string.
            See `make_column_transformer_from_pipeline`
        estimator_element : Tuple[str, str]
            A tuples represented as (estimator_name, estimator_action).
            The step_action can either be a class call (e.g. sklearn.impute.SimpleImputer())
            or "passthrough". The step_action is typically generated by the
            MappingObject.get_open_representation() function.

        Returns
        -------
        str
        """
        estimator_pipeline = cls.make_pipeline_from_pipeline_elements(
            cls.make_pipeline_elements_from_steps(
                [
                    ("preprocessor", "preprocessor"),
                    estimator_element,
                ]
            )
        )

        preprocessor_column_transformer = (
            cls.make_column_transformer_from_column_transformer_elements(preprocessor_pipeline)
        )

        blueprint_imports_str = "\n".join(
            f"import {i}" for i in sorted(set(blueprint_imports + cls.DEFAULT_IMPORTS))
        )

        blueprint_code = (
            f"{COPYRIGHT_STRING}\n"
            f"{blueprint_imports_str}\n"
            f"{cls.make_standard_template()}\n\n"
            f"preprocessor = {preprocessor_column_transformer}\n\n"
            f"estimator = {estimator_pipeline}"
        )
        blueprint_code_formatted = cls.format_code_block_with_black(blueprint_code)
        return str(blueprint_code_formatted)

    @classmethod
    def make_standard_template(cls) -> str:
        """Construct a standard template for the top of the code."""
        return f"{cls.STANDARD_INPUT_TEMPLATE}\n{cls.CATEGORICAL_COLUMN_TEMPLATE}".replace(
            "        ", ""
        )

    @staticmethod
    def make_pipeline_elements_from_steps(
        pipeline_steps: List[Tuple[str, str]], reverse: bool = False, index: Optional[int] = None
    ) -> str:
        """Build a string of pipeline elements from raw pipeline steps.

        Parameters
        ----------
        pipeline_steps : List[Tuple[str, str]]
            A list of tuples, where each tuple is (step_name, step_action).
            The step_action can either be a class call (e.g. sklearn.impute.SimpleImputer())
            or "passthrough". The step_action is typically generated by the
            MappingObject.get_open_representation() function.
        reverse : bool
            Reverse the list. If steps are added from last to first, this should be set to True
            so that the final pipeline is in the correct direction.

        Returns
        -------
        str
        """
        if reverse:
            pipeline_steps = pipeline_steps[::-1]
        index_str = "" if index is None else f"_{index + 1}"
        return ",".join([f'("{x[0]}{index_str}", {x[1]})' for x in pipeline_steps])

    @staticmethod
    def make_pipeline_from_pipeline_elements(pipeline_element_str: str) -> str:
        """Return a Pipeline representation from a pre-formatted transformer pipeline element
        Elements should be created from steps with `make_pipeline_elements_from_steps`.
        """
        return f"Pipeline([{pipeline_element_str}])"

    @classmethod
    def make_column_transformer_element_from_pipeline(
        cls,
        transformer_name: str,
        transformer_pipeline: str,
        transformer_columns: Optional[str] = None,
    ) -> str:
        """Construct a column tranformer element from a pre-formatted transformer pipeline.

        Pipeline should be created from steps with:
        `make_pipeline_elements_from_steps` and `make_pipeline_from_pipeline_elements`
        """
        if transformer_columns is None:
            return f'("{transformer_name}", {transformer_pipeline})'
        return f'("{transformer_name}", {transformer_pipeline}, {transformer_columns})'

    @staticmethod
    def make_column_transformer_from_column_transformer_elements(
        column_transformer_elements: List[str],
    ) -> str:
        """Return a Column Transformer representation from a pre-formatted transformer pipeline
        The transformer should be ultimately constructed from:
        `make_column_transformer_element_from_pipeline_elements`
        If starting from steps, see `make_pipeline_elements_from_steps`.
        """
        return f"ColumnTransformer([{','.join(column_transformer_elements)}])"
