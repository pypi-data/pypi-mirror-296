#
# Copyright 2024 DataRobot, Inc. and its affiliates.
#
# All rights reserved.
#
# DataRobot, Inc.
#
# This is proprietary source code of DataRobot, Inc. and its
# affiliates.
#
# Released under the terms of DataRobot Tool and Utility Agreement.
from typing import Any, Dict, List
import warnings

import numpy as np
from numpy.typing import NDArray
import pandas as pd
from scipy.sparse import hstack, spmatrix
from sklearn.base import BaseEstimator, TransformerMixin
from sklearn.feature_extraction.text import TfidfVectorizer


class MultiColumnTfidfVectorizer(BaseEstimator, TransformerMixin):  # type: ignore[misc]
    """
    A TF-IDF transformer that supports multiple columns, since sklearn does not.

    Parameters
    ----------
    **tfidf_params : dict
        Parameters to pass to the TfidfVectorizer instances.

    Attributes
    ----------
    vectorizers : dict
        A dictionary storing the fitted TfidfVectorizer for each column.
    feature_names_ : dict
        A dictionary mapping column names to the list of feature names generated
        by the vectorizer for that column.
    """

    def __init__(self, **tfidf_params: Any) -> None:
        self.tfidf_params: Dict[str, Any] = tfidf_params
        self.vectorizers: Dict[str, TfidfVectorizer] = {}
        self.feature_names_: Dict[str, List[str]] = {}

    def fit(
        self, X: pd.DataFrame, y: None = None  # pylint: disable=unused-argument
    ) -> "MultiColumnTfidfVectorizer":
        if not isinstance(X, pd.DataFrame):
            raise ValueError("Input must be a pandas DataFrame")

        successful_fit = False  # Track if at least one column is successfully vectorized

        for column in X.columns:
            vect = TfidfVectorizer(**self.tfidf_params)
            column_data = X[column].fillna("")
            try:
                vect.fit(column_data)
                if vect.vocabulary_:
                    self.vectorizers[column] = vect
                    # Prepend column name to feature names for uniqueness
                    self.feature_names_[column] = [
                        f"{column}__{feat}" for feat in vect.get_feature_names_out()
                    ]
                    successful_fit = True
            except ValueError as e:
                # Raise a warning for columns skipped due to an empty vocabulary
                warnings.warn(
                    f"Column '{column}' was skipped because its vocabulary is empty. Error: {e}",
                    UserWarning,
                )

        if not successful_fit:
            raise ValueError("All columns failed to fit.")

        return self

    def transform(self, X: pd.DataFrame) -> spmatrix:
        outputs: List[spmatrix] = []
        for column, vectorizer in self.vectorizers.items():
            column_data = X[column].fillna("")
            transformed = vectorizer.transform(column_data)
            outputs.append(transformed)

        if not outputs:
            raise ValueError("No columns were transformed.")

        # Combine the transformed columns
        combined_matrix = hstack(outputs)
        return combined_matrix

    def get_feature_names_out(self) -> NDArray[Any]:
        """
        Returns the complete list of feature names generated by the transformer.

        Returns
        -------
        feature_names : array of shape (n_features,)
            Array of feature names.
        """
        # Concatenate all feature names from each vectorizer
        feature_names: List[str] = sum(self.feature_names_.values(), [])
        return np.array(feature_names)
