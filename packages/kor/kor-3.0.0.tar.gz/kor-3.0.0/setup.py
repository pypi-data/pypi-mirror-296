# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['kor', 'kor.documents', 'kor.encoders', 'kor.extraction']

package_data = \
{'': ['*']}

install_requires = \
['langchain-core>=0.3,<0.4', 'pandas>=1.5.3,<3', 'pydantic>=2,<3']

extras_require = \
{':extra == "html"': ['markdownify>=0.11.6,<0.12.0']}

setup_kwargs = {
    'name': 'kor',
    'version': '3.0.0',
    'description': 'Extract information with LLMs from text',
    'long_description': '[![Unit Tests](https://github.com/eyurtsev/kor/actions/workflows/test.yml/badge.svg?branch=main&event=push)](https://github.com/eyurtsev/kor/actions/workflows/test.yml)\n[![Test Docs](https://github.com/eyurtsev/kor/actions/workflows/doc_test.yaml/badge.svg?branch=main&event=push)](https://github.com/eyurtsev/kor/actions/workflows/doc_test.yaml)\n[![Release Notes](https://img.shields.io/github/release/eyurtsev/kor)](https://github.com/eyurtsev/kor/releases)\n[![Downloads](https://static.pepy.tech/badge/kor/month)](https://pepy.tech/project/kor)\n[![Open Issues](https://img.shields.io/github/issues-raw/eyurtsev/kor)](https://github.com/eyurtsev/kor/issues)\n[![](https://dcbadge.vercel.app/api/server/6adMQxSpJS?compact=true&style=flat)](https://discord.com/channels/1038097195422978059/1170024642245832774)\n\n\n# Kor\n\nThis is a half-baked prototype that "helps" you extract structured data from text using LLMs ðŸ§©.\n\nSpecify the schema of what should be extracted and provide some examples.\n\nKor will generate a prompt, send it to the specified LLM and parse out the\noutput.\n\nYou might even get results back.\n\nSo yes â€“ itâ€™s just another wrapper on top of LLMs with its own flavor of abstractions. ðŸ˜¸\n\nSee [documentation](https://eyurtsev.github.io/kor/).\n\nIntegrated with the [LangChain framework ðŸ˜½ðŸ’— ðŸ¦œðŸ”—](https://python.langchain.com/en/latest/index.html).\n\n## Kor vs. LangChain\n\nThere are 3 different approaches for extracting information using LLMs: \n\n1. [prompt based/parsing](https://python.langchain.com/docs/use_cases/extraction/how_to/parse)\n2. [function/tool calling](https://python.langchain.com/docs/use_cases/extraction/quickstart)\n3. JSON mode\n\nPlease see the LangChain [extraction use case docs](https://python.langchain.com/docs/use_cases/extraction/) for an overview.\n\nKor has a pretty good implementation of the **parsing** approach. The approach works with all good-enough LLMs regardless\nof whether they support function/tool calling or JSON modes.\n\nExtraction quality is principally driven by providing good reference examples and good schema documentation.\n\nPlease see guidelines [here](https://python.langchain.com/docs/use_cases/extraction/guidelines) and [here](https://eyurtsev.github.io/kor/guidelines.html).\n\n## Version 1.0.0 Release\n\n* `kor` compatible with both pydantic v2 and v1.\n* pydantic v2 had significant breaking changes w/ respect to v1, `kor` major\n  version bump was used as a precaution.\n\n\nMain things to watch out for:\n\n1. Use a `default` value for any Optional fields if using pydantic v2 for validation.\n\n```python\nclass MusicRequest(BaseModel):\n    song: Optional[List[str]] = Field(\n        default=None,\n        description="The song(s) that the user would like to be played."\n    )\n```\n\n2. Kor schema is typed checked using pydantic. Pydantic v2 is stricter, and may\n   catch issues that were hiding in existing user code that was using the `kor`\n   library.\n\n3. Serialization has not yet been implemented with pydantic v2.\n\n\n## Kor style schema\n\n```python\nfrom langchain.chat_models import ChatOpenAI\nfrom kor import create_extraction_chain, Object, Text\n\nllm = ChatOpenAI(\n    model_name="gpt-3.5-turbo",\n    temperature=0,\n    max_tokens=2000,\n    model_kwargs = {\n        \'frequency_penalty\':0,\n        \'presence_penalty\':0,\n        \'top_p\':1.0\n    }\n)\n\nschema = Object(\n    id="player",\n    description=(\n        "User is controlling a music player to select songs, pause or start them or play"\n        " music by a particular artist."\n    ),\n    attributes=[\n        Text(\n            id="song",\n            description="User wants to play this song",\n            examples=[],\n            many=True,\n        ),\n        Text(\n            id="album",\n            description="User wants to play this album",\n            examples=[],\n            many=True,\n        ),\n        Text(\n            id="artist",\n            description="Music by the given artist",\n            examples=[("Songs by paul simon", "paul simon")],\n            many=True,\n        ),\n        Text(\n            id="action",\n            description="Action to take one of: `play`, `stop`, `next`, `previous`.",\n            examples=[\n                ("Please stop the music", "stop"),\n                ("play something", "play"),\n                ("play a song", "play"),\n                ("next song", "next"),\n            ],\n        ),\n    ],\n    many=False,\n)\n\nchain = create_extraction_chain(llm, schema, encoder_or_encoder_class=\'json\')\nchain.invoke("play songs by paul simon and led zeppelin and the doors")[\'data\']\n```\n\n```python\n{\'player\': {\'artist\': [\'paul simon\', \'led zeppelin\', \'the doors\']}}\n```\n\n## Pydantic style schema\n\n* See documentation here [pydantic](https://eyurtsev.github.io/kor/validation.html).\n\n```python \nclass Action(enum.Enum):\n    play = "play"\n    stop = "stop"\n    previous = "previous"\n    next_ = "next"\n\n\nclass MusicRequest(BaseModel):\n    song: Optional[List[str]] = Field(\n        default=None,\n        description="The song(s) that the user would like to be played."\n    )\n    album: Optional[List[str]] = Field(\n        default=None,\n        description="The album(s) that the user would like to be played."\n    )\n    artist: Optional[List[str]] = Field(\n        default=None,\n        description="The artist(s) whose music the user would like to hear.",\n        examples=[("Songs by paul simon", "paul simon")],\n    )\n    action: Optional[Action] = Field(\n        default=None,\n        description="The action that should be taken; one of `play`, `stop`, `next`, `previous`",\n        examples=[\n            ("Please stop the music", "stop"),\n            ("play something", "play"),\n            ("play a song", "play"),\n            ("next song", "next"),\n        ],\n    )\n    \nschema, validator = from_pydantic(MusicRequest)   \nchain = create_extraction_chain(\n    llm, schema, encoder_or_encoder_class="json", validator=validator\n)\nchain.invoke("stop the music now")["validated_data"]\n```\n\n```python\nMusicRequest(song=None, album=None, artist=None, action=<Action.stop: \'stop\'>)\n```\n\n\n\n## Compatibility\n\n`Kor` is tested against python 3.8, 3.9, 3.10, 3.11.\n\n## Installation\n\n```sh\npip install kor\n```\n\n## ðŸ’¡ Ideas\n\nIdeas of some things that could be done with Kor.\n\n* Extract data from text that matches an extraction schema.\n* Power an AI assistant with skills by precisely understanding a user request.\n* Provide natural language access to an existing API.\n\n## ðŸš§ Prototype\n\nPrototype! So the API is not expected to be stable!\n\n##  âœ¨ What does Kor excel at?  ðŸŒŸ\n\n* Making mistakes! Plenty of them!\n* Slow! It uses large prompts with examples, and works best with the larger slower LLMs.\n* Crashing for long enough pieces of text! Context length window could become\n  limiting when working with large forms or long text inputs.\n\nThe expectation is that as LLMs improve some of these issues will be mitigated.\n\n## Limitations\n\nKor has no limitations. (Just kidding.)\n\nTake a look at the section above and at the compatibility section.\n\n## Got Ideas?\n\nOpen an issue, and let\'s discuss!\n\n## ðŸŽ¶ Why the name?\n\nFast to type and sufficiently unique.\n\n## Contributing\n\nIf you have any ideas or feature requests, please open an issue and share!\n\nSee [CONTRIBUTING.md](https://github.com/eyurtsev/kor/blob/main/CONTRIBUTING.md) for more information.\n\n## Other packages\n\nProbabilistically speaking this package is unlikely to work for your use case.\n\nSo here are some great alternatives:\n\n* [Promptify](https://github.com/promptslab/Promptify)\n* [MiniChain](https://srush.github.io/MiniChain/examples/stats/)\n',
    'author': 'Eugene Yurtsev',
    'author_email': 'eyurtsev@gmail.com',
    'maintainer': 'None',
    'maintainer_email': 'None',
    'url': 'https://www.github.com/eyurtsev/kor',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'extras_require': extras_require,
    'python_requires': '>=3.9,<4.0',
}


setup(**setup_kwargs)
