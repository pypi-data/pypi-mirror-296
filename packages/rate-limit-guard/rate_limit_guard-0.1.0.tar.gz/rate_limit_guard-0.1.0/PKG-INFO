Metadata-Version: 2.1
Name: rate-limit-guard
Version: 0.1.0
Summary: 
Home-page: https://github.com/yourusername/rate-limiter
License: MIT
Keywords: rate limiter,API,decorator
Author: Gorkem Kacar
Author-email: g.kacar@digitastic.app
Requires-Python: >=3.11,<4.0
Classifier: License :: OSI Approved :: MIT License
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Requires-Dist: aiohttp (>=3.10.5,<4.0.0)
Requires-Dist: asyncio (>=3.4.3,<4.0.0)
Requires-Dist: autoflake (>=2.3.1,<3.0.0)
Requires-Dist: bandit (>=1.7.9,<2.0.0)
Requires-Dist: black (>=24.8.0,<25.0.0)
Requires-Dist: isort (>=5.13.2,<6.0.0)
Requires-Dist: mypy (>=1.11.1,<2.0.0)
Requires-Dist: pylint (>=3.2.6,<4.0.0)
Requires-Dist: pytest-asyncio (>=0.23.8,<0.24.0)
Requires-Dist: requests (>=2.32.3,<3.0.0)
Requires-Dist: toml (>=0.10.2,<0.11.0)
Project-URL: Repository, https://github.com/yourusername/rate-limiter
Description-Content-Type: text/markdown

# Rate Limiting Decorator

This Python module provides a `rate_limit_decorator` that allows you to limit the rate at which a function can be called. It supports both synchronous and asynchronous functions, making it versatile for various applications.

## Features

- **Rate Limiting**: Control the maximum number of function calls within a given time interval.
- **Support for Asynchronous and Synchronous Functions**: The decorator works seamlessly with both types of functions.
- **Easy Integration**: Simply apply the decorator to your function, and it will handle rate limiting for you.

## Usage

Hereâ€™s a basic example of how to use the `rate_limit_decorator`:

### Synchronous

```python
from rate_limit_guard import rate_limit_decorator

@rate_limit_decorator(interval=1, max_calls=5)
def my_function():
    print("Function is called")

def main():
    try:
        for _ in range(10):
            my_function()
    except RuntimeError:
        # this will be raised after the rate limit is reached
        pass
```

### Asynchronous

```python
from rate_limit_guard import rate_limit_decorator
import asyncio

@rate_limit_decorator(interval=1, max_calls=5)
async def my_async_function():
    print("Async function is called")
    await asyncio.sleep(0.5)

async def main():
    try:
        for _ in range(10):
            await my_async_function()
    except RuntimeError:
        # this will be raised after the rate limit is reached
        pass
```
