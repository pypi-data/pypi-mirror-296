# generated by datamodel-codegen:
#   filename:  tmp
#   timestamp: 2024-09-02T14:02:23+00:00
import typing
from contextlib import contextmanager
from contextvars import ContextVar

import arrow
import pytz
from pydantic import BaseModel

_requester_context_var = ContextVar("_requester_context_var", default=None)


@contextmanager
def with_requester(requester: typing.Any) -> typing.Iterator[None]:
    token = _requester_context_var.set(requester)
    try:
        yield
    finally:
        _requester_context_var.reset(token)


class CanvasBaseModel(BaseModel):
    """
    Base class for all classes representing objects returned by the API.

    This makes a call to :func:`canvasapi.canvas_object.CanvasObject.set_attributes`
    to dynamically construct this object's attributes with a JSON object.
    """

    model_config = {
        "validate_assignment": True,
        "arbitrary_types_allowed": True,
        "extra": "allow",
    }

    _requester: typing.Any

    # if not typing.TYPE_CHECKING:

    #     def __getattribute__(self, name):
    #         return super().__getattribute__(name)

    def __init__(self, requester=None, attributes=None, /, **kwargs):
        """
        :param requester: The requester to pass HTTP requests through.
        :type requester: :class:`canvasapi.requester.Requester`
        :param attributes: The JSON object to build this object with.
        :type attributes: dict
        """

        if requester and attributes:
            with with_requester(requester):
                super().__init__(**attributes)
            self._requester = requester
        else:
            super().__init__(**kwargs)
            self._requester = _requester_context_var.get()

    def __str__(self) -> str:
        try:
            return repr(self)
        except:  # noqa: E722
            return super().__str__()

    # def __repr__(self):  # pragma: no cover
    #     classname = self.__class__.__name__
    #     attrs = ", ".join(
    #         [
    #             "{}={}".format(attr, val)
    #             for attr, val in self.__dict__.items()
    #             if attr != "attributes"
    #         ]
    #     )  # noqa
    #     return "{}({})".format(classname, attrs)

    def set_attributes(self, attributes):
        """
        Load this object with attributes.

        This method attempts to detect special types based on the field's content
        and will create an additional attribute of that type.

        Consider a JSON response with the following fields::

            {
                "name": "New course name",
                "course_code": "COURSE-001",
                "start_at": "2012-05-05T00:00:00Z",
                "end_at": "2012-08-05T23:59:59Z",
                "sis_course_id": "12345"
            }

        The `start_at` and `end_at` fields match a date in ISO8601 format,
        so two additional datetime attributes are created, `start_at_date`
        and `end_at_date`.

        :param attributes: The JSON object to build this object with.
        :type attributes: dict
        """
        for attribute, value in attributes.items():
            self.__setattr__(attribute, value)

            try:
                naive = arrow.get(str(value)).datetime
                aware = naive.replace(tzinfo=pytz.utc) - naive.utcoffset()  # type: ignore
                self.__setattr__(attribute + "_date", aware)
            except arrow.ParserError:
                pass
            except ValueError:
                pass
