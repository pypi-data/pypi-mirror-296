{"version":3,"file":"Uint8Array_from_string.8TrDoKM4.js","sources":["../../../../../../src/lib/taverns/hexadecimal/Uint8Array_from_string.js"],"sourcesContent":["\n//\n//\timport { Uint8Array_from_string } from '$lib/taverns/hexadecimal/Uint8Array_from_string'\n//\n//\n\n//\n//\tnibble: 4 bits, for example: 0, 1, .., F\n//\tbyte:   8 bits, for example: 00, 01, ... , EF, FF\n//\n\n/*\n\tbyte_to_hexadecimal (\"0A\")\n*/\nfunction byte_to_hexadecimal (byte) {\n    return ('0' + byte.toString(16).toUpperCase()).slice(-2);\n}\n\n\n//\n//\tUint8Array.from ([ 0, 255, 256, -1 ]) -> [ 0, 255, 0, 255 ]\n//\nexport const Uint8Array_from_string = (hexadecimal_string) => {\n\t//\n\t//\t\"00\" = 0\n\t//\t\"FF\" = 255\n\t//\n\t//\tTherefore if \"FF0\", then isn't possible to convert to Uint8Array\n\t//\n\tif (hexadecimal_string.length % 2 !== 0) {\t\t\n\t\tthrow new Error (`The hexadecimal string \"${ hexadecimal_string }\" does not divide by 2.`)\n\t}\n\t\n\tconst byte_integers = []\n\t\n\tlet E = -2;\n\twhile ((E += 2) < hexadecimal_string.length) {\n\t\tconst nibble_1 = Number (\"0x\" + hexadecimal_string [ E + 1 ]);\n\t\tconst nibble_2 = Number (\"0x\" + hexadecimal_string [ E ]) * 16;\n\t\t\n\t\tconst byte_integer = (nibble_1 + nibble_2)\n\t\tif (isNaN (byte_integer)) {\n\t\t\tthrow new Error (`The nibbles at indexes ${ E } & ${ E + 1 } did not convert into a byte integer.`)\n\t\t}\n\t\t\n\t\tbyte_integers.push (byte_integer)\n\t}\n\n\t\n\treturn Uint8Array.from (byte_integers)\n}"],"names":["Uint8Array_from_string","hexadecimal_string","byte_integers","E","nibble_1","nibble_2","byte_integer"],"mappings":"AAsBY,MAACA,EAA0BC,GAAuB,CAO7D,GAAIA,EAAmB,OAAS,IAAM,EACrC,MAAM,IAAI,MAAO,2BAA4BA,CAAkB,yBAA0B,EAG1F,MAAMC,EAAgB,CAAE,EAExB,IAAIC,EAAI,GACR,MAAQA,GAAK,GAAKF,EAAmB,QAAQ,CAC5C,MAAMG,EAAW,EAAQ,KAAOH,EAAqBE,EAAI,CAAC,GACpDE,EAAW,EAAQ,KAAOJ,EAAqBE,CAAC,GAAM,GAEtDG,EAAgBF,EAAWC,EACjC,GAAI,MAAOC,CAAY,EACtB,MAAM,IAAI,MAAO,0BAA2BH,CAAG,MAAMA,EAAI,CAAG,uCAAsC,EAGnGD,EAAc,KAAMI,CAAY,CAChC,CAGD,OAAO,WAAW,KAAMJ,CAAa,CACtC"}