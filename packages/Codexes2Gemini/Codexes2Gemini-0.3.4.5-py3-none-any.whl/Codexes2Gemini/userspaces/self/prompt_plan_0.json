{
  "multiplan": [
    {
      "name": "New Plan_20240817_043519",
      "context": "FIPS 203 \nFederal Information Processing Standards Publication \nModule-Lattice-Based \nKey-Encapsulation Mechanism Standard \nCategory: Computer Security \nSubcategory: Cryptography \nInformation Technology Laboratory \nNational Institute of Standards and Technology \nGaithersburg, MD 20899-8900 \nThis publication is available free of charge from: \nhttps://doi.org/10.6028/NIST.FIPS.203 \nPublished August 13, 2024 \nU.S. Department of Commerce \nGina M. Raimondo, Secretary \nNational Institute of Standards and Technology \nLaurie E. Locascio, NIST Director and Under Secretary of Commerce for Standards and Technology \n\n\nPage 1\n\nForeword \nThe Federal Information Processing Standards (FIPS) Publication Series of the National Institute of Stan\u00ad\ndards and Technology is the official series of publications relating to standards and guidelines developed \nunder 15 U.S.C. 278g-3, and issued by the Secretary of Commerce under 40 U.S.C. 11331. \nComments concerning this Federal Information Processing Standard publication are welcomed and should \nbe submitted using the contact information in the \u201cInquiries and Comments\u201d clause of the announcement \nsection. \nKevin M. Stine, Director \nInformation Technology Laboratory \n\n\nPage 2\n\nFIPS 203 \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \nAbstract \nA key-encapsulation mechanism (KEM) is a set of algorithms that, under certain conditions, can be \nused by two parties to establish a shared secret key over a public channel. A shared secret key that \nis securely established using a KEM can then be used with symmetric-key cryptographic algorithms \nto perform basic tasks in secure communications, such as encryption and authentication. This \nstandard specifies a key-encapsulation mechanism called ML-KEM. The security of ML-KEM is \nrelated to the computational difficulty of the Module Learning with Errors problem. At present, \nML-KEM is believed to be secure, even against adversaries who possess a quantum computer. \nThis standard specifies three parameter sets for ML-KEM. In order of increasing security strength \nand decreasing performance, these are ML-KEM-512, ML-KEM-768, and ML-KEM-1024. \nKeywords: computer security; cryptography; encryption; Federal Information Processing Stan\u00ad\ndards; key-encapsulation mechanism; lattice-based cryptography; post-quantum; public-key \ncryptography. \n\n\nPage 3\n\nFIPS 203 \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \nFederal Information Processing Standards Publication 203 \nPublished: August 13, 2024 \nEffective: August 13, 2024 \nAnnouncing the \nModule-Lattice-Based Key-Encapsulation\nMechanism Standard \nFederal Information Processing Standards (FIPS) publications are developed by the National \nInstitute of Standards and Technology (NIST) under 15 U.S.C. 278g-3 and issued by the Secretary \nof Commerce under 40 U.S.C. 11331. \n1. Name of Standard. Module-Lattice-Based Key-Encapsulation Mechanism Standard (FIPS \n203). \n2. Category of Standard. Computer Security. Subcategory. Cryptography. \n3. Explanation. A cryptographic key (or simply \u201ckey\u201d) is represented in a computer as a string of \nbits. A shared secret key is a cryptographic key that is computed jointly by two parties (e.g., \nAlice and Bob) using a set of algorithms. Under certain conditions, these algorithms ensure \nthat both parties will produce the same key and that this key is secret from adversaries. Such \na shared secret key can then be used with symmetric-key cryptographic algorithms (specified \nin other NIST standards) to perform tasks such as encryption and authentication of digital \ninformation. \nThis standard specifies a set of algorithms for establishing a shared secret key. While there \nare many methods for establishing a shared secret key, the particular method described in \nthis standard is a key-encapsulation mechanism (KEM). \nIn a KEM, the computation of the shared secret key begins with Alice generating a decapsu\u00ad\nlation key and an encapsulation key. Alice keeps the decapsulation key private and makes \nthe encapsulation key available to Bob. Bob then uses Alice\u2019s encapsulation key to generate \none copy of a shared secret key along with an associated ciphertext. Bob then sends the \nciphertext to Alice. Finally, Alice uses the ciphertext from Bob along with Alice\u2019s private \ndecapsulation key to compute another copy of the shared secret key. \nThe security of the particular KEM specified in this standard is related to the computational \ndifficulty of solving certain systems of noisy linear equations, specifically the Module Learn\u00ad\ning With Errors (MLWE) problem. At present, it is believed that this particular method of \nestablishing a shared secret key is secure, even against adversaries who possess a quantum \ncomputer. In the future, additional KEMs may be specified and approved in FIPS publications \nor in NIST Special Publications. \n4. Approving Authority. Secretary of Commerce. \n5. Maintenance Agency. Department of Commerce, National Institute of Standards and Tech\u00ad\nnology, Information Technology Laboratory (ITL). \ni \n\n\nPage 4\n\nFIPS 203 \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \n6. Applicability. Federal Information Processing Standards apply to information systems used or \noperated by federal agencies or by a contractor of an agency or other organization on behalf \nof an agency. They do not apply to national security systems as defined in 44 U.S.C. 3552. \nThis standard, or other FIPS or NIST Special Publications that specify alternative mechanisms, \nshall be used wherever the establishment of a shared secret key (or shared secret from which \nkeying material can be generated) is required for federal applications, including the use of \nsuch a key with symmetric-key cryptographic algorithms, in accordance with applicable Office \nof Management and Budget and agency policies. \nThe adoption and use of this standard are available to private and commercial organizations. \n7. Implementations. A key-encapsulation mechanism may be implemented in software, firmware, \nhardware, or any combination thereof. For every computational procedure that is specified \nin this standard, a conforming implementation may replace the given set of steps with any \nmathematically equivalent set of steps. In other words, different procedures that produce \nthe correct output for every input are permitted. \nNIST will develop a validation program to test implementations for conformance to the \nalgorithms in this standard. Information about validation programs is available at https: \n//csrc.nist.gov/projects/cmvp. Example values will be available at https://csrc.nist.gov/proj \nects/cryptographic-standards-and-guidelines/example-values. \n8. Other Approved Security Functions. Implementations that comply with this standard \nshall employ cryptographic algorithms that have been approved for protecting Federal \nGovernment-sensitive information. Approved cryptographic algorithms and techniques \ninclude those that are either: \n(a) Specified in a Federal Information Processing Standards (FIPS) publication, \n(b) Adopted in a FIPS or NIST recommendation, or \n(c) Specified in the list of approved security functions in SP 800-140C. \n9. Export Control. Certain cryptographic devices and technical data regarding them are subject \nto federal export controls. Exports of cryptographic modules that implement this standard \nand technical data regarding them must comply with all federal laws and regulations and \nbe licensed by the Bureau of Industry and Security of the U.S. Department of Commerce. \nInformation about export regulations is available at https://www.bis.doc.gov. \n10. Patents. NIST has entered into two patent license agreements to facilitate the adoption of \nNIST\u2019s announced selection of the PQC key-encapsulation mechanism CRYSTALS-KYBER. NIST \nand the licensing parties share a desire, in the public interest, the licensed patents be freely \navailable to be practiced by any implementer of the ML-KEM algorithm as published by NIST. \nML-KEM is the name given to the algorithm in this standard derived from CRYSTALS-KYBER. \nFor a summary and extracts from the license, please see https://csrc.nist.gov/csrc/media/P \nrojects/post-quantum-cryptography/documents/selected-algos-2022/nist-pqc-license-sum \nmary-and-excerpts.pdf. Implementation of the algorithm specified in the standard may be \ncovered by U.S. and foreign patents of which NIST is not aware. \nii \n\n\nPage 5\n\nFIPS 203 \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \n11. Implementation Schedule. This standard becomes effective immediately upon final publica\u00ad\ntion. \n12. Specifications. Federal Information Processing Standards (FIPS) 203, Module-Lattice-Based \nKey-Encapsulation Mechanism Standard (affixed). \n13. Qualifications. In applications, the security guarantees of a KEM only hold under certain \nconditions (see SP 800-227 [1]). One such condition is the secrecy of several values, including \nthe randomness used by the two parties, the decapsulation key, and the shared secret key \nitself. Users shall, therefore, guard against the disclosure of these values. \nWhile it is the intent of this standard to specify general requirements for implementing \nML-KEM algorithms, conformance to this standard does not ensure that a particular imple\u00ad\nmentation is secure. It is the responsibility of the implementer to ensure that any module \nthat implements a key establishment capability is designed and built in a secure manner. \nSimilarly, the use of a product containing an implementation that conforms to this standard \ndoes not guarantee the security of the overall system in which the product is used. The re\u00ad\nsponsible authority in each agency or department shall ensure that an overall implementation \nprovides an acceptable level of security. \nNIST will continue to follow developments in the analysis of the ML-KEM algorithm. As with \nits other cryptographic algorithm standards, NIST will formally reevaluate this standard every \nfive years. \nBoth this standard and possible threats that reduce the security provided through the use of \nthis standard will undergo review by NIST as appropriate, taking into account newly available \nanalysis and technology. In addition, the awareness of any breakthrough in technology or \nany mathematical weakness of the algorithm will cause NIST to reevaluate this standard and \nprovide necessary revisions. \n14. Waiver Procedure. The Federal Information Security Management Act (FISMA) does not allow \nfor waivers to Federal Information Processing Standards (FIPS) that are made mandatory by \nthe Secretary of Commerce. \n15. Where to Obtain Copies of the Standard. This publication is available by accessing https: \n//csrc.nist.gov/publications. Other computer security publications are available at the same \nwebsite. \n16. How to Cite This Publication. NIST has assigned NIST FIPS 203 as the publication identifier \nfor this FIPS, per the NIST Technical Series Publication Identifier Syntax. NIST recommends \nthat it be cited as follows: \nNational Institute of Standards and Technology (2024) Module-Lattice-Based Key-\nEncapsulation Mechanism Standard. (Department of Commerce, Washington, \nD.C.), Federal Information Processing Standards Publication (FIPS) NIST FIPS 203. \nhttps://doi.org/10.6028/NIST.FIPS.203 \n17. Inquiries and Comments. Inquiries and comments about this FIPS may be submitted to \nfips-203-comments@nist.gov. \niii \n\n\nPage 6\n\nFIPS 203 \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \nFederal Information Processing Standards Publication 203 \nSpecification for the \nModule-Lattice-Based Key-Encapsulation \nMechanism Standard \nTable of Contents \n1 Introduction \n1 \n1.1 Purpose and Scope \n1 \n1.2 Context \n1 \n2 Terms, Acronyms, and Notation \n2 \n2.1 Terms and Definitions \n2 \n2.2 Acronyms \n4 \n2.3 Mathematical Symbols \n5 \n2.4 Interpreting the Pseudocode \n6 \n2.4.1 \nData Types \n7 \n2.4.2 \nLoop Syntax \n7 \n2.4.3 \nArithmetic With Arrays of Integers \n7 \n2.4.4 \nRepresentations of Algebraic Objects \n8 \n2.4.5 \nArithmetic With Polynomials and NTT Representations \n9 \n2.4.6 \nMatrices and Vectors \n9 \n2.4.7 \nArithmetic With Matrices and Vectors \n10 \n2.4.8 \nApplying Algorithms to Arrays, Examples \n11 \n3 Overview of the ML-KEM Scheme \n12 \n3.1 Key-Encapsulation Mechanisms \n12 \n3.2 The ML-KEM Scheme \n13 \n3.3 Requirements for ML-KEM Implementations \n15 \n4 Auxiliary Algorithms \n18 \n4.1 Cryptographic Functions \n18 \n4.2 General Algorithms \n20 \n4.2.1 \nConversion and Compression Algorithms \n20 \n4.2.2 \nSampling Algorithms \n22 \n4.3 The Number-Theoretic Transform \n24 \niv \n\n\nPage 7\n\nFIPS 203 \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \n4.3.1 \nMultiplication in the NTT Domain \n27 \n5 The K-PKE Component Scheme \n28 \n5.1 K-PKE Key Generation \n28 \n5.2 K-PKE Encryption \n29 \n5.3 K-PKE Decryption \n31 \n6 Main Internal Algorithms \n32 \n6.1 Internal Key Generation \n32 \n6.2 Internal Encapsulation \n32 \n6.3 Internal Decapsulation \n33 \n7 The ML-KEM Key-Encapsulation Mechanism \n35 \n7.1 ML-KEM Key Generation \n35 \n7.2 ML-KEM Encapsulation \n36 \n7.3 ML-KEM Decapsulation \n37 \n8 Parameter Sets \n39 \nReferences \n41 \nAppendix A \u2014 Precomputed Values for the NTT \n44 \nAppendix B \u2014 SampleNTT Loop Bounds \n46 \nAppendix C \u2014 Differences From the CRYSTALS-KYBER Submission \n47 \nC.1 Differences Between CRYSTALS-KYBER and FIPS 203 Initial Public Draft \n47 \nC.2 Changes From FIPS 203 Initial Public Draft \n47 \nv \n\n\nPage 8\n\nFIPS 203 \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \nList of Tables \nTable 1 \nDecapsulation failure rates for ML-KEM \n15 \nTable 2 \nApproved parameter sets for ML-KEM \n39 \nTable 3 \nSizes (in bytes) of keys and ciphertexts of ML-KEM \n39 \nTable 4 \nWhile-loop limits and probabilities of occurrence for SampleNTT \n46 \nList of Figures \nFigure 1 \nA simple view of key establishment using a KEM \n12 \nList of Algorithms \nAlgorithm 1 \nForExample() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \n8 \nAlgorithm 2 \nSHAKE128example(str1,\u2026,str\ud835\udc5a,\ud835\udc4f1,\u2026,\ud835\udc4f\u2113) . . . . . . . . . . . . . \n19 \n. . . . . . . . . . . . . . . . . . . . . . . . . . . . \n20\nAlgorithm 3 \nBitsToBytes(\ud835\udc4f) \nAlgorithm 4 \nBytesToBits(\ud835\udc35) . . . . . . . . . . . . . . . . . . . . . . . . . . . . \n20 \nAlgorithm 5 \nByteEncode\ud835\udc51(\ud835\udc39 ) . . . . . . . . . . . . . . . . . . . . . . . . . . . . \n22 \nAlgorithm 6 \nByteDecode\ud835\udc51(\ud835\udc35) . . . . . . . . . . . . . . . . . . . . . . . . . . . . \n22 \nAlgorithm 7 \nSampleNTT(\ud835\udc35) . . . . . . . . . . . . . . . . . . . . . . . . . . . . \n23 \nAlgorithm 8 \nSamplePolyCBD\ud835\udf02(\ud835\udc35) . . . . . . . . . . . . . . . . . . . . . . . . . \n23 \nAlgorithm 9 \nNTT(\ud835\udc53) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \n26 \nAlgorithm 10 \nNTT\u22121(\ud835\udc53)\n\u0302 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \n26 \nAlgorithm 11 \nMultiplyNTTs(\ud835\udc53,\u0302 \ud835\udc54)\n\u0302 \n. . . . . . . . . . . . . . . . . . . . . . . . . . \n27 \nAlgorithm 12 \nBaseCaseMultiply(\ud835\udc4e0,\ud835\udc4e1,\ud835\udc4f0,\ud835\udc4f1,\ud835\udefe) . . . . . . . . . . . . . . . . . . \n27 \nAlgorithm 13 \nK-PKE.KeyGen(\ud835\udc51) . . . . . . . . . . . . . . . . . . . . . . . . . . . \n29 \nAlgorithm 14 \nK-PKE.Encrypt(ekPKE,\ud835\udc5a,\ud835\udc5f) . . . . . . . . . . . . . . . . . . . . . . . \n30 \nAlgorithm 15 \nK-PKE.Decrypt(dkPKE,\ud835\udc50) . . . . . . . . . . . . . . . . . . . . . . . . \n31 \nAlgorithm 16 \nML-KEM.KeyGen_internal(\ud835\udc51,\ud835\udc67) . . . . . . . . . . . . . . . . . . . . \n32 \nAlgorithm 17 \nML-KEM.Encaps_internal(ek,\ud835\udc5a) . . . . . . . . . . . . . . . . . . . \n33 \nAlgorithm 18 \nML-KEM.Decaps_internal(dk,\ud835\udc50) . . . . . . . . . . . . . . . . . . . . \n34 \nAlgorithm 19 \nML-KEM.KeyGen() . . . . . . . . . . . . . . . . . . . . . . . . . . . \n35 \nAlgorithm 20 \nML-KEM.Encaps(ek) . . . . . . . . . . . . . . . . . . . . . . . . . . \n37 \nAlgorithm 21 \nML-KEM.Decaps(dk,\ud835\udc50) . . . . . . . . . . . . . . . . . . . . . . . . \n38 \nvi \n\n\nPage 9\n\nFIPS 203 \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \n1. Introduction \n1.1 Purpose and Scope \nThis standard specifies the Module-Lattice-Based Key-Encapsulation Mechanism (ML-KEM). A \nkey-encapsulation mechanism (KEM) is a set of algorithms that can be used to establish a shared \nsecret key between two parties communicating over a public channel. A KEM is a particular type \nof key establishment scheme. Other NIST-approved key establishment schemes are specified \nin NIST Special Publication (SP) 800-56A, Recommendation for Pair-Wise Key-Establishment \nSchemes Using Discrete Logarithm-Based Cryptography [2], and SP 800-56B, Recommendation \nfor Pair-Wise Key Establishment Schemes Using Integer Factorization Cryptography [3]. \nThe key establishment schemes specified in SP 800-56A and SP 800-56B are vulnerable to \nattacks that use sufficiently-capable quantum computers. ML-KEM is an approved alternative \nthat is presently believed to be secure, even against adversaries in possession of a large-scale \nfault-tolerant quantum computer. ML-KEM is derived from the round-three version of the \nCRYSTALS-KYBER KEM [4], a submission in the NIST Post-Quantum Cryptography Standardization \nproject. For the differences between ML-KEM and CRYSTALS-KYBER, see Appendix C. \nThis standard specifies the algorithms and parameter sets of the ML-KEM scheme. It aims \nto provide sufficient information to implement ML-KEM in a manner that can pass validation \n(see https://csrc.nist.gov/projects/cryptographic-module-validation-program). For \ngeneral definitions and properties of KEMs, including requirements for the secure use of KEMs \nin applications, see SP 800-227 [1]. \nThis standard specifies three parameter sets for ML-KEM that offer different trade-offs in security \nstrength versus performance. All three parameter sets of ML-KEM are approved to protect \nsensitive, non-classified communication systems of the U.S. Federal Government. \n1.2 Context \nOver the past several years, there has been steady progress toward building quantum computers. \nIf large-scale quantum computers are realized, the security of many commonly used public-key \ncryptosystems will be at risk. This would include key-establishment schemes and digital signature \nschemes whose security depends on the difficulty of solving the integer factorization and discrete \nlogarithm problems (both over finite fields and elliptic curves). As a result, in 2016, NIST initiated \na public Post-Quantum Cryptography (PQC) Standardization process to select quantum-resistant \npublic-key cryptographic algorithms. A total of 82 candidate algorithms were submitted to NIST \nfor consideration. \nAfter three rounds of evaluation and analysis, NIST selected the first four algorithms for stan\u00ad\ndardization. These algorithms are intended to protect sensitive U.S. Government information \nwell into the foreseeable future, including after the advent of cryptographically-relevant quan\u00ad\ntum computers. This standard specifies a variant of the selected algorithm CRYSTALS-KYBER, \na lattice-based key-encapsulation mechanism (KEM) [4]. Throughout this standard, the KEM \nspecified here will be referred to as ML-KEM, as it is based on the Module Learning With Errors \nassumption. \n1 \n\n\nPage 10\n\nFIPS 203 \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \n2. Terms, Acronyms, and Notation \n2.1 Terms and Definitions \napproved \nFIPS-approved and/or NIST-recommended. An algorithm or technique \nthat is either 1) specified in a FIPS or NIST recommendation, 2) adopted \nin a FIPS or NIST recommendation, or 3) specified in a list of NIST-approved \nsecurity functions. \n(KEM) ciphertext \nA bit string that is produced by encapsulation and used as an input to \ndecapsulation. \ncryptographic \nmodule \nThe set of hardware, software, and/or firmware that implements ap-\nproved cryptographic functions (including key generation) that are con-\ntained within the cryptographic boundary of the module. \ndecapsulation \nThe process of applying the Decaps algorithm of a KEM. This algorithm \naccepts a KEM ciphertext and the decapsulation key as input and pro-\nduces a shared secret key as output. \ndecapsulation key \nA cryptographic key produced by a KEM during key generation and used \nduring the decapsulation process. The decapsulation key must be kept \nprivate and must be destroyed after it is no longer needed. (See Section \n3.3.) \ndecryption key \nA cryptographic key that is used with a PKE in order to decrypt cipher-\ntexts into plaintexts. The decryption key must be kept private and must \nbe destroyed after it is no longer needed. \ndestroy \nAn action applied to a key or other piece of secret data. After a piece \nof secret data is destroyed, no information about its value can be re-\ncovered. \nencapsulation \nThe process of applying the Encaps algorithm of a KEM. This algorithm \naccepts the encapsulation key as input, requires private randomness, \nand produces a shared secret key and an associated ciphertext as out-\nput. \nencapsulation key \nA cryptographic key produced by a KEM during key generation and used \nduring the encapsulation process. The encapsulation key can be made \npublic. (See Section 3.3.) \nencryption key \nA cryptographic key that is used with a PKE in order to encrypt plaintexts \ninto ciphertexts. The encryption key can be made public. \nequivalent process \nTwo processes are equivalent if the same output is produced when the \nsame values are input to each process (either as input parameters, as \nvalues made available during the process, or both). \nfresh random value An output that was produced by a random bit generator and has not \nbeen previously used. \n2 \n\n\nPage 11\n\nFIPS 203 \nhash function \ninput checking \nkey \nkey-encapsulation \nmechanism (KEM) \nkey establishment \nkey pair \nlittle-endian \nparty \npseudorandom \npublic channel \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \nA function on bit strings in which the length of the output is fixed. \nApproved hash functions (such as those specified in FIPS 180 [5] and \nFIPS 202 [6]) are designed to satisfy the following properties: \n1. (One-way) It is computationally infeasible to find any input that \nmaps to any new pre-specified output. \n2. (Collision-resistant) It is computationally infeasible to find any two \ndistinct inputs that map to the same output. \nExamination of a potential input to an algorithm for the purpose of \ndetermining whether it conforms to certain requirements. \nA bit string that is used in conjunction with a cryptographic algorithm, \nsuch as the encapsulation and decapsulation keys (of a KEM), the shared \nsecret key (produced by a KEM), and the encryption and decryption \nkeys (of a PKE). (See Section 3.3.) \nA set of three cryptographic algorithms (KeyGen, Encaps, and Decaps) \nthat can be used by two parties to establish a shared secret key over a \npublic channel. \nA procedure that results in secret keying material that is shared among \ndifferent parties. \nA set of two keys with the property that one key can be made public \nwhile the other key must be kept private. In this standard, this could \nrefer to either the (encapsulation key, decapsulation key) key pair of a \nKEM or the (encryption key, decryption key) key pair of a PKE. \nThe property of a byte string having its bytes positioned in order of \nincreasing significance. In particular, the leftmost (first) byte is the \nleast significant, and the rightmost (last) byte is the most significant. \nThe term \u201clittle-endian\u201d may also be applied in the same manner to \nbit strings (e.g., the 8-bit string 11010001 corresponds to the byte \n20 +21 +23 +27 = 139). \nAn individual person, organization, device, or process. In this specifica\u00ad\ntion, there are two parties (e.g., Party A and Party B, or Alice and Bob) \nwho jointly perform the key establishment process using a KEM. \nA process (or data produced by a process) is said to be pseudorandom \nwhen the outcome is deterministic yet also appears random as long \nas the internal action of the process is hidden from observation. For \ncryptographic purposes, \u201ceffectively random\u201d means \u201ccomputationally \nindistinguishable from random within the limits of the intended security \nstrength.\u201d \nA communication channel between two parties. Such a channel can be \nobserved and possibly also corrupted by third parties. \n3 \n\n\nPage 12\n\nFIPS 203 \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \npublic-key \nencryption scheme \n(PKE) \nA set of three cryptographic algorithms (KeyGen, Encrypt, and Decrypt) \nthat can be used by two parties to send secret data over a public channel. \nAlso known as an asymmetric encryption scheme. \nshared secret \nA secret value that has been computed during a key-establishment \nscheme, is known by both participants, and is used as input to a key-\nderivation method to produce keying material. \nshared secret key \nA shared secret that can be used directly as a cryptographic key in \nsymmetric-key cryptography. It does not require additional key deriva-\ntion. The shared secret key must be kept private and must be destroyed \nwhen no longer needed. \nsecurity category \nA number associated with the security strength of a post-quantum \ncryptographic algorithm, as specified by NIST (see [7]). \nsecurity strength \nA number associated with the amount of work (i.e., the number of op-\nerations) that is required to break a cryptographic algorithm or system. \nshall \nUsed to indicate a requirement of this standard. \nshould \nUsed to indicate a strong recommendation but not a requirement of \nthis standard. Ignoring the recommendation could lead to undesirable \nresults. \n2.2 Acronyms \nAES \nAdvanced Encryption Standard \nCBD \nCentered Binomial Distribution \nFIPS \nFederal Information Processing Standard \nKEM \nKey-Encapsulation Mechanism \nLWE \nLearning with Errors \nMLWE \nModule Learning with Errors \nNIST \nNational Institute of Standards and Technology \nNISTIR \nNIST Interagency or Internal Report \nNTT \nNumber-Theoretic Transform \nPKE \nPublic-Key Encryption \nPQC \nPost-Quantum Cryptography \nPRF \nPseudorandom Function \nRBG \nRandom Bit Generator \nSHA \nSecure Hash Algorithm \n4 \n\n\nPage 13\n\nFIPS 203 \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \nSHAKE \nSecure Hash Algorithm KECCAK \nSP \nSpecial Publication \nXOF \nExtendable-Output Function \n2.3 Mathematical Symbols \n\ud835\udc5b \nDenotes the integer 256 throughout this document. \n\ud835\udc5e \nDenotes the prime integer 3329 = 28 \u22c513+1 throughout this document. \n\ud835\udf01 \nDenotes the integer 17, which is a primitive \ud835\udc5b-th root of unity modulo \ud835\udc5e. \n\ud835\udd39 \nThe set {0,1,\u2026,255} of unsigned 8-bit integers (bytes). \n\u211a \nThe set of rational numbers. \n\u2124 \nThe set of integers. \n\u2124\ud835\udc5a \nThe ring of integers modulo \ud835\udc5a (i.e., the set {0,1,\u2026,\ud835\udc5a \u2212 1} equipped with \nthe operations of addition and multiplication modulo \ud835\udc5a.) \n\u2124\ud835\udc5b\n\ud835\udc5a \nThe set of \ud835\udc5b-tuples over \u2124\ud835\udc5a equipped with \u2124\ud835\udc5a-module structure. As a data \ntype, this is the set of length-\ud835\udc5b arrays whose entries are in \u2124\ud835\udc5a. \n\ud835\udc45\ud835\udc5e \nThe ring \u2124\ud835\udc5e[\ud835\udc4b]/(\ud835\udc4b\ud835\udc5b + 1) consisting of polynomials of the form \ud835\udc53 = \ud835\udc530 + \n\ud835\udc531\ud835\udc4b +\u22ef+\ud835\udc53255\ud835\udc4b255 , where \ud835\udc53\ud835\udc57 \u2208 \u2124\ud835\udc5e for all \ud835\udc57. The ring operations are addi\u00ad\ntion and multiplication modulo \ud835\udc4b\ud835\udc5b +1. \n\ud835\udc47\ud835\udc5e \nThe image of \ud835\udc45\ud835\udc5e under the number-theoretic transform. Its elements are \ncalled \u201cNTT representations\u201d of polynomials in \ud835\udc45\ud835\udc5e. (See Section 4.3.) \nD\ud835\udf02(\ud835\udc45\ud835\udc5e) \nA certain distribution of polynomials in \ud835\udc45\ud835\udc5e with small coefficients, from \nwhich noise is sampled. The distribution is parameterized by \ud835\udf02 \u2208 {2,3}. (See \nSection 4.2.2.) \n\ud835\udc46\u2217 \nIf \ud835\udc46 is a set, this denotes the set of finite-length tuples (or arrays) of elements \nfrom the set \ud835\udc46, including the empty tuple (or empty array). \n\ud835\udc46\ud835\udc58 \nIf \ud835\udc46 is a set, this denotes the set of \ud835\udc58-tuples (or length-\ud835\udc58 arrays) of elements \nfrom the set \ud835\udc46. \n\ud835\udc53\ud835\udc57 \nThe coefficient of \ud835\udc4b\ud835\udc57 of a polynomial \ud835\udc53 = \ud835\udc530 +\ud835\udc531\ud835\udc4b+\u22ef+\ud835\udc53255\ud835\udc4b255 \u2208\ud835\udc45\ud835\udc5e. \n\ud835\udc53  \n\u0302\nThe element of \ud835\udc47\ud835\udc5e that is equal to the NTT representation of a polynomial\n\ud835\udc53 \u2208 \ud835\udc45\ud835\udc5e. (See Sections 2.4.4 and 4.3.) \n\ud835\udc2f\ud835\udc47 , \ud835\udc00\ud835\udc47 \nThe transpose of a row or column vector \ud835\udc2f. In general, the transpose of a \nmatrix \ud835\udc00. \n5 \n\n\nPage 14\n\nFIPS 203 \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \n\u2218 \nDenotes linear-algebraic composition with coefficients in \ud835\udc45\ud835\udc5e or \ud835\udc47\ud835\udc5e (e.g., \n\ud835\udc00 \u2218 \ud835\udc2f denotes the vector resulting from applying matrix \ud835\udc00 to vector \ud835\udc2f). (See \nSection 2.4.7.) \nDenotes the operation on coefficient arrays that implements product in the \n\u00d7\ud835\udc47\ud835\udc5e \nring \ud835\udc47\ud835\udc5e. (See Sections 2.4.5 and 4.3.1.) \n\ud835\udc34\u2016\ud835\udc35 \nThe concatenation of two arrays or bit strings \ud835\udc34 and \ud835\udc35. \n\ud835\udc35[\ud835\udc56] \nThe entry at index \ud835\udc56 in the array \ud835\udc35. All arrays have indices that begin at zero. \n\ud835\udc35[\ud835\udc58 \u2236 \ud835\udc5a] \nThe subarray (\ud835\udc35[\ud835\udc58],\ud835\udc35[\ud835\udc58 + 1],\u2026,\ud835\udc35[\ud835\udc5a \u2212 1]) of the array \ud835\udc35. \n|\ud835\udc35| \nIf \ud835\udc35 is a number, this denotes the absolute value of \ud835\udc35. If \ud835\udc35 is an array, this \ndenotes its length. \n\u2308\ud835\udc65\u2309 \nThe ceiling of \ud835\udc65 (i.e., the smallest integer greater than or equal to \ud835\udc65). \n\u230a\ud835\udc65\u230b \nThe floor of \ud835\udc65 (i.e., the largest integer less than or equal to \ud835\udc65). \n\u2308\ud835\udc65\u230b \nThe rounding of \ud835\udc65 to the nearest integer. If \ud835\udc65 = \ud835\udc66+1/2 for some \ud835\udc66 \u2208 \u2124, then \n\u2308\ud835\udc65\u230b = \ud835\udc66+1. \n\u2236= \nDenotes that the left-hand side is defined to be the expression on the right-\nhand side. \n\ud835\udc5f mod \ud835\udc5a \nThe unique integer \ud835\udc5f\u2032 in {0,1,\u2026,\ud835\udc5a \u2212 1} such that \ud835\udc5a divides \ud835\udc5f \u2212 \ud835\udc5f\u2032 . \nBitRev7(\ud835\udc5f) \nBit reversal of a seven-bit integer \ud835\udc5f. Specifically, if \ud835\udc5f = \ud835\udc5f0 +2\ud835\udc5f1 +4\ud835\udc5f2 +\u22ef+ \n64\ud835\udc5f6 with \ud835\udc5f\ud835\udc56 \u2208 {0,1}, then BitRev7(\ud835\udc5f) = \ud835\udc5f6 +2\ud835\udc5f5 +4\ud835\udc5f4 +\u22ef+64\ud835\udc5f0. \n\ud835\udc60 \u2190 \ud835\udc65 \nIn pseudocode, this notation means that the variable \ud835\udc60 is assigned the value \nof the expression \ud835\udc65. \n\ud835\udc60 \u2190\n$\n\u2212 \ud835\udd39\u2113 \nIn pseudocode, this notation means that the variable \ud835\udc60 is assigned the value \nof an array of \u2113 random bytes. The bytes must be freshly generated using \nrandomness from an approved RBG. (See Section 3.3.) \n\u22a5 \nA symbol indicating failure or the lack of output from an algorithm. \n2.4 Interpreting the Pseudocode \nThis section outlines the conventions of the pseudocode used to describe the algorithms in \nthis standard. All algorithms are understood to have access to two global integer constants: \n\ud835\udc5b = 256 and \ud835\udc5e = 3329. There are also five global integer variables: \ud835\udc58, \ud835\udf021, \ud835\udf022, \ud835\udc51\ud835\udc62, and \ud835\udc51\ud835\udc63. All \nother variables are local. The five global variables are set to particular values when a parameter \nset is selected (see Section 8). \nWhen algorithms in this specification invoke other algorithms as subroutines, all arguments (i.e., \ninputs) are passed by value. In other words, a copy of the inputs is created, and the subroutine \nis invoked with the copy. There is no \u201cpassing by reference.\u201d \nPseudocode assignments are performed using the symbol \u201c\u2190.\u201d For example, the statement \n\ud835\udc67 \u2190\ud835\udc66 means that the variable \ud835\udc67 is assigned the value of variable \ud835\udc66. Pseudocode comparisons \n6 \n\n\nPage 15\n\nFIPS 203 \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \nare performed via the symbol \u201c==.\u201d For example, the expression \ud835\udc65 == \ud835\udc64 is a boolean value \nthat is TRUE if and only if the variables \ud835\udc65 and \ud835\udc64 have the same value. \nIn regular text (i.e., outside of the pseudocode), a different convention is applied. There, the \n\u201c=\u201d symbol is used both for assigning values and for comparisons, in keeping with standard \nmathematical notation. When emphasis is needed, assignments will be made with \u201c\u2236=\u201d instead. \nVariables will always have a valid value that is appropriate to their data type, with two exceptions: \n1. The outputs of a random bit generator (RBG) have the byte array data type but are also \nallowed to have the special value NULL. This value indicates that randomness generation \nfailed. This can only occur in ML-KEM.KeyGen and ML-KEM.Encaps. \n2. The outputs of ML-KEM.KeyGen and ML-KEM.Encaps have the byte array data type but \nare also allowed to have the special value \u0000. When ML-KEM.KeyGen or ML-KEM.Encaps \nreturn the value \u0000, this indicates that the algorithm failed due to a failure of randomness \ngeneration. \n2.4.1 Data Types \nFor variables that represent the input or output of an algorithm, the data type (e.g., bit, byte, \narray of bits) will be explicitly described at the start of the algorithm. For most local variables \nin the pseudocode, the data type is easily deduced from context. For all other variables, the \ndata type will be declared in a comment. In a single algorithm, the data type of a variable is \ndetermined the first time that the variable is used and will not be changed. Variable names can \nand will be reused across different algorithms, including with different data types. \nIn addition to standard atomic data types (e.g., bits, bytes) and data structures (e.g., arrays), \nintegers modulo \ud835\udc5a (i.e., elements of \u2124\ud835\udc5a) will also be used as an abstract data type. It is implicit \nthat reduction modulo \ud835\udc5a takes place whenever an assignment is made to a variable in \u2124\ud835\udc5a. For \nexample, for \ud835\udc67 \u2208\u2124\ud835\udc5a and integers \ud835\udc65 and \ud835\udc66, the statement \n\ud835\udc67 \u2190\ud835\udc65+\ud835\udc66 \n(2.1) \nmeans that \ud835\udc67 is assigned the value \ud835\udc65 + \ud835\udc66 mod \ud835\udc5a. The pseudocode is agnostic regarding how \nan integer modulo \ud835\udc5a is represented in actual implementations or how modular reduction is \ncomputed. \n2.4.2 Loop Syntax \nThe pseudocode will make use of both \u201cwhile\u201d and \u201cfor\u201d loops. The \u201cwhile\u201d syntax is self-\nexplanatory. In the case of \u201cfor\u201d loops, the syntax will be in the style of the programming language \nC. Two simple examples are given in Algorithm 1. The standard mathematical expression (e.g., \n\u2211\ud835\udc5b \n\ud835\udc56\u21901(\ud835\udc56 + 3)) will be used for simple summations instead of a \u201cfor\u201d loop. \n2.4.3 Arithmetic With Arrays of Integers \nThis standard makes extensive use of arrays of integers modulo \ud835\udc5a (i.e., elements of \u2124\u2113\n\ud835\udc5a). In a \ntypical case, the relevant values are \ud835\udc5a= \ud835\udc5e = 3329 and \u2113 = \ud835\udc5b = 256. Arithmetic with arrays in \n7 \n\n\nPage 16\n\nFIPS 203 \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \nAlgorithm 1 ForExample() \nPerforms two simple \u201cfor\u201d loops. \n1: for (\ud835\udc56 \u2190 0; \ud835\udc56 < 10; \ud835\udc56++) \n2: \n\ud835\udc34[\ud835\udc56] \u2190 \ud835\udc56 \n\u25b7 \ud835\udc34 is an integer array of length 10 \n3: end for \n\u25b7 \ud835\udc34 now has the value (0,1,2,3,4, 5,6,7, 8,9) \n4:  \n  \n\ud835\udc57\u21900\n5: for (\ud835\udc58 \u2190 256; \ud835\udc58 > 1; \ud835\udc58 \u2190 \ud835\udc58/2) \n6: \n\ud835\udc35[\ud835\udc57] \u2190 \ud835\udc58 \n\u25b7 \ud835\udc35 is an integer array of length 8 \n7: \n\ud835\udc57 \u2190 \ud835\udc57 + 1 \n8: end for \n\u25b7 \ud835\udc35 now has the value (256,128,64,32,16,8,4,2) \n\u2124\u2113 will\nfollows. Let\n\ud835\udc5a \n be done as \n \ud835\udc4e \u2208 \u2124\nand\n\ud835\udc5a \n \ud835\udc4b,\ud835\udc4c \u2208 \u2124\u2113 .\n\ud835\udc5a The statements \n\ud835\udc4d \u2190 \ud835\udc4e\u22c5\ud835\udc4b \n(2.2) \n\ud835\udc4a \u2190 \ud835\udc4b +\ud835\udc4c \n(2.3) \nwill result in two arrays \ud835\udc4d,\ud835\udc4a \u2208 \u2124\u2113\n\ud835\udc5a, with the property that \ud835\udc4d[\ud835\udc56] = \ud835\udc4e\u22c5\ud835\udc4b[\ud835\udc56] and \ud835\udc4a[\ud835\udc56] = \ud835\udc4b[\ud835\udc56]+\ud835\udc4c [\ud835\udc56] \nfor all \ud835\udc56. Multiplication of arrays in \u2124\u2113\n\ud835\udc5a will only be meaningful when \ud835\udc5a = \ud835\udc5e and \u2113 = \ud835\udc5b = 256, in \nwhich case it corresponds to multiplication in a particular ring. This operation will be described \nin (2.8). \n2.4.4 Representations of Algebraic Objects \nAn essential operation in ML-KEM is the number-theoretic transform (NTT), which maps a poly\u00ad\nnomial \ud835\udc53 in a certain ring \ud835\udc45\ud835\udc5e to its \u201cNTT representation\u201d \ud835\udc53 in\n\u0302 an isomorphic ring \ud835\udc47\ud835\udc5e. The rings \ud835\udc45\ud835\udc5e \nand \ud835\udc47\ud835\udc5e and the NTT are discussed in detail in Section 4.3. This standard will represent elements \nof \ud835\udc45\ud835\udc5e and \ud835\udc47\ud835\udc5e in pseudocode using arrays of integers modulo \ud835\udc5e as follows. \nAn element \ud835\udc53 of \ud835\udc45\ud835\udc5e is a polynomial of the form \n\ud835\udc53 = \ud835\udc530 + \ud835\udc531\ud835\udc4b + \u22ef + \ud835\udc53255\ud835\udc4b255 \u2208 \ud835\udc45\ud835\udc5e \n(2.4) \nand will be represented in pseudocode by the array \n(\ud835\udc530,\ud835\udc531,\u2026,\ud835\udc53255) \u2208 \u2124256,\n\ud835\udc5e \n(2.5) \nwhose entries contain the coefficients of \ud835\udc53. Overloading notation, the array in (2.5) will also be \ndenoted by \ud835\udc53. The \ud835\udc56-th entry of the array \ud835\udc53 will thus contain the \ud835\udc56-th coefficient of the polynomial \n\ud835\udc53 (i.e., \ud835\udc53[\ud835\udc56] = \ud835\udc53\ud835\udc56). \nAn element (sometimes called \u201cNTT representation\u201d) \ud835\udc54\u0302of \ud835\udc47\ud835\udc5e is a tuple of 128 polynomials, each \nof degree at most one. Specifically, \n\ud835\udc540,0 +\ud835\udc540,1\ud835\udc4b, \ud835\udc541,0 +\ud835\udc541,1\ud835\udc4b, \u2026, \ud835\udc54127,0 + \n\ud835\udc54= (  \n \n \n \n \n\ud835\udc54127,1\n \n\ud835\udc4b) \u2208\ud835\udc47\ud835\udc5e. \n(2.6)\n\u0302\n\u0302\n\u0302\n\u0302\n\u0302\n\u0302\n\u0302\n8 \n\n\nPage 17\n\nFIPS 203 \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \nSuch an algebraic object will be represented in pseudocode by the array \n(  \n \n \n\ud835\udc541,1,\u2026,  \n \n. \n \n\ud835\udc54127,1) \u2208 \u2124256\n\ud835\udc540,0,\ud835\udc540,1,\ud835\udc541,0, \n\ud835\udc54127,0, \n\ud835\udc5e \n\u0302\n\u0302\n\u0302\n\u0302\n\u0302\n(2.7)\n\u0302\nOverloading notation, the array in (2.7) will also be denoted by \ud835\udc54.\n\u0302 In this case, the mapping \nbetween array entries and coefficients is \u0302 \n\ud835\udc54\ud835\udc56,0\n\u0302 \nand \ud835\udc54[2\ud835\udc56 + 1] = \ud835\udc54\ud835\udc56,1\n\u0302 \nfor \ud835\udc56 \u2208 {0,1,\u2026,127}.\n\ud835\udc54[2\ud835\udc56] = \n\u0302 \n\u0302\nConverting between a polynomial \ud835\udc53 \u2208 \ud835\udc45\ud835\udc5e and its NTT representation \ud835\udc53 \u2208 \ud835\udc47\ud835\udc5e will be done via the \nalgorithms NTT (Algorithm 9) and NTT\u22121 (Algorithm 10). These algorithms act on arrays of \ncoefficients, as described above, and satisfy \ud835\udc53 \u0302= NTT(\ud835\udc53) and \ud835\udc53 = NTT\u22121(\ud835\udc53)\n\u0302 . \n2.4.5 Arithmetic With Polynomials and NTT Representations \nThe algebraic operations of addition and scalar multiplication in \ud835\udc45\ud835\udc5e and \ud835\udc47\ud835\udc5e are done coordinate-\nwise. For example, if \ud835\udc4e \u2208 \u2124\ud835\udc5e and \ud835\udc53 \u2208 \ud835\udc45\ud835\udc5e, the \ud835\udc56-th coefficient of the polynomial \ud835\udc4e\u22c5\ud835\udc53 \u2208 \ud835\udc45\ud835\udc5e is \nequal to \ud835\udc4e \u22c5\ud835\udc53\ud835\udc56 mod \ud835\udc5e. In pseudocode, elements of both \ud835\udc45\ud835\udc5e and \ud835\udc47\ud835\udc5e are represented by coefficient \narrays (i.e., elements of \u2124256\n\ud835\udc5e ). The algebraic operations of addition and scalar multiplication are \nthus performed by addition and scalar multiplication of the corresponding coefficient arrays, \nas in (2.3) and (2.2). For example, the addition of two NTT representations in pseudocode is \nperformed by a statement of the form \u0302 \n\u0302\n\u0302 \n\u0302\n\u0302\n\u0302 \nare coefficient arrays. \n\u210e \u2190 \ud835\udc53 + \ud835\udc54, where \u210e,\ud835\udc53, \ud835\udc54 \u2208 \u2124256\n\ud835\udc5e \nThe algebraic operations of multiplication in \ud835\udc45\ud835\udc5e and \ud835\udc47\ud835\udc5e are treated as follows. For efficiency \nreasons, multiplication in \ud835\udc45\ud835\udc5e will not be used. The algebraic meaning of multiplication in \ud835\udc47\ud835\udc5e is \ndiscussed in Section 4.3.1. In pseudocode, it will be performed by the algorithm MultiplyNTTs \n(Algorithm 11). Specifically, if \u0302\n\u0302 \nare a pair of arrays (each representing the NTT of some\n\ud835\udc53,\ud835\udc54 \u2208 \u2124256\n\ud835\udc5e \npolynomial), then \n\u0302 \n \n\ud835\udc54 \nmeans \n\u210e\u2190 MultiplyNTTs(\n \n\u210e \u2190 \ud835\udc53 \u00d7\ud835\udc47\ud835\udc5e \n \n\ud835\udc53,\ud835\udc54). \n\u0302\n\u0302\n\u0302\n\u0302\n(2.8)\n\u0302\nThe result is an array \u0302 \n\ud835\udc5e .\n\u210e \u2208 \u2124256 \n2.4.6 Matrices and Vectors \nIn addition to arrays of integers modulo \ud835\udc5e, the pseudocode will also make use of arrays whose \nentries are themselves elements of \u2124256\n\ud835\udc5e . For example, an element \ud835\udc2f \u2208 (\u2124256\n\ud835\udc5e )3 will be a length-\nthree array whose entries \ud835\udc2f[0], \ud835\udc2f[1], and \ud835\udc2f[2] are themselves elements of \u2124256\n\ud835\udc5e \n(i.e., arrays). One \ncan think of each of these entries as representing a polynomial in \ud835\udc45\ud835\udc5e so that \ud835\udc2f itself represents \nan element of the module \ud835\udc45\ud835\udc5e\n3 . \nWhen arrays are used to represent matrices and vectors whose entries are elements of \ud835\udc45\ud835\udc5e, they \nwill be denoted with bold letters (e.g., \ud835\udc2f for vectors and \ud835\udc00 for matrices). When arrays are used \nto represent matrices and vectors whose entries are elements of \ud835\udc47\ud835\udc5e, they will be denoted with a \n\u201chat\u201d (e.g., \ud835\udc2f\u0302 and \ud835\udc00\n\u0302 ). Unless an explicit transpose operation is performed, it is understood that \nvectors are column vectors. One can then view vectors as the special case of matrices with only \none column. \nConverting between matrices over \ud835\udc45\ud835\udc5e and matrices over \ud835\udc47\ud835\udc5e will be done coordinate-wise. For \n9 \n\n\nPage 18\n\nFIPS 203 \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \n)\ud835\udc58 \nexample, if \ud835\udc2f \u2208 (\u2124256\n\ud835\udc5e \n, then the statement \n\u0302 \n\ud835\udc2f \u2190 NTT(\ud835\udc2f) \n(2.9)\nwill result in \u0302 \n)\ud835\udc58 such that \ud835\udc2f[\ud835\udc56]\n\u0302 \n= NTT(\ud835\udc2f[\ud835\udc56]) for all \ud835\udc56. This involves running NTT a total \n\ud835\udc2f \u2208 (\u2124256\n\ud835\udc5e \nof \ud835\udc58 times. \n2.4.7 Arithmetic With Matrices and Vectors \nThe following describes how to perform arithmetic with matrices over \ud835\udc45\ud835\udc5e and \ud835\udc47\ud835\udc5e with vectors as \na special case. \nAddition and scalar multiplication are performed coordinate-wise, so the addition of matrices \nover \ud835\udc45\ud835\udc5e and \ud835\udc47\ud835\udc5e is straightforward. In the case of \ud835\udc47\ud835\udc5e, scalar multiplication is done via (2.8). For \nexample, if \ud835\udc53 \u2208 \u2124256 and \u0302\n\u0302 \n\ud835\udc5e \n, then\n\u0302 \n\ud835\udc5e \n\ud835\udc2e, \ud835\udc2f \u2208 (\u2124256)\ud835\udc58 \n\ud835\udc30\u2190\n \n\ud835\udc53\u22c5\n \ud835\udc2e \n\u0302\n\u0302\n\u0302\n(2.10) \n\u0302 \n \n\ud835\udc2f \n\ud835\udc33 \u2190 \ud835\udc2e+ \n\u0302\n\u0302\n(2.11)\nwill result in \u0302 \n\u0302 \n\ud835\udc5e )\ud835\udc58 satisfying \ud835\udc30[\ud835\udc56] =\n\u0302 \n\u0302 \n\u0302 \n\u0302 \n\u0302\n\ud835\udc30,\ud835\udc33 \u2208 (\u2124256 \n\u0302 \n\ud835\udc53 \u00d7\ud835\udc47\ud835\udc5e \ud835\udc2e[\ud835\udc56] and \ud835\udc33[\ud835\udc56] = \ud835\udc2e[\ud835\udc56] + \ud835\udc2f[\ud835\udc56] for all \ud835\udc56. Here, the \nmultiplication and addition of individual entries are performed using the appropriate arithmetic \nfor coefficient arrays of elements of \ud835\udc47\ud835\udc5e (i.e., as in (2.3)). \nIt will also be necessary to multiply matrices with entries in \ud835\udc47\ud835\udc5e, which is done by using standard \nmatrix multiplication with the base-case multiplication (i.e., multiplication of individual entries) \nbeing multiplication in \ud835\udc47\ud835\udc5e. If \ud835\udc00\n\u0302 and \ud835\udc01\n\u0302 are two matrices with entries in \ud835\udc47\ud835\udc5e, their matrix product \nwill be denoted \ud835\udc00 \u2218\n\u0302 \ud835\udc01.\n\u0302 Some example pseudocode statements involving matrix multiplication \nare given in (2.12), (2.13), and (2.14). In these examples, \ud835\udc00\n\u0302 is a \ud835\udc58 \u00d7 \ud835\udc58 matrix, while \ud835\udc2e\u0302 and \ud835\udc2f\u0302 are \nvectors of length \ud835\udc58. All three of these objects are represented in pseudocode by arrays: a \ud835\udc58 \u00d7 \ud835\udc58 \narray for \ud835\udc00\n\u0302 and length-\ud835\udc58 arrays for \ud835\udc2e\u0302 and \ud835\udc2f\u0302. The entries of \ud835\udc00\n\u0302 , \ud835\udc2e\u0302, and \ud835\udc2f\u0302 are elements of \u2124256\n\ud835\udc5e . In \n(2.12) and (2.13), the pseudocode statement on the left produces a new length-\ud835\udc58 vector whose \nentries are specified on the right. In (2.14), the pseudocode statement on the left computes a \n\ud835\udc67 of \u2124256\ndot product. The result is in the base ring (i.e., \ud835\udc47\ud835\udc5e) and is represented by an element \u0302 \n\ud835\udc5e . \n\ud835\udc58\u22121 \n\ud835\udc30\u2190\n \n\ud835\udc00\u2218 \ud835\udc2e \n\ud835\udc30[\ud835\udc56] = \u2211\ud835\udc00[\ud835\udc56,\ud835\udc57]\u00d7\ud835\udc47\ud835\udc5e\ud835\udc2e[\ud835\udc57] \n \n \n\ud835\udc57=0 \n\u0302\n\u0302\n\u0302\n\u0302\n\u0302\n\u0302\n(2.12) \n\ud835\udc58\u22121 \n\ud835\udc32\u2190\n \n\ud835\udc00\u22ba\u2218\ud835\udc2e \n\ud835\udc32[\ud835\udc56] = \u2211\ud835\udc00[\ud835\udc57,\ud835\udc56]\u00d7\ud835\udc47\ud835\udc5e\ud835\udc2e[\ud835\udc57] \n \n \n\ud835\udc57=0 \n\u0302\n\u0302\n\u0302\n\u0302\n\u0302\n\u0302\n(2.13) \n\ud835\udc58\u22121 \n\ud835\udc67\u2190\n \n \n \n\ud835\udc67= \u2211\ud835\udc2e[\ud835\udc57]\u00d7\ud835\udc47\ud835\udc5e\ud835\udc2f[\ud835\udc57] \n\ud835\udc2e\u22ba\u2218\ud835\udc2f \n \n \n\ud835\udc57=0 \n\u0302\n\u0302\n\u0302\n\u0302\n(2.14)\n\u0302\n\u0302\nThe multiplication \u00d7\ud835\udc47\ud835\udc5e of individual entries above is performed using MultiplyNTTs, as described \nin (2.8). \n10 \n\n\nPage 19\n\nFIPS 203 \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \n2.4.8 Applying Algorithms to Arrays, Examples \nIn the previous examples, arithmetic over \u2124\ud835\udc5a was extended to arithmetic with arrays over \u2124\ud835\udc5a \nand then further extended to arithmetic with matrices whose entries are themselves arrays over \n\u2124\ud835\udc5a. Similarly, algorithms defined with a given data type as input will be applied to arrays and \nmatrices over that data type. When the pseudocode invokes such an algorithm on an array or \nmatrix input, it is implied that the algorithm is invoked repeatedly and applied to each entry of \nthe input. \nFor example, consider the function Compress\ud835\udc51 \u2236\u2124\ud835\udc5e \u2192\u21242\ud835\udc51 defined in Section 4. It can be invoked \non an array input \ud835\udc39 \u2208 \u2124256\n\ud835\udc5e \nwith the statement \n\ud835\udc3e \u2190 Compress\ud835\udc51(\ud835\udc39 ). \n(2.15) \nThe result will be an array \ud835\udc3e \u2208 \u2124256 such that \ud835\udc3e[\ud835\udc56] = Compress\ud835\udc51(\ud835\udc39 [\ud835\udc56]) for every \ud835\udc56 \u2208 {0,1,\u2026,255}. \nThe computation (2.15) involves \n2\ud835\udc51 \nrunning the Compress algorithm 256 times. \nFor a second example, consider the algorithm NTT defined in Section 4.3. It takes an array \ud835\udc53 \u2208 \n\u2124256 \n\u0302\n(representing an element of \ud835\udc45\ud835\udc5e) as input and outputs another array \ud835\udc53 \u2208 \u2124256 (representing \n\ud835\udc5e \n\ud835\udc5e \nan element of \ud835\udc47\ud835\udc5e). If the NTT algorithm is invoked on a vector \ud835\udc2c \u2208 (\u2124256\n\ud835\udc5e )\ud835\udc58 (representing an \nelement of \ud835\udc45\ud835\udc5e\n\ud835\udc58) with the pseudocode statement \n\u0302 \n\ud835\udc2c \u2190 NTT(\ud835\udc2c), \n(2.16)\nthe result is a vector \u0302 \n\ud835\udc5e )\ud835\udc58 such that \ud835\udc2c[\ud835\udc56] = NTT(\ud835\udc2c[\ud835\udc56]) for all \ud835\udc56 \u2208 {0,1,\u2026,\ud835\udc58\u22121}. The vector \n\ud835\udc2c\u2208(\u2124256 \n\u0302 \n\ud835\udc2c\u0302 represents an element of \ud835\udc47\ud835\udc5e\n\ud835\udc58 . The computation (2.16) involves running the NTT algorithm \ud835\udc58 \ntimes. \nFor a third example, consider line 2 of K-PKE.Encrypt in Section 5.2: \n\u0302\n\ud835\udc2d \u2190 ByteDecode12(ekPKE[0 \u2236 384\ud835\udc58]). \n(2.17) \nByteDecode12 is defined to receive a byte array of length 32 \u22c512 = 384 as input and produce \nan integer array in \u2124256\n\ud835\udc5e \nas output. The computation (2.17) is run on the first 384\ud835\udc58 bytes of \nbyte array ekPKE and results in \u0302 \n\ud835\udc5e )\ud835\udc58 \n\ud835\udc2d \u2208 (\u2124256 . ByteDecode12 will thus be applied \ud835\udc58 times, once for \n\u0302\neach subarray ekPKE[384 \u22c5 \ud835\udc57,384 \u22c5 (\ud835\udc57 + 1)], and will result in an integer array \ud835\udc2d[\ud835\udc57] \u2208 \u2124256\n\ud835\udc5e \nsuch that \n\u0302 \n[384\u22c5\ud835\udc57,384\u22c5(\ud835\udc57+1)]) for each \ud835\udc57 from 0 to \ud835\udc58 \u2212 1.\n\ud835\udc2d[\ud835\udc57] = ByteDecode12(ekPKE \n11 \n\n\nPage 20\n\nFIPS 203 \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \n3. Overview of the ML-KEM Scheme \nThis section gives a high-level overview of the ML-KEM scheme. \n3.1 Key-Encapsulation Mechanisms \nThe following is a high-level overview of key-encapsulation mechanisms (KEMs). For details, see \nSP 800-227 [1]. \nA KEM is a cryptographic scheme that, under certain conditions, can be used to establish a shared \nsecret key between two communicating parties. This shared secret key can then be used for \nsymmetric-key cryptography. \nA KEM consists of three algorithms and a collection of parameter sets. The three algorithms are: \n1. A probabilistic key generation algorithm denoted by KeyGen \n2. A probabilistic \u201dencapsulation\u201d algorithm denoted by Encaps \n3. A deterministic \u201ddecapsulation\u201d algorithm denoted by Decaps \nThe collection of parameter sets is used to select a trade-off between security and efficiency. \nEach parameter set in the collection is a list of specific (typically numerical) values, one for each \nparameter required by the three algorithms. \nFigure 1. A simple view of key establishment using a KEM \n12 \nAlice \nBob \ndecapsulation key\nDecaps\nciphertext\nAlice\u2019s copy of the \nshared secret key\nEncaps\nBob\u2019s copy of the \nshared secret key\nencapsulation key\nKeyGen\n\ud835\udc3e\u2032 \n\ud835\udc3e \n\n\nPage 21\n\nFIPS 203 \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \nIn the typical application, a KEM is used to establish a shared secret key between two parties \n(here referred to as Alice and Bob) as described in Figure 1. Alice begins by running KeyGen in \norder to generate a (public) encapsulation key and a (private) decapsulation key. Upon obtaining \nAlice\u2019s encapsulation key, Bob runs the Encaps algorithm, which produces Bob\u2019s copy \ud835\udc3e of the \nshared secret key along with an associated ciphertext. Bob sends the ciphertext to Alice, and \nAlice completes the process by running the Decaps algorithm using her decapsulation key and \nthe ciphertext. This final step produces Alice\u2019s copy \ud835\udc3e\u2032 of the shared secret key. \nAfter completing this process, Alice and Bob would like to conclude that their outputs satisfy \n\ud835\udc3e\u2032 = \ud835\udc3e and that this value is a secure, random, shared secret key. However, these properties \nonly hold if certain important conditions are satisfied, as discussed in SP 800-227 [1]. \n3.2 The ML-KEM Scheme \nML-KEM is a key-encapsulation mechanism based on CRYSTALS-KYBER [4], a scheme that was \ninitially described in [8]. The following is a brief and informal description of the computational \nassumption underlying ML-KEM and how the ML-KEM scheme is constructed. \nThe computational assumption. The security of ML-KEM is based on the presumed hardness \nof the so-called Module Learning with Errors (MLWE) problem [9], which is a generalization of \nthe Learning With Errors (LWE) problem introduced by Regev in 2005 [10]. The hardness of the \nMLWE problem is itself based on the presumed hardness of certain computational problems in \nmodule lattices [9]. This motivates the name of the scheme ML-KEM. \nIn the LWE problem, the input is a set of random \u201cnoisy\u201d linear equations in some secret \nvariables \ud835\udc65 \u2208 \u2124\ud835\udc5b\n\ud835\udc5e , and the task is to recover \ud835\udc65. The noise in the equations is such that standard \nalgorithms (e.g., Gaussian elimination) are intractable. The LWE problem naturally lends itself to \ncryptographic applications. For example, if \ud835\udc65 is interpreted as a secret key, then one can encrypt \na one-bit plaintext value by sampling either an approximately correct linear equation (if the \nplaintext is zero) or a far-from-correct linear equation (if the plaintext is one). Plausibly, only a \nparty in possession of \ud835\udc65 can distinguish these two cases. Encryption can then be delegated to \nanother party by publishing a large collection of noisy linear equations, which can be combined \nappropriately by the encrypting party. The result is an asymmetric encryption scheme. \nThe MLWE problem is similar to the LWE problem. An important difference is that, in MLWE, \u2124\ud835\udc5b\n\ud835\udc5e \nis replaced by a certain module \ud835\udc45\ud835\udc5e\n\ud835\udc58 , which is constructed by taking the \ud835\udc58-fold Cartesian product \nof a certain polynomial ring \ud835\udc45\ud835\udc5e. In particular, the secret in the MLWE problem is an element \ud835\udc31 of \nthe module \ud835\udc45\ud835\udc5e\n\ud835\udc58 . The ring \ud835\udc45\ud835\udc5e is discussed in detail in Section 4.3. \nThe ML-KEM construction. At a high level, the construction of the scheme ML-KEM proceeds in \ntwo steps. First, the ideas discussed previously are used to construct a public-key encryption (PKE) \nscheme from the MLWE problem. Second, this PKE scheme is converted into a key-encapsulation \nmechanism using the so-called Fujisaki-Okamoto (FO) transform [11, 12]. Due to certain prop\u00ad\nerties of the FO transform, the resulting KEM provides security in a significantly more general \nattack model than the PKE scheme. As a result, ML-KEM is believed to satisfy so-called IND-CCA2 \nsecurity [1, 4, 13, 14]. \n13 \n\n\nPage 22\n\nFIPS 203 \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \nThe specification of the ML-KEM algorithms in this standard will follow the same pattern. Specif\u00ad\nically, this standard will first describe a public-key encryption scheme called K-PKE (in Section 5) \nand then use the algorithms of K-PKE as subroutines when describing the algorithms of ML-KEM \n(in Sections 6 and 7). The cryptographic transformation from K-PKE to ML-KEM is crucial for \nachieving IND-CCA2 security. The scheme K-PKE is not IND-CCA2-secure and shall not be used as \na stand-alone scheme (see Section 3.3). \nA notable feature of ML-KEM is the use of the number-theoretic transform (NTT). The NTT \n\u0302\nconverts a polynomial \ud835\udc53 \u2208 \ud835\udc45\ud835\udc5e to an alternative representation as a vector \ud835\udc53 of linear polynomials. \nWorking with NTT representations enables significantly faster multiplication of polynomials. \nOther operations (e.g., addition, rounding, and sampling) can be done in either representation. \nML-KEM satisfies the essential KEM property of correctness. This means that in the absence \nof corruption or interference, the process in Figure 1 will result in \ud835\udc3e\u2032 = \ud835\udc3e with overwhelming \nprobability. ML-KEM also comes with a proof of asymptotic theoretical security in a certain \nheuristic model [4]. Each of the parameter sets of ML-KEM comes with an associated security \nstrength that was estimated based on current cryptanalysis (see Section 8 for details). \nParameter sets and algorithms. Recall that a KEM consists of algorithms KeyGen, Encaps, and \nDecaps, along with a collection of parameter sets. In the case of ML-KEM, the three aforemen\u00ad\ntioned algorithms are: \n1. ML-KEM.KeyGen (Algorithm 19) \n2. ML-KEM.Encaps (Algorithm 20) \n3. ML-KEM.Decaps (Algorithm 21) \nThese algorithms are described and discussed in detail in Section 7. \nML-KEM comes equipped with three parameter sets: \n\u2022 ML-KEM-512 (security category 1) \n\u2022 ML-KEM-768 (security category 3) \n\u2022 ML-KEM-1024 (security category 5) \nThese parameter sets are described and discussed in detail in Section 8. The security categories \n1-5 are defined in SP 800-57, Part 1 [7]. Each parameter set assigns a particular numerical value \nto five integer variables: \ud835\udc58, \ud835\udf021, \ud835\udf022, \ud835\udc51\ud835\udc62, and \ud835\udc51\ud835\udc63. The values of these variables in each parameter \nset are given in Table 2 of Section 8. In addition to these five variable parameters, there are also \ntwo constants: \ud835\udc5b = 256 and \ud835\udc5e = 3329. \nDecapsulation failures. Provided that all inputs are well-formed and randomness generation is \nsuccessful, the key establishment procedure of ML-KEM will never explicitly fail, meaning that \nboth ML-KEM.Encaps and ML-KEM.Decaps will each output a 256-bit value. Moreover, if no \ncorruption or interference is present, the two 256-bit values produced by ML-KEM.Encaps and \nML-KEM.Decaps will be equal with overwhelming probability (i.e., \ud835\udc3e\u2032 will equal \ud835\udc3e in the process \ndescribed in Figure 1). The event that \ud835\udc3e\u2032 \u2260\ud835\udc3e under these conditions is called a decapsulation \n14 \n\n\nPage 23\n\nFIPS 203 \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \nfailure. Formally, the decapsulation failure probability is defined to be the probability (conditioned \non no RGB failures) that the process \n1. (ek,dk) \u2190 ML-KEM.KeyGen() \n(3.1) \n2. (\ud835\udc50,\ud835\udc3e) \u2190 ML-KEM.Encaps(ek) \n(3.2) \n3. \ud835\udc3e\u2032 \u2190 ML-KEM.\n(\n,\ud835\udc50) \nDecaps dk\n(3.3) \nresults in \ud835\udc3e\u2032 \u2260\ud835\udc3e. The probability is taken over uniformly random seeds \ud835\udc51,\ud835\udc67 (sampled in \nML-KEM.KeyGen) and \ud835\udc5a (sampled in ML-KEM.Encaps) and under the heuristic assumption that \nhash functions and XOFs behave like uniformly random functions. The decapsulation failure rates \nfor ML-KEM are listed in Table 1. For details, see Theorem 1 in [8] and the scripts in [15]. \nTable 1. Decapsulation failure rates for ML-KEM \nParameter set Decapsulation failure rate \nML-KEM-512 \n2\u2212138.8 \nML-KEM-768 \n2\u2212164.8 \nML-KEM-1024 \n2\u2212174.8 \nTerminology for keys. A KEM involves three different types of keys: encapsulation keys, de\u00ad\ncapsulation keys, and shared secret keys. ML-KEM is built on top of the component public-key \nencryption scheme K-PKE, which has two additional key types: encryption keys and decryption \nkeys. In the literature, encapsulation keys and encryption keys are sometimes referred to as \n\u201cpublic keys,\u201d while decapsulation keys and decryption keys are sometimes referred to as \u201cpri\u00ad\nvate keys.\u201d In order to reduce confusion, this standard will not use the terms \u201cpublic key\u201d or \n\u201cprivate key.\u201d Instead, keys will be referred to only using the more specific terms, i.e., one of \n\u201cencapsulation key\u201d, \u201cdecapsulation key\u201d, \u201cencryption key\u201d, \u201cdecryption key\u201d, and \u201cshared secret \nkey\u201d. \n3.3 Requirements for ML-KEM Implementations \nThis section describes several requirements for cryptographic modules that implement ML-KEM. \nImplementation requirements specific to particular algorithms will be described in later sections. \nAdditional requirements, including requirements for using ML-KEM in specific applications, \nare given in SP 800-227 [1]. While conforming implementations must adhere to all of these \nrequirements, adherence does not guarantee that the result will be secure (see Point 13 in the \nannouncement). \nK-PKE is only a component. The public-key encryption scheme K-PKE described in Section 5 shall \nnot be used as a stand-alone cryptographic scheme. Instead, the algorithms that comprise K-PKE \nmay only be used as subroutines in the algorithms of ML-KEM. In particular, the algorithms \nK-PKE.KeyGen (Algorithm 13), K-PKE.Encrypt (Algorithm 14), and K-PKE.Decrypt (Algorithm 15) \nare not approved for use as a public-key encryption scheme. \n15 \n\n\nPage 24\n\nFIPS 203 \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \nControlled access to internal functions. The key-encapsulation mechanism ML-KEM makes use \nof internal, \u201cderandomized\u201d functions ML-KEM.KeyGen_internal, ML-KEM.Encaps_internal, and \nML-KEM.Decaps_internal, specified in Section 6. The interfaces for these functions should not \nbe made available to applications other than for testing purposes. In particular, the sampling of \nrandom values required for key generation (as specified in ML-KEM.KeyGen) and encapsulation \n(as specified in ML-KEM.Encaps) shall be performed by the cryptographic module. \nEquivalent implementations. For every algorithm that is specified in this standard, a conforming \nimplementation may replace the given set of steps with any mathematically equivalent set of \nsteps. In other words, the specified algorithm may be replaced with a different procedure that \nproduces the correct output for every input (where \u201cinput\u201d includes the specified input as well \nas all parameter values and all randomness). \nApproved usage of the shared secret key. If randomness generation is successful, the values \n\ud835\udc3e and \ud835\udc3e\u2032 returned by ML-KEM.Encaps and ML-KEM.Decaps, respectively, are always 256-bit \nvalues. Under appropriate conditions (see Sections 3.1 and 3.2, and SP 800-227 [1]), these values \nmatch (i.e., \ud835\udc3e\u2032 = \ud835\udc3e) and can be used directly as a shared secret key for symmetric cryptography. \nIf further key derivation is needed, the final symmetric keys shall be derived from this 256-bit \nshared secret key in an approved manner, as specified in SP 800-108 and SP 800-56C [16, 17]. \nAs discussed in Section 3.2, ML-KEM is an IND-CCA2-secure KEM. However, a combined KEM \nthat includes ML-KEM as a component might not meet IND-CCA2 security. Implementers should \nassess the security of any procedure in which the key derivation methods of SP 800-56C are \napplied to ML-KEM in combination with another key establishment procedure. More guidance \nregarding combined KEMs is given in SP 800-227 [1]. \nRandomness generation. Two algorithms in this standard require the generation of randomness \nas an internal step: ML-KEM.KeyGen and ML-KEM.Encaps. In pseudocode, this randomness \n$ \ngeneration is denoted by a statement of the form \ud835\udc5a \u2190\n\u2212 \ud835\udd3932 . A fresh string of random bytes \nmust be generated for every such invocation. These random bytes shall be generated using an \napproved RBG, as prescribed in SP 800-90A, SP 800-90B, and SP 800-90C [18, 19, 20]. Moreover, \nthis RBG shall have a security strength of at least 128 bits for ML-KEM-512, at least 192 bits for \nML-KEM-768, and at least 256 bits for ML-KEM-1024. \nInput checking. The algorithms ML-KEM.Encaps and ML-KEM.Decaps require input checking. \nImplementers shall ensure that ML-KEM.Encaps and ML-KEM.Decaps are only executed on \ninputs that have been checked, as described in Section 7. \nDestruction of intermediate values. Data used in intermediate computation steps of KEM \nalgorithms could be used by an adversary to compromise security. Therefore, implementers \nshall ensure that intermediate data is destroyed as soon as it is no longer needed. In particular, \nfor ML-KEM.KeyGen, ML-KEM.Encaps, and ML-KEM.Decaps, only the designated output can be \nretained in memory after the algorithm terminates. All other data shall be destroyed prior to \n16 \n\n\nPage 25\n\nFIPS 203 \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \nthe algorithm terminating. \nThere are two exceptions to this rule: \n1. The seed (\ud835\udc51,\ud835\udc67) generated in steps 1 and 2 of ML-KEM.KeyGen can be stored for later \nexpansion using ML-KEM.KeyGen_internal. As this seed can be used to compute the \ndecapsulation key, it is sensitive data and shall be treated with the same safeguards as a \ndecapsulation key (see SP 800-227 [1]). \n2. The matrix \ud835\udc00\n\u0302 generated in steps 3-7 of K-PKE.KeyGen (as a subroutine of ML-KEM.KeyGen) \ncan be stored so that it need not be recomputed in later operations (e.g., ML-KEM.Decaps). \nThe same matrix \ud835\udc00\n\u0302 is also generated in steps 4-8 of K-PKE.Encrypt (as a subroutine of \nML-KEM.Encaps or ML-KEM.Decaps); it can also then be stored. In either case, the matrix \n\ud835\udc00\n\u0302 is data that is easily computed from the public encapsulation key and thus does not \nrequire any special protections. \nNo floating-point arithmetic. Implementations of ML-KEM shall not use floating-point arithmetic, \nas rounding errors in floating-point operations may lead to incorrect results in some cases. In \nall pseudocode in this standard in which division is performed (e.g., \ud835\udc65/\ud835\udc66) and \ud835\udc66 may not divide \n\ud835\udc65, either \u230a\ud835\udc65/\ud835\udc66\u230b, \u2308\ud835\udc65/\ud835\udc66\u2309, or \u2308\ud835\udc65/\ud835\udc66\u230b is used. All of these can be computed without floating-point \narithmetic, as ordinary integer division \ud835\udc65/\ud835\udc66 computes \u230a\ud835\udc65/\ud835\udc66\u230b, and \u2308\ud835\udc65/\ud835\udc66\u2309 = \u230a(\ud835\udc65 + \ud835\udc66 \u2212 1)/\ud835\udc66\u230b for \nnon-negative integers \ud835\udc65 and positive integers \ud835\udc66. \n17 \n\n\nPage 26\n\nFIPS 203 \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \n4. Auxiliary Algorithms \n4.1 Cryptographic Functions \nThe algorithms specified in this publication require the use of several cryptographic functions. \nEach function shall be instantiated by means of an approved hash function or an approved \neXtendable-Output Function (XOF), as prescribed below. The relevant hash functions and XOFs \nare described in detail in FIPS 202 [6]. They will be used as follows. \nSHA3-256 and SHA3-512 are hash functions with one variable-length input and one fixed-length \noutput. In this standard, invocations of these functions on an input \ud835\udc40 will be denoted by \nSHA3-256(\ud835\udc40) and SHA3-512(\ud835\udc40), respectively. The inputs and outputs for both SHA3-256 and \nSHA3-512 are always byte arrays. \nSHAKE128 and SHAKE256 are XOFs with one variable-length input and one variable-length output. \nThis standard will adhere to the following conventions [6]: \n\u2022 The inputs and outputs for both SHAKE128 and SHAKE256 are always byte arrays. \n\u2022 When invoking SHAKE128 or SHAKE256, desired output length is always specified in bits. \nFor example, the expression \n\ud835\udc5f \u2236= SHAKE128(\ud835\udc40,8 \u22c5 64) \n(4.1) \nimplies that \ud835\udc40 is an array of bytes and that \ud835\udc5f is an array of 64 bytes. \nThe aforementioned functions play several different roles in the algorithms specified in this \nstandard and will only be invoked using the wrapper functions defined below. Importantly, these \nwrappers will avoid any potential \u201cbyte array\u201d versus \u201cbit-length\u201d confusion by only working with \nbytes and byte array lengths. \nPseudorandom function (PRF). The function PRF takes a parameter \ud835\udf02 \u2208 {2,3}, one 32-byte \ninput, and one 1-byte input. It produces one (64 \u22c5 \ud835\udf02)-byte output. It will be denoted by \nPRF \u2236 {2,3}\u00d7\ud835\udd3932 \u00d7\ud835\udd39 \u2192 \ud835\udd3964\ud835\udf02, \n(4.2) \nand it shall be instantiated as \nPRF\ud835\udf02(\ud835\udc60,\ud835\udc4f) \u2236= SHAKE256(\ud835\udc60\u2016\ud835\udc4f,8 \u22c5 64 \u22c5 \ud835\udf02), \n(4.3) \nwhere \ud835\udf02 \u2208 {2,3}, \ud835\udc60 \u2208 \ud835\udd3932 , and \ud835\udc4f \u2208 \ud835\udd39. Note that \ud835\udf02 is only used to specify the desired output \nlength and not to perform domain separation. \nHash functions. The specification will also make use of three hash functions H, J and G, which \nare defined as follows. \nThe functions H and J each take one variable-length input and produce one 32-byte output. They \nwill be denoted by H \u2236 \ud835\udd39\u2217 \u2192 \ud835\udd3932 and J \u2236 \ud835\udd39\u2217 \u2192 \ud835\udd3932 , respectively, and shall be instantiated as \nH(\ud835\udc60) \u2236= SHA3-256(\ud835\udc60) \nand \nJ(\ud835\udc60) \u2236= SHAKE256(\ud835\udc60,8 \u22c5 32) \n(4.4) \n18 \n\n\nPage 27\n\nFIPS 203 \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \nwhere \ud835\udc60 \u2208 \ud835\udd39\u2217 . \nThe function G takes one variable-length input and produces two 32-byte outputs. It will be \ndenoted by G \u2236 \ud835\udd39\u2217 \u2192 \ud835\udd3932 \u00d7 \ud835\udd3932 . The two outputs of G will be denoted by (\ud835\udc4e,\ud835\udc4f) \u2190 G(\ud835\udc50), where \n\ud835\udc4e,\ud835\udc4f \u2208 \ud835\udd3932 , \ud835\udc50 \u2208\ud835\udd39\u2217 , and G(\ud835\udc50) = \ud835\udc4e\u2016\ud835\udc4f. The function G shall be instantiated as \nG(\ud835\udc50) \u2236= SHA3-512(\ud835\udc50). \n(4.5) \neXtendable-Output Function (XOF). This standard uses a XOF wrapper defined in terms of the \nincremental API for SHAKE128 in SP 800-185 [21]. This SHAKE128 API consists of three functions: \n\u2022 ctx \u2190 SHAKE128.Init() \nInitializes a XOF \u201ccontext\u201d ctx. \n\u2022 ctx \u2190 SHAKE128.Absorb(ctx,str) \nInjects data to be used in the \u201cabsorbing\u201d phase of SHAKE128 and updates the context \naccordingly. \n\u2022 (ctx,\ud835\udc35) \u2190 SHAKE128.Squeeze(ctx,8 \u22c5 \ud835\udc67) \nExtracts \ud835\udc67 output bytes produced during the \u201csqueezing\u201d phase of SHAKE128 and updates \nthe context accordingly. \nWhile the above functions are constructed using the Keccak-\ud835\udc53 permutation rather than the XOF \nSHAKE128 directly, they are defined so that a single SHAKE128 call of the form \noutput \u2190 SHAKE128(str1\u2016\u2026\u2016str\ud835\udc5a,8\ud835\udc4f1 +\u2026+8\ud835\udc4f\u2113) \n(4.6) \nis equivalent to performing Algorithm 2. This equivalence holds whether or not |str\ud835\udc56| and \ud835\udc4f\ud835\udc57 are \nmultiples of the SHAKE128 block length. \nAlgorithm 2 SHAKE128example(str1,\u2026,str\ud835\udc5a,\ud835\udc4f1,\u2026,\ud835\udc4f\u2113) \nPerforms a sequence of absorbing operations followed by a sequence of squeezing operations. \nInput: byte arrays str1,\u2026,str\ud835\udc5a. \nInput: positive integers \ud835\udc4f1,\u2026,\ud835\udc4f\u2113. \nOutput: a byte array of length \u2211\u2113 \n\ud835\udc57=1 \ud835\udc4f\ud835\udc57. \n1: ctx \u2190 SHAKE128.Init() \n\u25b7 initialize context \n2: for (\ud835\udc56 \u2190 1; \ud835\udc56 \u2264 \ud835\udc5a; \ud835\udc56++) \n3: \nctx \u2190 SHAKE128.Absorb(ctx,str\ud835\udc56) \n\u25b7 absorb byte array str\ud835\udc56 \n4: end for \n5: for (\ud835\udc57 \u21901; \ud835\udc57 \u2264\u2113; \ud835\udc57++) \n6: \n(ctx,out\ud835\udc57) \u2190 SHAKE128.Squeeze(ctx,8\u22c5\ud835\udc4f\ud835\udc57) \n\u25b7 squeeze \ud835\udc4f\ud835\udc57-many bytes \n7: end for \n8: output \u2190 out1\u2016\u2026\u2016out\u2113\n\u25b7 return the concatenation of all the results \nIn this standard, the incremental API for SHAKE128 will only be invoked through a wrapper XOF, \n19 \n\n\nPage 28\n\nFIPS 203 \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \nwhich is defined as follows. \n1. XOF.Init() = SHAKE128.Init(). \n2. XOF.Absorb(ctx, str) = SHAKE128.Absorb(ctx,str). \n3. XOF.Squeeze(ctx,\u2113) = SHAKE128.Squeeze(ctx,8 \u22c5 \u2113). \nNote that XOF.Squeeze requires the input length to be specified in bytes. This is consistent with \nthe convention that all wrapper functions treat inputs and outputs as byte arrays and measure \nthe lengths of all such arrays in terms of bytes. \n4.2 General Algorithms \nThis section specifies a number of algorithms that will be used as subroutines in ML-KEM. \n4.2.1 Conversion and Compression Algorithms \nThis section specifies several algorithms for converting between bit arrays, byte arrays, and arrays \nof integers modulo \ud835\udc5a. It also specifies a certain operation for compressing integers modulo \ud835\udc5e, \nand the corresponding decompression operation. \nAlgorithm 3 BitsToBytes(\ud835\udc4f) \nConverts a bit array (of a length that is a multiple of eight) into an array of bytes. \nInput: bit array \ud835\udc4f \u2208 {0,1}8\u22c5\u2113 . \nOutput: byte array \ud835\udc35 \u2208 \ud835\udd39\u2113 . \n1: \ud835\udc35 \u2190 (0,\u2026,0) \n2: for (\ud835\udc56 \u2190 0; \ud835\udc56 < 8\u2113; \ud835\udc56++) \n3: \n\ud835\udc35[\u230a\ud835\udc56/8\u230b] \u2190 \ud835\udc35[\u230a\ud835\udc56/8\u230b]+\ud835\udc4f[\ud835\udc56]\u22c52\ud835\udc56 mod 8 \n4: end for \n5: return \ud835\udc35 \nAlgorithm 4 BytesToBits(\ud835\udc35) \nPerforms the inverse of BitsToBytes, converting a byte array into a bit array. \nInput: byte array \ud835\udc35 \u2208\ud835\udd39\u2113 . \nOutput: bit array \ud835\udc4f \u2208 {0,1}8\u22c5\u2113 . \n1: \ud835\udc36\u2190\ud835\udc35 \n\u25b7 copy \ud835\udc35 into array \ud835\udc36 \u2208\ud835\udd39\u2113 \n2: for (\ud835\udc56 \u2190 0; \ud835\udc56 < \u2113; \ud835\udc56++) \n3: \nfor (\ud835\udc57 \u2190 0; \ud835\udc57 < 8; \ud835\udc57++) \n4: \n\ud835\udc4f[8\ud835\udc56+\ud835\udc57] \u2190 \ud835\udc36[\ud835\udc56] mod 2 \n5: \n\ud835\udc36[\ud835\udc56] \u2190 \u230a\ud835\udc36[\ud835\udc56]/2\u230b \n6: \nend for \n7: end for \n8: return \ud835\udc4f \n20 \n\n\nPage 29\n\nFIPS 203 \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \nConverting between bits and bytes. The algorithms BitsToBytes (Algorithm 3) and BytesToBits \n(Algorithm 4) convert between bit arrays and byte arrays. The inputs to BitsToBytes and the \noutputs of BytesToBits are bit arrays, with each segment of eight bits representing a byte in \nlittle-endian order. As an example, the 8-bit string 11010001 corresponds to the byte 20 +21 + \n23 +27 = 139. \nCompression and decompression. Recall that \ud835\udc5e = 3329, and that the bit length of \ud835\udc5e is 12. For \n\ud835\udc51 < 12, define \nCompress\ud835\udc51 \u2236 \u2124\ud835\udc5e \u27f6 \u21242\ud835\udc51 \n\ud835\udc65 \u27fc \u2308(2\ud835\udc51/\ud835\udc5e) \u22c5 \ud835\udc65\u230b mod 2\ud835\udc51 . \nDecompress\ud835\udc51 \u2236 \u21242\ud835\udc51 \u27f6 \u2124\ud835\udc5e \n\ud835\udc66 \u27fc \u2308(\ud835\udc5e/2\ud835\udc51) \u22c5 \ud835\udc66\u230b. \n(4.7) \n(4.8) \nThe input and output types of these functions are integers modulo \ud835\udc5a (see Section 2.4.1). Division \nand rounding in the computation of these functions are performed in the set of rational numbers. \nFloating-point computations shall not be used. \nThe Compress and Decompress algorithms satisfy two important properties. First, decompression \nfollowed by compression preserves the input. That is, Compress\ud835\udc51(Decompress\ud835\udc51(\ud835\udc66)) = \ud835\udc66 for \nall \ud835\udc66 \u2208 \u21242\ud835\udc51 and all \ud835\udc51 < 12. Second, if \ud835\udc51 is large (i.e., close to 12), compression followed by \ndecompression does not significantly alter the value. \nEncoding and decoding. The algorithms ByteEncode (Algorithm 5) and ByteDecode (Algorithm \n6) will be used for conversion between integers modulo \ud835\udc5a and bytes. The algorithm ByteEncode \nconverts an array of \ud835\udc5b = 256 integers modulo \ud835\udc5a into a corresponding array of bytes. ByteDecode \nperforms the inverse operation, converting an array of bytes into an array of integers modulo \ud835\udc5a. \nSpecifying the modulus \ud835\udc5a is done as described below. \nFor the following description, it is convenient to view ByteDecode and ByteEncode as converting \nbetween integers and bits. The conversion between bits and bytes is straightforward and done \nusing BitsToBytes and BytesToBits. The valid range of values for the parameter \ud835\udc51 is 1 \u2264\ud835\udc51 \u226412. \nBit arrays are divided into \ud835\udc51-bit segments. The operations are performed in two different ways, \ndepending on the value of \ud835\udc51: \n\u2022 For \ud835\udc51 satisfying 1 \u2264 \ud835\udc51 \u2264 11, the conversion is one-to-one. ByteDecode\ud835\udc51 converts each \n\ud835\udc51-bit segment of its input into one integer modulo 2\ud835\udc51 , while ByteEncode\ud835\udc51 performs the \ninverse operation. \n\u2022 For \ud835\udc51 = 12, ByteDecode12 produces integers modulo \ud835\udc5e as output, while ByteEncode12 \nreceives integers modulo \ud835\udc5e as input. Specifically, ByteDecode12 converts each 12-bit \nsegment of its input into an integer modulo 212 = 4096 and then reduces the result \nmodulo \ud835\udc5e. This is no longer a one-to-one operation. Indeed, some 12-bit segments could \ncorrespond to an integer greater than \ud835\udc5e\u22121 = 3328 but less than 4096. However, this \ncannot occur for arrays produced by ByteEncode12. These aspects of ByteDecode12 and \n21 \n\n\nPage 30\n\nFIPS 203 \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \nByteEncode12 will be important when considering checking of the ML-KEM encapsulation \nkey in Section 7. \nAlgorithm 5 ByteEncode (\ud835\udc39 ) \n\ud835\udc51\nEncodes an array of \ud835\udc51-bit integers into a byte array for 1 \u2264\ud835\udc51 \u226412. \nInput: integer array \ud835\udc39 \u2208 \u2124256 , where \ud835\udc5a = 2\ud835\udc51 if \ud835\udc51 < 12, and \ud835\udc5a = \ud835\udc5e if \ud835\udc51 = 12.\n\ud835\udc5a \nOutput: byte array \ud835\udc35 \u2208 \ud835\udd3932\ud835\udc51 . \n1: for (\ud835\udc56 \u2190 0; \ud835\udc56 < 256; \ud835\udc56++) \n2: \n\ud835\udc4e\u2190\ud835\udc39[\ud835\udc56] \n\u25b7\ud835\udc4e\u2208\u2124\ud835\udc5a \n3: \nfor (\ud835\udc57 \u2190 0; \ud835\udc57 < \ud835\udc51; \ud835\udc57++) \n4: \n\ud835\udc4f[\ud835\udc56\u22c5\ud835\udc51+\ud835\udc57] \u2190 \ud835\udc4e mod 2 \n\u25b7 \ud835\udc4f \u2208 {0,1}256\u22c5\ud835\udc51 \n5: \n\ud835\udc4e\u2190(\ud835\udc4e\u2212\ud835\udc4f[\ud835\udc56\u22c5\ud835\udc51+\ud835\udc57])/2 \n\u25b7 note \ud835\udc4e \u2212 \ud835\udc4f[\ud835\udc56 \u22c5 \ud835\udc51 + \ud835\udc57] is always even \n6: \nend for \n7: end for \n8: \ud835\udc35 \u2190 BitsToBytes(\ud835\udc4f) \n9: return \ud835\udc35 \nAlgorithm 6 ByteDecode (\ud835\udc35) \n\ud835\udc51\nDecodes a byte array into an array of \ud835\udc51-bit integers for 1 \u2264\ud835\udc51 \u226412. \nInput: byte array \ud835\udc35 \u2208 \ud835\udd3932\ud835\udc51 . \nOutput: integer array \ud835\udc39 \u2208 \u2124256 , where \ud835\udc5a = 2\ud835\udc51 if \ud835\udc51 < 12 and \ud835\udc5a = \ud835\udc5e if \ud835\udc51 = 12.\n\ud835\udc5a \n1: \ud835\udc4f \u2190 BytesToBits(\ud835\udc35) \n2: for (\ud835\udc56 \u2190 0; \ud835\udc56 < 256; \ud835\udc56++) \n3: \n\ud835\udc39 [\ud835\udc56] \u2190 \u2211\ud835\udc51\u22121 \n\ud835\udc57\u21900 \ud835\udc4f[\ud835\udc56 \u22c5 \ud835\udc51 + \ud835\udc57] \u22c5 2\ud835\udc57 mod \ud835\udc5a \n4: end for \n5: return \ud835\udc39 \n4.2.2 Sampling Algorithms \nThe algorithms of ML-KEM require two sampling subroutines that are specified in Algorithms 7 \nand 8. Both of these algorithms can be used to convert a stream of uniformly random bytes into \na sample from some desired distribution. In this standard, these algorithms will be invoked with \na stream of pseudorandom bytes as the input. It follows that the output will then be a sample \nfrom a distribution that is computationally indistinguishable from the desired distribution. \nUniform sampling of NTT representations. The algorithm SampleNTT (Algorithm 7) converts \na seed together with two indexing bytes into a polynomial in the NTT domain. If the seed is \nuniformly random, the resulting polynomial will be drawn from a distribution that is computa\u00ad\ntionally indistinguishable from the uniform distribution on \ud835\udc47\ud835\udc5e. The output of SampleNTT is an \narray in \u2124256\n\ud835\udc5e \nthat contains the coefficients of the sampled element of \ud835\udc47\ud835\udc5e (see Section 2.4.4). See \nAppendix B for a note on (optionally) safely bounding the algorithm\u2019s while-loop iterations. \n22 \n\n\nPage 31\n\nFIPS 203 \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \nAlgorithm 7 SampleNTT(\ud835\udc35) \nTakes a 32-byte seed and two indices as input and outputs a pseudorandom element of \ud835\udc47\ud835\udc5e. \nInput: byte array \ud835\udc35 \u2208 \ud835\udd3934 . \n\u25b7 a 32-byte seed along with two indices \nOutput: array \u0302 \n\ud835\udc5e .\n\ud835\udc4e\u2208\u2124256 \n\u25b7 the coefficients of the NTT of a polynomial \n1: ctx \u2190 XOF.Init() \n2: ctx \u2190 XOF.Absorb(ctx,\ud835\udc35) \n\u25b7 input the given byte array into XOF \n3: \ud835\udc57 \u21900 \n4: while \ud835\udc57 < 256 do \n5: \n(ctx,\ud835\udc36) \u2190 XOF.Squeeze(ctx,3) \n\u25b7 get a fresh 3-byte array \ud835\udc36 from XOF \n6: \n\ud835\udc511 \u2190\ud835\udc36[0]+256\u22c5(\ud835\udc36[1] mod 16) \n\u25b70 \u2264\ud835\udc511 < 212 \n7: \n\ud835\udc512 \u2190\u230a\ud835\udc36[1]/16\u230b+16\u22c5\ud835\udc36[2] \n\u25b70 \u2264\ud835\udc512 < 212 \n8: \nif \ud835\udc511 < \ud835\udc5e then \n9: \n\u0302 \n\u25b7 \ud835\udc4e \u2208 \u2124256\n\ud835\udc5e \n\ud835\udc4e[\ud835\udc57] \u2190 \ud835\udc511 \n\u0302 \n10: \n\ud835\udc57 \u2190\ud835\udc57+1 \n11: \nend if \n12: \nif \ud835\udc512 < \ud835\udc5e and \ud835\udc57 < 256 then \n13: \n\u0302\n\ud835\udc4e[\ud835\udc57] \u2190 \ud835\udc512 \n14: \n\ud835\udc57 \u2190\ud835\udc57+1 \n15: \nend if \n16: end while \n17: return \ud835\udc4e\u0302 \nSampling from the centered binomial distribution. ML-KEM makes use of a special distribution \nD\ud835\udf02(\ud835\udc45\ud835\udc5e) of polynomials in \ud835\udc45\ud835\udc5e with small coefficients. Such polynomials are sometimes referred \nto as \u201cerrors\u201d or \u201cnoise.\u201d The distribution is parameterized by an integer \ud835\udf02 \u2208 {2,3}. To sample a \npolynomial from D\ud835\udf02(\ud835\udc45\ud835\udc5e), each of its coefficients is independently sampled from a certain cen\u00ad\ntered binomial distribution (CBD) on \u2124\ud835\udc5e. The algorithm SamplePolyCBD (Algorithm 8) samples \nthe coefficient array of a polynomial \ud835\udc53 \u2208 \ud835\udc45\ud835\udc5e according to the distribution D\ud835\udf02(\ud835\udc45\ud835\udc5e), provided that \nAlgorithm 8 SamplePolyCBD (\ud835\udc35) \n\ud835\udf02\nTakes a seed as input and outputs a pseudorandom sample from the distribution D\ud835\udf02(\ud835\udc45\ud835\udc5e). \nInput: byte array \ud835\udc35 \u2208 \ud835\udd3964\ud835\udf02 . \nOutput: array \ud835\udc53 \u2208 \u2124256\n\ud835\udc5e . \n\u25b7 the coefficients of the sampled polynomial \n1: \ud835\udc4f \u2190 BytesToBits(\ud835\udc35) \n2: for (\ud835\udc56 \u2190 0; \ud835\udc56 < 256; \ud835\udc56++) \n3: \n\ud835\udc65\u2190\u2211\ud835\udf02\u22121 \n\u25b70 \u2264\ud835\udc65\u2264\ud835\udf02 \n\ud835\udc57\u21900 \ud835\udc4f[2\ud835\udc56\ud835\udf02 + \ud835\udc57] \n4: \n\ud835\udc66\u2190\u2211\ud835\udf02\u22121 \n\u25b70 \u2264\ud835\udc66\u2264\ud835\udf02 \n\ud835\udc57\u21900 \ud835\udc4f[2\ud835\udc56\ud835\udf02 + \ud835\udf02 + \ud835\udc57] \n5: \n\ud835\udc53[\ud835\udc56] \u2190 \ud835\udc65\u2212\ud835\udc66 mod \ud835\udc5e \n\u25b70 \u2264\ud835\udc53[\ud835\udc56] \u2264\ud835\udf02 or \ud835\udc5e\u2212\ud835\udf02 \u2264\ud835\udc53[\ud835\udc56] \u2264\ud835\udc5e\u22121 \n6: end for \n7: return \ud835\udc53 \n23 \n\n\nPage 32\n\nFIPS 203 \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \nits input is a stream of uniformly random bytes. \n4.3 The Number-Theoretic Transform \nThe Number-Theoretic Transform (NTT) can be viewed as a specialized, exact version of the \ndiscrete Fourier transform. In the case of ML-KEM, the NTT is used to improve the efficiency of \nmultiplication in the ring \ud835\udc45\ud835\udc5e. Recall that \ud835\udc45\ud835\udc5e is the ring \u2124\ud835\udc5e[\ud835\udc4b]/(\ud835\udc4b\ud835\udc5b +1) of polynomials of the \nform \ud835\udc53 = \ud835\udc530 +\ud835\udc531\ud835\udc4b+\u22ef+\ud835\udc53255\ud835\udc4b255 (where \ud835\udc53\ud835\udc57 \u2208 \u2124\ud835\udc5e for all \ud835\udc57), with the ring operations defined \nby arithmetic modulo \ud835\udc4b\ud835\udc5b +1. \nThe ring \ud835\udc45\ud835\udc5e is isomorphic to another ring \ud835\udc47\ud835\udc5e, which is a direct sum of 128 quadratic extensions \nof \u2124\ud835\udc5e. The NTT is a computationally efficient isomorphism between these two rings. When a \npolynomial \ud835\udc53 \u2208 \ud835\udc45\ud835\udc5e is input, the NTT outputs an element \u0302\n\u0302\n\ud835\udc53 \u2236= NTT(\ud835\udc53) of the ring \ud835\udc47\ud835\udc5e, where \ud835\udc53 is \ncalled the \u201cNTT representation\u201d of \ud835\udc53. The isomorphism property implies that \n\ud835\udc53 \u00d7\ud835\udc45\ud835\udc5e \ud835\udc54 = NTT\u22121(\ud835\udc53 \u00d7\n \ud835\udc47\ud835\udc5e \ud835\udc54),\n \n\u0302\n\u0302\n(4.9) \nwhere \u00d7\ud835\udc45\ud835\udc5e and \u00d7\ud835\udc47\ud835\udc5e denote multiplication in \ud835\udc45\ud835\udc5e and \ud835\udc47\ud835\udc5e, respectively. Moreover, since \ud835\udc47\ud835\udc5e is a \nproduct of 128 rings that each consist of polynomials of degree at most one, the operation \u00d7\ud835\udc47\ud835\udc5e \nis much more efficient than the operation \u00d7\ud835\udc45\ud835\udc5e . For these reasons, the NTT is considered to be \nan integral part of ML-KEM and not merely an optimization. \nAs the rings \ud835\udc45\ud835\udc5e and \ud835\udc47\ud835\udc5e have a vector space structure over \u2124\ud835\udc5e, the most natural abstract data \ntype to represent elements from either of these rings is \u2124\ud835\udc5b\n\ud835\udc5e . For this reason, the choice of data \nstructure for the inputs and outputs of NTT and NTT\u22121 are length-\ud835\udc5b arrays of integers modulo \n\ud835\udc5e. These arrays are understood to represent elements of \ud835\udc47\ud835\udc5e or \ud835\udc45\ud835\udc5e, respectively (see Section \n2.4.4). Algorithms 9 and 10 describe an efficient means of computing NTT and NTT\u22121 in place. \nHowever, to clarify the distinction between the algebraic objects before and after the conversion, \nthe algorithms are written with explicit inputs and outputs. This is consistent with this standard\u2019s \nconvention that all inputs are passed by copy. \nThe mathematical structure of the NTT. In ML-KEM, \ud835\udc5e is the prime 3329 = 28 \u22c513 + 1, and \n\ud835\udc5b = 256. There are 128 primitive 256-th roots of unity and no primitive 512-th roots of unity in \n\u2124\ud835\udc5e. Note that \ud835\udf01 = 17 \u2208\u2124\ud835\udc5e is a primitive 256-th root of unity modulo \ud835\udc5e. Thus, \ud835\udf01128 \u2261 \u22121. \nDefine BitRev7(\ud835\udc56) to be the integer represented by bit-reversing the unsigned 7-bit value that \ncorresponds to the input integer \ud835\udc56 \u2208 {0,\u2026,127}. \nThe polynomial \ud835\udc4b256 +1 factors into 128 polynomials of degree 2 modulo \ud835\udc5e as follows: \n127 \n\ud835\udc4b256 +1 = \n(\ud835\udc4b2 \u2212\ud835\udf012BitRev7(\ud835\udc56)+1). \n\u220f \n\ud835\udc56=0 \n(4.10) \nTherefore, \ud835\udc45\ud835\udc5e \u2236= \u2124\ud835\udc5e[\ud835\udc4b]/(\ud835\udc4b256 +1) is isomorphic to a direct sum of 128 quadratic extension \n24 \n\n\nPage 33\n\nFIPS 203 \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \nfields of \u2124\ud835\udc5e, denoted \ud835\udc47\ud835\udc5e. Specifically, this ring has the structure \n127 \n\ud835\udc47\ud835\udc5e \u2236= \u2a01\u2124\ud835\udc5e[\ud835\udc4b]/(\ud835\udc4b2 \u2212\ud835\udf012BitRev7(\ud835\udc56)+1). \n\ud835\udc56=0 \n(4.11) \n\u0302\nThus, the NTT representation \ud835\udc53 \u2208 \ud835\udc47\ud835\udc5e of a polynomial \ud835\udc53 \u2208 \ud835\udc45\ud835\udc5e is the vector that consists of the \ncorresponding residues of degree at most one: \n\u0302\n\ud835\udc53 \u2236= (\ud835\udc53 mod (\ud835\udc4b2 \u2212\ud835\udf012BitRev7(0)+1),\u2026,\ud835\udc53 mod (\ud835\udc4b2 \u2212\ud835\udf012BitRev7(127)+1)) . \n(4.12) \nAs discussed in Section 2.4.4, the algorithms in this standard represent \ud835\udc53 \u0302as an array of 256 \nintegers modulo \ud835\udc5e. Specifically, \n\ud835\udc53 mod (\ud835\udc4b2 \u2212\ud835\udf012BitRev7(\ud835\udc56)+1) =  \n\ud835\udc53[2\ud835\udc56] + \ud835\udc53[2\ud835\udc56 + 1]\ud835\udc4b, \n\u0302\n\u0302\n(4.13) \nfor \ud835\udc56 from 0 to 127. \nThe ML-KEM NTT algorithms. An algorithm for the ML-KEM NTT is described in Algorithm 9. An \nalgorithm for the inverse operation (NTT\u22121) is described in Algorithm 10. These two algorithms \nwill be used to transform elements of \ud835\udc45\ud835\udc5e to elements of \ud835\udc47\ud835\udc5e (using NTT) and vice versa (using \nNTT\u22121). In addition, as discussed in Section 2.4.8, these algorithms represent the coordinate-\nwise transformation of structures over those rings. Specifically, they map matrices/vectors with \nentries in \ud835\udc45\ud835\udc5e to matrices/vectors with entries in \ud835\udc47\ud835\udc5e (using NTT) and vice versa (using NTT\u22121). \nThe values \ud835\udf01BitRev7(\ud835\udc56) mod \ud835\udc5e for \ud835\udc56 = 1,\u2026,127 used in line 5 of Algorithm 9 and line 5 of Algorithm \n10 may be precomputed into an array. This array is given in Appendix A. \n25 \n\n\nPage 34\n\nFIPS 203 \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \nAlgorithm 9 NTT(\ud835\udc53) \n\u0302\nComputes the NTT representation \ud835\udc53 of the given polynomial \ud835\udc53 \u2208 \ud835\udc45\ud835\udc5e. \nInput: array \ud835\udc53 \u2208 \u2124256\n\ud835\udc5e . \n\u25b7 the coefficients of the input polynomial \n\u0302\nOutput: array \ud835\udc53 \u2208 \u2124256\n\ud835\udc5e . \n\u25b7 the coefficients of the NTT of the input polynomial \n\u0302\n1: \ud835\udc53\u2190\ud835\udc53 \n\u25b7 will compute in place on a copy of input array \n2: \ud835\udc56 \u2190 1 \n3: for (len \u2190 128; len \u22652; len \u2190 len/2) \n4: \nfor (start \u21900; start < 256; start \u2190 start +2\u22c5 len) \nzeta \u2190 \ud835\udf01BitRev7(\ud835\udc56) mod \ud835\udc5e \n5: \n6: \n\ud835\udc56 \u2190 \ud835\udc56+1 \n7: \nfor (\ud835\udc57 \u2190 start; \ud835\udc57 < start + len; \ud835\udc57++)\n\u0302\n8: \n\ud835\udc61 \u2190 zeta \u22c5 \ud835\udc53[\ud835\udc57 + len]\n\u25b7 steps 8-10 done modulo \ud835\udc5e \n\u0302\n\u0302\n9: \n\ud835\udc53[\ud835\udc57 + len] \u2190 \ud835\udc53[\ud835\udc57]\u2212\ud835\udc61 \n\u0302\n\u0302\n10: \n\ud835\udc53[\ud835\udc57] \u2190 \ud835\udc53[\ud835\udc57]+\ud835\udc61 \n11: \nend for \n12: \nend for \n13: end for \n14: return \ud835\udc53 \u0302 \n \n\u22121\nAlgorithm 10 NTT\n(\ud835\udc53)\n \n\u0302\n\u0302\nComputes the polynomial \ud835\udc53 \u2208 \ud835\udc45\ud835\udc5e that corresponds to the given NTT representation \ud835\udc53 \u2208 \ud835\udc47\ud835\udc5e. \n\u0302\nInput: array \ud835\udc53 \u2208 \u2124256\n\ud835\udc5e . \n\u25b7 the coefficients of input NTT representation \nOutput: array \ud835\udc53 \u2208 \u2124256\n\ud835\udc5e . \n\u25b7 the coefficients of the inverse NTT of the input \n1: \ud835\udc53\u2190 \ud835\udc53\u0302 \n\u25b7 will compute in place on a copy of input array \n2: \ud835\udc56 \u2190 127 \n3: for (len \u21902; len \u2264 128; len \u21902\u22c5 len) \n4: \nfor (start \u21900; start < 256; start \u2190 start +2\u22c5 len) \nzeta \u2190 \ud835\udf01BitRev7(\ud835\udc56) mod \ud835\udc5e \n5: \n6: \n\ud835\udc56 \u2190 \ud835\udc56\u22121 \n7: \nfor (\ud835\udc57 \u2190 start; \ud835\udc57 < start + len; \ud835\udc57++) \n8: \n\ud835\udc61 \u2190 \ud835\udc53[\ud835\udc57] \n9: \n\ud835\udc53[\ud835\udc57] \u2190 \ud835\udc61+\ud835\udc53[\ud835\udc57+ len]\n\u25b7 steps 9-10 done modulo \ud835\udc5e \n10: \n\ud835\udc53[\ud835\udc57 + len] \u2190 zeta \u22c5 (\ud835\udc53[\ud835\udc57 + len] \u2212 \ud835\udc61) \n11: \nend for \n12: \nend for \n13: end for \n14: \ud835\udc53 \u2190\ud835\udc53\u22c53303 mod \ud835\udc5e \n\u25b7 multiply every entry by 3303 \u2261 128\u22121 mod \ud835\udc5e \n15: return \ud835\udc53 \n26 \n\n\nPage 35\n\nFIPS 203 \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \n4.3.1 Multiplication in the NTT Domain \nThe addition and scalar multiplication of elements of \ud835\udc47\ud835\udc5e can be done using the corresponding \ncoordinate-wise arithmetic operations on the coefficient arrays (see Section 2.4.5). This section \ndescribes how to do the remaining ring operation (i.e., multiplication in \ud835\udc47\ud835\udc5e). \n\u0302\nRecall from (4.12) that \ud835\udc53 \u2208 \ud835\udc47\ud835\udc5e is a vector of 128 degree-one residues modulo quadratic polyno\u00ad\nmials. Algebraically, multiplication in the ring \ud835\udc47\ud835\udc5e consists of independent multiplication in each \nof the 128 coordinates with respect to the quadratic modulus of that coordinate. Specifically, \nthe \ud835\udc56-th coordinate in \ud835\udc47\ud835\udc5e of the product \u210e\u0302 = \ud835\udc53\u00d7\n\u0302 \ud835\udc47\ud835\udc5e\ud835\udc54\u0302 is determined by the calculation \n\u0302\n\u0302 \n\u0302\n\u0302\n\u0302\n\u0302\n\u210e[2\ud835\udc56]+ \u210e[2\ud835\udc56+1]\ud835\udc4b = (\ud835\udc53[2\ud835\udc56]+ \ud835\udc53[2\ud835\udc56+1]\ud835\udc4b)(\ud835\udc54[2\ud835\udc56]+ \ud835\udc54[2\ud835\udc56+1]\ud835\udc4b) mod (\ud835\udc4b2 \u2212\ud835\udf012BitRev7(\ud835\udc56)+1). \n(4.14) \nAlgorithm 11 MultiplyNTTs(\ud835\udc53, \ud835\udc54)\n \n\u0302\n\u0302\nComputes the product (in the ring \ud835\udc47\ud835\udc5e) of two NTT representations. \nInput: Two arrays \ud835\udc53 \u2208 \u2124256\n\ud835\udc5e \n\u0302 \n\ud835\udc5e . \n\u25b7 the coefficients of two NTT representations \n\u0302 \nand \ud835\udc54 \u2208 \u2124256 \n\u0302\nOutput: An array \u210e \u2208 \u2124256\n\ud835\udc5e . \n\u25b7 the coefficients of the product of the inputs \n1: for (\ud835\udc56 \u2190 0; \ud835\udc56 < 128; \ud835\udc56++)\n\u0302\n\u0302 \n\u0302\n\u0302\n\u0302\n\u0302\n2: \n(\u210e[2\ud835\udc56],\u210e[2\ud835\udc56+1]) \u2190 BaseCaseMultiply(\ud835\udc53[2\ud835\udc56],\ud835\udc53[2\ud835\udc56 + 1],\ud835\udc54[2\ud835\udc56], \ud835\udc54[2\ud835\udc56 + 1],\ud835\udf012BitRev7(\ud835\udc56)+1) \n3: end for \n4: return \u210e\u0302 \nThus, one can compute the product of two elements of \ud835\udc47\ud835\udc5e using the algorithm MultiplyNTTs (Al\u00ad\ngorithm 11), which uses BaseCaseMultiply (Algorithm 12) as a subroutine. The values \ud835\udf012BitRev7(\ud835\udc56)+1 \nused in Algorithm 11 may be precomputed and stored in an array (see Appendix A). MultiplyNTTs \nalso enables linear-algebraic arithmetic with matrices and vectors whose entries are in \ud835\udc47\ud835\udc5e (see \nSection 2.4.7). \nAlgorithm 12 BaseCaseMultiply(\ud835\udc4e0,\ud835\udc4e1,\ud835\udc4f0,\ud835\udc4f1,\ud835\udefe) \nComputes the product of two degree-one polynomials with respect to a quadratic modulus. \nInput: \ud835\udc4e0,\ud835\udc4e1,\ud835\udc4f0,\ud835\udc4f1 \u2208 \u2124\ud835\udc5e. \n\u25b7 the coefficients of \ud835\udc4e0 + \ud835\udc4e1\ud835\udc4b and \ud835\udc4f0 + \ud835\udc4f1\ud835\udc4b \nInput: \ud835\udefe \u2208\u2124\ud835\udc5e. \n\u25b7 the modulus is \ud835\udc4b2 \u2212\ud835\udefe \nOutput: \ud835\udc500,\ud835\udc501 \u2208 \u2124\ud835\udc5e. \n\u25b7 the coefficients of the product of the two polynomials \n1: \ud835\udc500 \u2190\ud835\udc4e0 \u22c5\ud835\udc4f0 +\ud835\udc4e1 \u22c5\ud835\udc4f1 \u22c5\ud835\udefe \n\u25b7 steps 1-2 done modulo \ud835\udc5e \n2: \ud835\udc501 \u2190\ud835\udc4e0 \u22c5\ud835\udc4f1 +\ud835\udc4e1 \u22c5\ud835\udc4f0 \n3: return (\ud835\udc500, \ud835\udc501) \n27 \n\n\nPage 36\n\nFIPS 203 \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \n5. The K-PKE Component Scheme \nThis section describes the component scheme K-PKE. As discussed in Section 3.3, K-PKE is not \napproved for use in a stand-alone fashion. It serves only as a collection of subroutines for use in \nthe algorithms of the approved scheme ML-KEM, as described in Section 7. \nK-PKE consists of three algorithms: \n1. Key generation (K-PKE.KeyGen) \n2. Encryption (K-PKE.Encrypt) \n3. Decryption (K-PKE.Decrypt) \nWhen K-PKE is instantiated as part of ML-KEM, K-PKE inherits the parameter set selected for \nML-KEM. Each parameter set specifies numerical values for each parameter. While \ud835\udc5b is always \n256 and \ud835\udc5e is always 3329, the values of the remaining parameters \ud835\udc58, \ud835\udf021, \ud835\udf022, \ud835\udc51\ud835\udc62, and \ud835\udc51\ud835\udc63 vary \namong the three parameter sets. Parameters and parameter sets are described in Section 8. \nThe algorithms in this section do not perform any input checking because they are only invoked as \nsubroutines of the main ML-KEM algorithms. The algorithms of ML-KEM themselves do perform \ninput checking as needed. \nEach of the algorithms of K-PKE is accompanied by a brief, informal description in text. For \nsimplicity, this description is written in terms of vectors and matrices whose entries are elements \nof \ud835\udc45\ud835\udc5e. In the actual algorithm, most of the computations occur in the NTT domain in order to \nimprove the efficiency of multiplication. The relevant vectors and matrices will then have entries \nin \ud835\udc47\ud835\udc5e. Linear-algebraic arithmetic with such vectors and matrices (e.g., line 18 of K-PKE.KeyGen) \nis performed as described in Sections 2.4.7 and 4.3.1. The encryption and decryption keys of \nK-PKE are also stored in the NTT form. \n5.1 K-PKE Key Generation \nThe key generation algorithm K-PKE.KeyGen of K-PKE (Algorithm 13) receives a seed as input and \noutputs an encryption key ekPKE and a decryption key dkPKE. As is typically the case for public-key \nencryption, the encryption key can be made public, while the decryption key and the randomness \nmust remain private. Indeed, the encryption key of K-PKE will serve as the encapsulation key of \nML-KEM (see ML-KEM.KeyGen below) and can thus be made public. Meanwhile, the decryption \nkey and seed of K-PKE.KeyGen must remain private as they can be used to perform decapsulation \nin ML-KEM. \nThe matrix \ud835\udc00\n\u0302 generated in steps 3-7 of K-PKE.KeyGen can be stored, as specified in Section 3.3. \nThis allows later operations to use \ud835\udc00\n\u0302 directly rather than re-expanding it from the public seed \ud835\udf0c. \nInformal description. The decryption key of K-PKE.KeyGen is a length-\ud835\udc58 vector \ud835\udc2c of elements \nof \ud835\udc45\ud835\udc5e (i.e., \ud835\udc2c \u2208 \ud835\udc45\ud835\udc5e\n\ud835\udc58). Roughly speaking, \ud835\udc2c is a set of secret variables, while the encryption key is \na collection of \u201cnoisy\u201d linear equations (\ud835\udc00,\ud835\udc00\ud835\udc2c + \ud835\udc1e) in the secret variables \ud835\udc2c. The rows of the \nmatrix \ud835\udc00 form the equation coefficients. This matrix is generated pseudorandomly using XOF \nwith only a seed stored in the encryption key. The secret \ud835\udc2c and the \u201cnoise\u201d \ud835\udc1e are sampled from \n28 \n\n\nPage 37\n\nFIPS 203 \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \nAlgorithm 13 K-PKE.KeyGen(\ud835\udc51) \nUses randomness to generate an encryption key and a corresponding decryption key. \nInput: randomness \ud835\udc51 \u2208 \ud835\udd3932 . \n\u2208 \ud835\udd39384\ud835\udc58+32\nOutput: encryption key ekPKE \n. \n\u2208 \ud835\udd39384\ud835\udc58 \nOutput: decryption key dkPKE \n. \n1: (\ud835\udf0c,\ud835\udf0e) \u2190 G(\ud835\udc51\u2016\ud835\udc58) \n\u25b7 expand 32+1 bytes to two pseudorandom 32-byte seeds1 \n2: \ud835\udc41 \u21900 \n\u0302 \n)\ud835\udc58\u00d7\ud835\udc58 \n3: for (\ud835\udc56 \u2190 0; \ud835\udc56 < \ud835\udc58; \ud835\udc56++) \n\u25b7 generate matrix \ud835\udc00\u2208 (\u2124256\n\ud835\udc5e \n4: \nfor (\ud835\udc57 \u2190 0; \ud835\udc57 < \ud835\udc58; \ud835\udc57++)\n\u0302\n5: \n\ud835\udc00[\ud835\udc56,\ud835\udc57] \u2190 SampleNTT(\ud835\udf0c\u2016\ud835\udc57\u2016\ud835\udc56) \n\u25b7 \ud835\udc57 and \ud835\udc56 are bytes 33 and 34 of the input \n6: \nend for \n7: end for \n)\ud835\udc58 \n8: for (\ud835\udc56 \u2190 0; \ud835\udc56 < \ud835\udc58; \ud835\udc56++) \n\u25b7 generate \ud835\udc2c \u2208 (\u2124256\n\ud835\udc5e \n9: \n\ud835\udc2c[\ud835\udc56] \u2190 SamplePolyCBD\ud835\udf021(PRF\ud835\udf021(\ud835\udf0e,\ud835\udc41)) \n\u25b7 \ud835\udc2c[\ud835\udc56] \u2208 \u2124256 sampled from CBD\n\ud835\udc5e \n10: \n\ud835\udc41 \u2190\ud835\udc41+1 \n11: end for \n)\ud835\udc58 \n12: for (\ud835\udc56 \u2190 0; \ud835\udc56 < \ud835\udc58; \ud835\udc56++) \n\u25b7 generate \ud835\udc1e \u2208 (\u2124256\n\ud835\udc5e \n13: \n\ud835\udc1e[\ud835\udc56] \u2190 SamplePolyCBD\ud835\udf021(PRF\ud835\udf021(\ud835\udf0e,\ud835\udc41)) \n\u25b7 \ud835\udc1e[\ud835\udc56] \u2208 \u2124256 sampled from CBD\n\ud835\udc5e \n14: \n\ud835\udc41 \u2190\ud835\udc41+1 \n15: end for \n16: \n\u0302\n\u25b7 run NTT \ud835\udc58 times (once for each coordinate of \ud835\udc2c)\n\ud835\udc2c \u2190 NTT(\ud835\udc2c) \n17: \n\u0302\n\u25b7 run NTT \ud835\udc58 times\n\ud835\udc1e \u2190 NTT(\ud835\udc1e)\n\u0302\n\u0302\n18: \ud835\udc2d\u2190 \ud835\udc00\u2218 \ud835\udc2c+\n\u0302 \ud835\udc1e\u0302 \n\u25b7 noisy linear system in NTT domain \n\u0302\n\u0302\n19: ekPKE \u2190 ByteEncode12(\ud835\udc2d)\u2016\ud835\udf0c \n\u25b7 run ByteEncode12 \ud835\udc58 times, then append \ud835\udc00-seed \n20: dkPKE \u2190 ByteEncode12(\ud835\udc2c)\n\u0302 \n\u25b7 run ByteEncode12 \ud835\udc58 times \n21: return (ekPKE,dkPKE) \ncentered binomial distributions using randomness expanded from another seed \ud835\udf0e via PRF. Once \n\ud835\udc00, \ud835\udc2c, and \ud835\udc1e are generated, the computation of the final part \ud835\udc2d = \ud835\udc00\ud835\udc2c+\ud835\udc1e of the encryption key \ntakes place. The results are appropriately encoded into byte arrays and output. \nIn K-PKE.KeyGen, the choice of parameter set affects the length of the secret \ud835\udc2c (via the parameter \n\ud835\udc58) and, as a consequence, the sizes of the noise vector \ud835\udc1e and the pseudorandom matrix \ud835\udc00. The \nchoice of parameter set also affects the noise distribution (via the parameter \ud835\udf021) used to sample \nthe entries of \ud835\udc2c and \ud835\udc1e. \n5.2 K-PKE Encryption \nThe encryption algorithm K-PKE.Encrypt of K-PKE (Algorithm 14) takes an encryption key ekPKE, \na 32-byte plaintext \ud835\udc5a, and randomness \ud835\udc5f as input and produces a single output: a ciphertext \ud835\udc50. \n1Byte 33 of the input to G is the module dimension \ud835\udc58 \u2208 {2,3,4} \u2282 \ud835\udd39. This is included to establish domain separation \nbetween the three parameter sets. For implementations that use the seed in place of the private key, this ensures \nthat the expansion will produce an unrelated key if the seed is mistakenly expanded using a parameter set other \nthan the originally intended one. \n29 \n\n\nPage 38\n\nFIPS 203 \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \nThe matrix \ud835\udc00\n\u0302 generated in steps 4-8 of K-PKE.Encrypt can be stored, as specified in Section 3.3. \nThis allows later operations to use \ud835\udc00\n\u0302 directly rather than re-expanding it from the public seed \ud835\udf0c. \nAlgorithm 14 K-PKE.Encrypt(ekPKE,\ud835\udc5a,\ud835\udc5f) \nUses the encryption key to encrypt a plaintext message using the randomness \ud835\udc5f. \n\u2208 \ud835\udd39384\ud835\udc58+32\nInput: encryption key ekPKE \n. \nInput: message \ud835\udc5a \u2208 \ud835\udd3932 . \nInput: randomness \ud835\udc5f \u2208 \ud835\udd3932 . \nOutput: ciphertext \ud835\udc50 \u2208 \ud835\udd3932(\ud835\udc51\ud835\udc62\ud835\udc58+\ud835\udc51\ud835\udc63). \n1: \ud835\udc41 \u21900\n\u0302 \n\u0302 \n)\ud835\udc58 \n2: \ud835\udc2d \u2190 ByteDecode12(ekPKE[0 \u2236 384\ud835\udc58]) \u25b7 run ByteDecode12 \ud835\udc58 times to decode \ud835\udc2d \u2208 (\u2124256 \n3: \ud835\udf0c \u2190 ekPKE[384\ud835\udc58 \u2236 384\ud835\udc58 + 32] \n\u25b7 extract 32-byte seed from \n\ud835\udc5e \nekPKE\n\u0302\n4: for (\ud835\udc56 \u2190 0; \ud835\udc56 < \ud835\udc58; \ud835\udc56++) \n\u25b7 re-generate matrix \ud835\udc00 \u2208 (\u2124256\n\ud835\udc5e )\ud835\udc58\u00d7\ud835\udc58 sampled in Alg. 13 \n5: \nfor (\ud835\udc57 \u2190 0; \ud835\udc57 < \ud835\udc58; \ud835\udc57++)\n\u0302\n6: \n\ud835\udc00[\ud835\udc56,\ud835\udc57] \u2190 SampleNTT(\ud835\udf0c\u2016\ud835\udc57\u2016\ud835\udc56) \n\u25b7 \ud835\udc57 and \ud835\udc56 are bytes 33 and 34 of the input \n7: \nend for \n8: end for \n)\ud835\udc58 \n9: for (\ud835\udc56 \u2190 0; \ud835\udc56 < \ud835\udc58; \ud835\udc56++) \n\u25b7 generate \ud835\udc32 \u2208 (\u2124256\n\ud835\udc5e \n10: \n\ud835\udc32[\ud835\udc56] \u2190 SamplePolyCBD\ud835\udf021(PRF\ud835\udf021(\ud835\udc5f,\ud835\udc41)) \n\u25b7 \ud835\udc32[\ud835\udc56] \u2208 \u2124256 sampled from CBD\n\ud835\udc5e \n11: \n\ud835\udc41 \u2190\ud835\udc41+1 \n12: end for \n)\ud835\udc58 \n13: for (\ud835\udc56 \u2190 0; \ud835\udc56 < \ud835\udc58; \ud835\udc56++) \n\u25b7 generate \ud835\udc1e\ud835\udfcf \u2208 (\u2124256\n\ud835\udc5e \n14: \n\ud835\udc1e\ud835\udfcf[\ud835\udc56] \u2190 SamplePolyCBD\ud835\udf022(PRF\ud835\udf022(\ud835\udc5f,\ud835\udc41)) \n\u25b7 \ud835\udc1e\ud835\udfcf[\ud835\udc56] \u2208 \u2124256 sampled from CBD\n\ud835\udc5e \n15: \n\ud835\udc41 \u2190\ud835\udc41+1 \n16: end for \n17: \ud835\udc522 \u2190 SamplePolyCBD\ud835\udf022(PRF\ud835\udf022(\ud835\udc5f,\ud835\udc41)) \n\u25b7 sample \ud835\udc522 \u2208 \u2124256 from CBD\n\ud835\udc5e \n18: \n\u0302\n\u25b7 run NTT \ud835\udc58 times\n\ud835\udc32 \u2190 NTT(\ud835\udc32) \n19: \ud835\udc2e \u2190 NTT\u22121(\ud835\udc00\n\u0302 \u22ba \u2218 \ud835\udc32) + \ud835\udc1e\ud835\udfcf \n\u25b7 run NTT\u22121 \ud835\udc58 times\n\u0302 \n20: \ud835\udf07 \u2190 Decompress1(ByteDecode1(\ud835\udc5a)) \n21: \ud835\udc63 \u2190 NTT\u22121(\ud835\udc2d\u22ba\n\u0302 \u2218\ud835\udc32)+\ud835\udc522 +\ud835\udf07 \n\u25b7 encode plaintext \ud835\udc5a into polynomial \ud835\udc63 \n\u0302 \n22: \ud835\udc501 \u2190 ByteEncode\ud835\udc51\ud835\udc62(Compress\ud835\udc51\ud835\udc62(\ud835\udc2e)) \n\u25b7 run ByteEncode\ud835\udc51\ud835\udc62 and Compress\ud835\udc51\ud835\udc62 \ud835\udc58 times \n23: \ud835\udc502 \u2190 ByteEncode\ud835\udc51\ud835\udc63(Compress\ud835\udc51\ud835\udc63(\ud835\udc63)) \n24: return \ud835\udc50 \u2190 (\ud835\udc501\u2016\ud835\udc502) \nInformal description. The algorithm K-PKE.Encrypt begins by extracting the vector \ud835\udc2d and the \nseed from the encryption key. The seed is then expanded to re-generate the matrix \ud835\udc00 in the same \nmanner as was done in K-PKE.KeyGen. If \ud835\udc2d and \ud835\udc00 are derived correctly from an encryption key \nproduced by K-PKE.KeyGen, then they are equal to their corresponding values in K-PKE.KeyGen. \nRecall from the description of key generation that the pair (\ud835\udc00,\ud835\udc2d = \ud835\udc00\ud835\udc2c+\ud835\udc1e) can be thought of as \na system of noisy linear equations in the secret variables \ud835\udc2c. One can generate an additional noisy \nlinear equation in the same secret variables \u2014 without knowing \ud835\udc2c \u2014 by picking a random linear \n30 \n\n\nPage 39\n\nFIPS 203 \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \ncombination of the noisy equations in the system (\ud835\udc00,\ud835\udc2d). One can then encode information in the \n\u201cconstant term\u201d (i.e., the entry that is a linear combination of entries of \ud835\udc2d) of such a combined \nequation. This information can then be deciphered by a party in possession of \ud835\udc2c. For example, \none could encode a single bit by deciding whether or not to significantly alter the constant term, \nthus making either a nearly correct equation that corresponds to the decrypted bit value of 0 or a \nfar-from-correct equation that corresponds to the decrypted bit value of 1. In the case of K-PKE, \nthe constant term is a polynomial with 256 coefficients, so one can encode more information: \none bit in each coefficient. \nTo this end, K-PKE.Encrypt proceeds by generating a vector \ud835\udc32 \u2208 \ud835\udc45\ud835\udc5e\n\ud835\udc58 and noise terms \ud835\udc1e\ud835\udfcf \u2208 \ud835\udc45\ud835\udc5e\n\ud835\udc58 \nand \ud835\udc522 \u2208 \ud835\udc45\ud835\udc5e, all of which are sampled from the centered binomial distribution using pseudoran\u00ad\ndomness expanded via PRF from the input randomness \ud835\udc5f. One then computes the \u201cnew noisy \nequation,\u201d which is (up to some details) (\ud835\udc00\u22ba\ud835\udc32 + \ud835\udc1e1,\ud835\udc2d\u22ba\ud835\udc32 + \ud835\udc522). An appropriate encoding \ud835\udf07 of \nthe input message \ud835\udc5a is then added to the latter term in the pair. Finally, the resulting pair (\ud835\udc2e,\ud835\udc63) \nis compressed, serialized into a byte array, and output as the ciphertext. \n5.3 K-PKE Decryption \nThe decryption algorithm K-PKE.Decrypt of K-PKE (Algorithm 15) takes a decryption key dkPKE \nand a ciphertext \ud835\udc50 as input, requires no randomness, and outputs a plaintext \ud835\udc5a. \nInformal description. The algorithm K-PKE.Decrypt begins by recovering a pair (\ud835\udc2e\u2032,\ud835\udc63\u2032) from the \nciphertext \ud835\udc50 (see the description of K-PKE.Encrypt). Here, one can think of \ud835\udc2e\u2032 as the coefficients \nof the equation and \ud835\udc63\u2032 as the constant term. The decryption key dkPKE contains the vector of \nsecret variables \ud835\udc2c. The decryption algorithm can thus use the decryption key to compute the \ntrue constant term \ud835\udc63 = \ud835\udc2c\u22ba\ud835\udc2e\u2032 and calculate \ud835\udc63\u2032 \u2212\ud835\udc63. The decryption algorithm ends by decoding \nthe plaintext message \ud835\udc5a from \ud835\udc63\u2032 \u2212\ud835\udc63 and outputting \ud835\udc5a. \nAlgorithm 15 K-PKE.Decrypt(dkPKE,\ud835\udc50) \nUses the decryption key to decrypt a ciphertext. \n\u2208 \ud835\udd39384\ud835\udc58 \nInput: decryption key dkPKE \n. \nInput: ciphertext \ud835\udc50 \u2208 \ud835\udd3932(\ud835\udc51\ud835\udc62\ud835\udc58+\ud835\udc51\ud835\udc63). \nOutput: message \ud835\udc5a \u2208 \ud835\udd3932 . \n1: \ud835\udc501 \u2190 \ud835\udc50[0 \u2236 32\ud835\udc51\ud835\udc62\ud835\udc58] \n2: \ud835\udc502 \u2190\ud835\udc50[32\ud835\udc51\ud835\udc62\ud835\udc58\u223632(\ud835\udc51\ud835\udc62\ud835\udc58+\ud835\udc51\ud835\udc63)] \n3: \ud835\udc2e\u2032 \u2190 Decompress\ud835\udc51\ud835\udc62(ByteDecode\ud835\udc51\ud835\udc62(\ud835\udc501)) \u25b7 run Decompress\ud835\udc51\ud835\udc62 and ByteDecode\ud835\udc51\ud835\udc62 \ud835\udc58 times \n4: \ud835\udc63\u2032 \u2190 Decompress\ud835\udc51\ud835\udc63(ByteDecode\ud835\udc51\ud835\udc63(\ud835\udc502)) \n5: \n\u0302\n)\n\ud835\udc2c \u2190 ByteDecode12(dkPKE \n\u25b7 run ByteDecode12 \ud835\udc58 times \n6: \ud835\udc64 \u2190 \ud835\udc63\u2032 \u2212 NTT\u22121(\ud835\udc2c\u22ba\n\u0302 \u2218 NTT(\ud835\udc2e\u2032)) \n\u25b7 run NTT \ud835\udc58 times; run NTT\u22121 once \n7: \ud835\udc5a \u2190 ByteEncode1(Compress1(\ud835\udc64)) \n\u25b7 decode plaintext \ud835\udc5a from polynomial \ud835\udc63 \n8: return \ud835\udc5a \n31 \n\n\nPage 40\n\nFIPS 203 \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \n6. Main Internal Algorithms \nThis section specifies three algorithms: ML-KEM.KeyGen_internal, ML-KEM.Encaps_internal, \nand ML-KEM.Decaps_internal. These three algorithms are all deterministic, meaning that their \noutput is completely determined by their input. No randomness is sampled inside of these \nalgorithms. These three algorithms will be used to construct ML-KEM in Section 7. The algorithms \nin this section make use of the parameters \ud835\udc5b, \ud835\udc5e, \ud835\udc58, \ud835\udc51\ud835\udc62, and \ud835\udc51\ud835\udc63. The subroutines they invoke \nadditionally make use of the parameters \ud835\udf021 and \ud835\udf022. While \ud835\udc5b is always 256 and \ud835\udc5e is always 3329, \nthe remaining parameters vary among the possible parameter sets (see Section 8). \nThe interfaces specified in this section will be used to test ML-KEM implementations through \nthe Cryptographic Algorithm Validation Program (CAVP). The key generation function in this \nsection may also be used to re-expand a key from a seed (see Section 3.3), including when \nobtaining assurance of private key possession via regeneration. As prescribed in Section 3.3, the \ninterfaces specified in this section should not be made available to applications other than for \ntesting purposes, and the random seeds (as specified in ML-KEM.KeyGen and ML-KEM.Encaps \nin Section 7) shall be generated by the cryptographic module. \n6.1 Internal Key Generation \nThe algorithm ML-KEM.KeyGen_internal (Algorithm 16) accepts two random seeds as input, and \nproduces an encapsulation key and a decapsulation key. \nInformal description. The core subroutine of ML-KEM.KeyGen_internal is the key generation \nalgorithm of K-PKE (Algorithm 13). The encapsulation key is simply the encryption key of K-PKE. \nThe decapsulation key consists of the decryption key of K-PKE, the encapsulation key, a hash \nof the encapsulation key, and a random 32-byte value. This random value will be used in the \n\u201dimplicit rejection\u201d mechanism of the internal decapsulation algorithm (Algorithm 18). \nAlgorithm 16 ML-KEM.KeyGen_internal(\ud835\udc51,\ud835\udc67) \nUses randomness to generate an encapsulation key and a corresponding decapsulation key. \nInput: randomness \ud835\udc51 \u2208 \ud835\udd3932 . \nInput: randomness \ud835\udc67 \u2208 \ud835\udd3932 . \nOutput: encapsulation key ek \u2208 \ud835\udd39384\ud835\udc58+32 . \nOutput: decapsulation key dk \u2208 \ud835\udd39768\ud835\udc58+96 . \n1: (ekPKE,dkPKE) \u2190 K-PKE.KeyGen(\ud835\udc51) \n\u25b7 run key generation for K-PKE \n2: ek \u2190 ekPKE \n\u25b7 KEM encaps key is just the PKE encryption key \n3: dk \u2190(dkPKE\u2016ek\u2016H(ek)\u2016\ud835\udc67) \n\u25b7 KEM decaps key includes PKE decryption key \n4: return (ek,dk) \n6.2 Internal Encapsulation \nThe algorithm ML-KEM.Encaps_internal (Algorithm 17) accepts an encapsulation key and a ran\u00ad\ndom byte array as input and outputs a ciphertext and a shared key. \n32 \n\n\nPage 41\n\nFIPS 203 \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \nAlgorithm 17 ML-KEM.Encaps_internal(ek,\ud835\udc5a) \nUses the encapsulation key and randomness to generate a key and an associated ciphertext. \nInput: encapsulation key ek \u2208 \ud835\udd39384\ud835\udc58+32 . \nInput: randomness \ud835\udc5a \u2208 \ud835\udd3932 . \nOutput: shared secret key \ud835\udc3e \u2208 \ud835\udd3932 . \nOutput: ciphertext \ud835\udc50 \u2208 \ud835\udd3932(\ud835\udc51\ud835\udc62\ud835\udc58+\ud835\udc51\ud835\udc63). \n1: (\ud835\udc3e,\ud835\udc5f) \u2190 G(\ud835\udc5a\u2016H(ek)) \n\u25b7 derive shared secret key \ud835\udc3e and randomness \ud835\udc5f \n2: \ud835\udc50 \u2190 K-PKE.Encrypt(ek,\ud835\udc5a,\ud835\udc5f) \n\u25b7 encrypt \ud835\udc5a using K-PKE with randomness \ud835\udc5f \n3: return (\ud835\udc3e,\ud835\udc50) \nInformal description. The core subroutine of ML-KEM.Encaps_internal is the encryption algo\u00ad\nrithm of K-PKE, which is used to encrypt a random value \ud835\udc5a into a ciphertext \ud835\udc50. A copy of the \nshared secret key \ud835\udc3e and the randomness used during encryption are derived from \ud835\udc5a and the \nencapsulation key ek via hashing. Specifically, H is applied to ek, and the result is concatenated \nwith \ud835\udc5a and then hashed using G. Finally, the algorithm outputs the shared secret key \ud835\udc3e and the \nciphertext \ud835\udc50. \n6.3 Internal Decapsulation \nThe algorithm ML-KEM.Decaps_internal (Algorithm 18) accepts a decapsulation key and a cipher-\ntext as input, does not use any randomness, and outputs a shared secret key. \nInformal description. The algorithm ML-KEM.Decaps_internal begins by parsing out the com\u00ad\nponents of the decapsulation key dk of ML-KEM. These components are an (encryption key, \ndecryption key) pair for K-PKE, a hash value \u210e, and a random value \ud835\udc67. The decryption key of \nK-PKE is then used to decrypt the input ciphertext \ud835\udc50 to get a plaintext \ud835\udc5a\u2032 . The decapsulation \nalgorithm then re-encrypts \ud835\udc5a\u2032 and computes a candidate shared secret key \ud835\udc3e\u2032 in the same \nmanner as should have been done in encapsulation. Specifically, \ud835\udc3e\u2032 and the encryption ran\u00ad\ndomness \ud835\udc5f\u2032 are computed by hashing \ud835\udc5a\u2032 and the encryption key of K-PKE, and a ciphertext \ud835\udc50\u2032 is \ngenerated by encrypting \ud835\udc5a\u2032 using randomness \ud835\udc5f\u2032 . Finally, decapsulation checks whether the \nresulting ciphertext \ud835\udc50\u2032 matches the provided ciphertext \ud835\udc50. If it does not, the algorithm performs \nan \u201cimplicit rejection\u201d: the value of \ud835\udc3e\u2032 is changed to a hash of \ud835\udc50 together with the random value \n\ud835\udc67 stored in the ML-KEM secret key (see the discussion of decapsulation failures in Section 3.2). \nIn either case, decapsulation outputs the resulting shared secret key \ud835\udc3e\u2032 . \nThe \u201cimplicit reject\u201d flag computed in step 9 (by comparing \ud835\udc50 and \ud835\udc50\u2032 ) is a secret piece of interme\u00ad\ndiate data. As specified in the requirements in Section 3.3, this flag shall be destroyed prior to \nML-KEM.Decaps_internal terminating. In particular, returning the value of the flag as an output \nin any form is not permitted. \n33 \n\n\nPage 42\n\nFIPS 203 \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \nAlgorithm 18 ML-KEM.Decaps_internal(dk,\ud835\udc50) \nUses the decapsulation key to produce a shared secret key from a ciphertext. \nInput: decapsulation key dk \u2208 \ud835\udd39768\ud835\udc58+96 . \nInput: ciphertext \ud835\udc50 \u2208 \ud835\udd3932(\ud835\udc51\ud835\udc62\ud835\udc58+\ud835\udc51\ud835\udc63). \nOutput: shared secret key \ud835\udc3e \u2208 \ud835\udd3932 . \n1: dkPKE \u2190 dk[0 \u2236 384\ud835\udc58] \n\u25b7 extract (from KEM decaps key) the PKE decryption key \n2: ekPKE \u2190 dk[384\ud835\udc58 \u2236 768\ud835\udc58 + 32] \n\u25b7 extract PKE encryption key \n3: \u210e\u2190 dk[768\ud835\udc58 + 32 \u2236 768\ud835\udc58 + 64] \n\u25b7 extract hash of PKE encryption key \n4: \ud835\udc67 \u2190 dk[768\ud835\udc58 + 64 \u2236 768\ud835\udc58 + 96] \n\u25b7 extract implicit rejection value \n5: \ud835\udc5a\u2032 \u2190 K-PKE.Decrypt(dkPKE,\ud835\udc50) \n\u25b7 decrypt ciphertext \n6: (\ud835\udc3e\u2032,\ud835\udc5f\u2032) \u2190 G(\ud835\udc5a\u2032\u2016\u210e)\n\u0304\n7: \ud835\udc3e \u2190 J(\ud835\udc67\u2016\ud835\udc50) \n8: \ud835\udc50\u2032 \u2190 K-PKE.Encrypt(ekPKE,\ud835\udc5a\u2032,\ud835\udc5f\u2032) \n\u25b7 re-encrypt using the derived randomness \ud835\udc5f\u2032 \n9: if \ud835\udc50 \u2260\ud835\udc50\u2032 then \n10: \n\ud835\udc3e\u2032 \u2190\ud835\udc3e\u0304 \n\u25b7 if ciphertexts do not match, \u201cimplicitly reject\u201d \n11: end if \n12: return \ud835\udc3e\u2032 \n34 \n\n\nPage 43\n\nFIPS 203 \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \n7. The ML-KEM Key-Encapsulation Mechanism \nThis section describes the three main algorithms of the ML-KEM scheme: \n1. Key generation (ML-KEM.KeyGen) \n2. Encapsulation (ML-KEM.Encaps) \n3. Decapsulation (ML-KEM.Decaps) \nTo instantiate ML-KEM, one must select a parameter set. Each parameter set is associated with \na particular trade-off between security and performance. The three possible parameter sets are \ncalled ML-KEM-512, ML-KEM-768, and ML-KEM-1024 and are described in detail in Table 2 of \nSection 8. Each parameter set assigns specific numerical values to the individual parameters \ud835\udc5b, \n\ud835\udc5e, \ud835\udc58, \ud835\udf021, \ud835\udf022, \ud835\udc51\ud835\udc62, and \ud835\udc51\ud835\udc63. While \ud835\udc5b is always 256 and \ud835\udc5e is always 3329, the remaining parameters \nvary among the three parameter sets. Implementers shall ensure that the three algorithms of \nML-KEM listed above are only invoked with a valid parameter set, and that this parameter set is \nselected appropriately for the desired application. Moreover, implementers shall ensure that the \nparameter set used in any particular invocation of ML-KEM.Encaps or ML-KEM.Decaps matches \nthe parameter set associated to the provided inputs. \n7.1 ML-KEM Key Generation \nThe key generation algorithm ML-KEM.KeyGen for ML-KEM (Algorithm 19) accepts no input, \ngenerates randomness internally, and produces an encapsulation key and a decapsulation key. \nWhile the encapsulation key can be made public, the decapsulation key shall remain private. \nThe seed (\ud835\udc51,\ud835\udc67) generated in steps 1 and 2 of ML-KEM.KeyGen can be stored for later expan\u00ad\nsion using ML-KEM.KeyGen_internal (see Section 3.3). As the seed can be used to compute \nthe decapsulation key, it is sensitive data and shall be treated with the same safeguards as a \ndecapsulation key (see SP 800-227 [1]). \nAlgorithm 19 ML-KEM.KeyGen() \nGenerates an encapsulation key and a corresponding decapsulation key. \nOutput: encapsulation key ek \u2208 \ud835\udd39384\ud835\udc58+32 . \nOutput: decapsulation key dk \u2208 \ud835\udd39768\ud835\udc58+96 . \n$ \n1: \ud835\udc51\u2190\n\u2212 \ud835\udd3932 \n\u25b7\ud835\udc51 is 32 random bytes (see Section 3.3)\n$ \n2: \ud835\udc67\u2190\n\u2212 \ud835\udd3932 \n\u25b7\ud835\udc67 is 32 random bytes (see Section 3.3) \n3: if \ud835\udc51 == NULL or \ud835\udc67 == NULL then \n4: \nreturn \u22a5\n\u25b7 return an error indication if random bit generation failed \n5: end if \n6: (ek, dk) \u2190 ML-KEM.KeyGen_internal(\ud835\udc51,\ud835\udc67) \n\u25b7 run internal key generation algorithm \n7: return (ek,dk) \nSecure key establishment depends on the use of key pairs that have been properly generated \nvia ML-KEM.KeyGen. If the owner of a KEM key pair did not generate the key pair but instead \nreceived it from a trusted third party or other source, the owner may optionally perform certain \n35 \n\n\nPage 44\n\ntest \u2190 ByteEncode12(ByteDecode12(ek[0 \u2236 384\ud835\udc58])) \nFIPS 203 \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \nchecks on the key pair. While these checks can detect certain corruptions, they do not guarantee \nthat the key pair was properly generated. \nKey pair check. To check a candidate key pair1 \n1In discussions of input checking, the \u201clow overline\u201d in the notation indicates that the input has not yet been \nchecked (e.g., ek has not yet been checked, while ek has passed the check). \n(ek,dk), perform the following checks: \n1. (Seed consistency) If a seed (\ud835\udc51,\ud835\udc67) is available, run ML-KEM.KeyGen_internal(\ud835\udc51,\ud835\udc67), and \nverify that the output is equal to (ek,dk). \n2. (Encapsulation key check) Check ek as specified in Section 7.2. \n3. (Decapsulation key check) Check dk as specified in Section 7.3. \n4. (Pair-wise consistency) Perform the following steps: \n$ \ni. Generate an array of 32 random bytes by performing \ud835\udc5a \u2190\n\u2212 \ud835\udd3932 . \nii. Perform (\ud835\udc3e,\ud835\udc50) \u2190 ML-KEM.Encaps_internal(ek,\ud835\udc5a). \niii. Perform \ud835\udc3e\u2032 \u2190 ML-KEM.Decaps_internal(dk,\ud835\udc50). \niv. Reject unless \ud835\udc3e == \ud835\udc3e\u2032 . \nIt is important to note that this checking process does not guarantee that the key pair is a properly \nproduced output of ML-KEM.KeyGen. \n7.2 ML-KEM Encapsulation \nThe encapsulation algorithm ML-KEM.Encaps of ML-KEM (Algorithm 20) accepts an encapsula\u00ad\ntion key as input, generates randomness internally, and outputs a ciphertext and a shared key. \nThis algorithm requires input checking, as specified below. \nEncapsulation key check. To check a candidate encapsulation key ek, perform the following: \n1. (Type check) If ek is not an array of bytes of length 384\ud835\udc58 + 32 for the value of \ud835\udc58 specified \nby the relevant parameter set, then input checking failed. \n2. (Modulus check) Perform the computation \n(7.1) \n(see Section 4.2.1). If test \u2260 ek[0 \u2236 384\ud835\udc58], then input checking failed. This check ensures \nthat the integers encoded in the public key are in the valid range [0,\ud835\udc5e \u2212 1]. \nIf both checks pass, then ML-KEM.Encaps can be run with input ek \u2236= ek. It is important to \nnote that this checking process does not guarantee that ek is a properly produced output of \nML-KEM.KeyGen. \nML-KEM.Encaps shall not be run with an encapsulation key that has not been checked as above. \nHowever, checking of the encapsulation key need not be performed by the encapsulating party, \n36 \n\n\nPage 45\n\ntest \u2190 H(dk[384\ud835\udc58 \u2236 768\ud835\udc58+32])). \nFIPS 203 \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \nnor with every execution of ML-KEM.Encaps. Instead, assurance that these checks have been \nperformed can be acquired through other means (see SP 800-227 [1]). \nAlgorithm 20 ML-KEM.Encaps(ek) \nUses the encapsulation key to generate a shared secret key and an associated ciphertext. \nChecked input: encapsulation key ek \u2208 \ud835\udd39384\ud835\udc58+32 . \nOutput: shared secret key \ud835\udc3e \u2208 \ud835\udd3932 . \nOutput: ciphertext \ud835\udc50 \u2208 \ud835\udd3932(\ud835\udc51\ud835\udc62\ud835\udc58+\ud835\udc51\ud835\udc63). \n1: \n2: \n$\n\ud835\udc5a \u2190\n\u2212 \ud835\udd3932 \nif \ud835\udc5a == NULL then \n\u25b7 \ud835\udc5a is 32 random bytes (see Section 3.3) \n3: \nreturn \u22a5 \n\u25b7 return an error indication if random bit generation failed \n4: end if \n5: \n6: \n(\ud835\udc3e,\ud835\udc50) \u2190 ML-KEM.Encaps_internal(ek,\ud835\udc5a) \nreturn (\ud835\udc3e,\ud835\udc50) \n\u25b7 run internal encapsulation algorithm \n7.3 ML-KEM Decapsulation \nThe decapsulation algorithm ML-KEM.Decaps of ML-KEM (Algorithm 21) accepts a decapsulation \nkey and an ML-KEM ciphertext as input, does not use any randomness, and outputs a shared \nsecret. This algorithm requires input checking, as specified below. \nDecapsulation input check. To check a candidate decapsulation key dk and ciphertext \ud835\udc50, perform \nthe following checks: \n1. (Ciphertext type check) If \ud835\udc50 is not a byte array of length 32(\ud835\udc51\ud835\udc62\ud835\udc58 + \ud835\udc51\ud835\udc63) for the values of \ud835\udc51\ud835\udc62, \n\ud835\udc51\ud835\udc63, and \ud835\udc58 specified by the relevant parameter set, then input checking has failed. \n2. (Decapsulation key type check) If dk is not a byte array of length 768\ud835\udc58 + 96 for the value of \n\ud835\udc58 specified by the relevant parameter set, then input checking has failed. \n3. (Hash check) Perform the computation \n(7.2) \nIf test \u2260 dk[768\ud835\udc58 + 32 \u2236 768\ud835\udc58 + 64], then input checking has failed. \nIf all of the above checks pass, then ML-KEM.Decaps can be run with inputs dk \u2236= dk and \ud835\udc50 \u2236= \ud835\udc50. It \nis important to note that this checking process does not guarantee that dk is a properly produced \noutput of ML-KEM.KeyGen, nor that \ud835\udc50 is a properly produced output of ML-KEM.Encaps. \nML-KEM.Decaps shall not be run with a decapsulation key or a ciphertext unless both have \nbeen checked. However, checking of the decapsulation key need not be performed by the \ndecapsulating party, nor with every execution of ML-KEM.Decaps. Instead, assurance that this \ncheck has been performed can be acquired through other means (see SP 800-227 [1]). Ciphertext \nchecking shall be performed with every execution of ML-KEM.Decaps. \n37 \n\n\nPage 46\n\nFIPS 203 \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \nAlgorithm 21 ML-KEM.Decaps(dk,\ud835\udc50) \nUses the decapsulation key to produce a shared secret key from a ciphertext. \nChecked input: decapsulation key dk \u2208 \ud835\udd39768\ud835\udc58+96 . \nChecked input: ciphertext \ud835\udc50 \u2208 \ud835\udd3932(\ud835\udc51\ud835\udc62\ud835\udc58+\ud835\udc51\ud835\udc63). \nOutput: shared secret key \ud835\udc3e \u2208 \ud835\udd3932 . \n1: \ud835\udc3e\u2032 \u2190 ML-KEM.Decaps_internal(dk,\ud835\udc50) \n\u25b7 run internal decapsulation algorithm \n2: return \ud835\udc3e\u2032 \n38 \n\n\nPage 47\n\nFIPS 203 \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \n8. Parameter Sets \nML-KEM is equipped with three parameter sets, each of the which comprises five individual \nparameters: \ud835\udc58, \ud835\udf021, \ud835\udf022, \ud835\udc51\ud835\udc62, and \ud835\udc51\ud835\udc63. There are also two constants: \ud835\udc5b = 256 and \ud835\udc5e = 3329. The \nfollowing is a brief and informal description of the roles played by the variable parameters in the \nalgorithms of K-PKE and ML-KEM. See Section 5 for details. \n\u2022 The parameter \ud835\udc58 determines the dimensions of the matrix \ud835\udc00\n\u0302 that appears in K-PKE.KeyGen \nand K-PKE.Encrypt. It also determines the dimensions of vectors \ud835\udc2c and \ud835\udc1e in K-PKE.KeyGen \nand the dimensions of vectors \ud835\udc32 and \ud835\udc1e1 in K-PKE.Encrypt. \n\u2022 The parameter \ud835\udf021 is required to specify the distribution for generating the vectors \ud835\udc2c and \ud835\udc1e \nin K-PKE.KeyGen and the vector \ud835\udc32 in K-PKE.Encrypt. \n\u2022 The parameter \ud835\udf022 is required to specify the distribution for generating the vectors \ud835\udc1e1 and \n\ud835\udc522 in K-PKE.Encrypt. \n\u2022 The parameters \ud835\udc51\ud835\udc62 and \ud835\udc51\ud835\udc63 serve as parameters and inputs for the functions Compress, \nDecompress, ByteEncode, and ByteDecode in K-PKE.Encrypt and K-PKE.Decrypt. \nThis standard approves the parameter sets given in Table 2. Each parameter set is associated \nwith a required security strength for randomness generation (see Section 3.3). The sizes of the \nML-KEM keys and ciphertexts for each parameter set are summarized in Table 3. \nTable 2. Approved parameter sets for ML-KEM \n\ud835\udc5b \n\ud835\udc5e \n\ud835\udc58 \ud835\udf021 \n\ud835\udf022 \n\ud835\udc51\ud835\udc62 \n\ud835\udc51\ud835\udc63 \nrequired RBG strength (bits) \nML-KEM-512 \n256 3329 2 \n3 \n2 \n10 \n4 \n128 \nML-KEM-768 \n256 3329 3 \n2 \n2 \n10 \n4 \n192 \nML-KEM-1024 256 3329 4 \n2 \n2 \n11 \n5 \n256 \nTable 3. Sizes (in bytes) of keys and ciphertexts of ML-KEM \nencapsulation key decapsulation key ciphertext shared secret key \nML-KEM-512 \n800 \n1632 \n768 \n32 \nML-KEM-768 \n1184 \n2400 \n1088 \n32 \nML-KEM-1024 \n1568 \n3168 \n1568 \n32 \nA parameter set name can also be said to denote a (parameter-free) KEM. Specifically, ML-KEM-\ud835\udc65 \ncan be used to denote the parameter-free KEM that results from instantiating the scheme \nML-KEM with the parameter set ML-KEM-\ud835\udc65. \nThe three parameter sets included in Table 2 were designed to meet certain security strength \ncategories defined by NIST in its original Call for Proposals [4, 22]. These security strength \ncategories are explained further in SP 800-57, Part 1 [7]. \nUsing this approach, security strength is not described by a single number, such as \u201c128 bits of \nsecurity.\u201d Instead, each ML-KEM parameter set is claimed to be at least as secure as a generic \n39 \n\n\nPage 48\n\nFIPS 203 \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \nblock cipher with a prescribed key size or a generic hash function with a prescribed output \nlength. More precisely, it is claimed that the computational resources needed to break ML-KEM \nare greater than or equal to the computational resources needed to break the block cipher or \nhash function when those computational resources are estimated using any realistic model of \ncomputation. Different models of computation can be more or less realistic and, accordingly, \nlead to more or less accurate estimates of security strength. Some commonly studied models \nare discussed in [23]. \nConcretely, ML-KEM-512 is claimed to be in security category 1, ML-KEM-768 is claimed to be \nin security category 3, and ML-KEM-1024 is claimed to be in security category 5. For additional \ndiscussion of the security strength of MLWE-based cryptosystems, see [4]. \nSelecting an appropriate parameter set. When initially establishing cryptographic protections \nfor data, the strongest possible parameter set should be used. This has a number of advantages, \nincluding reducing the likelihood of costly transitions to higher-security parameter sets in the \nfuture. At the same time, it should be noted that some parameter sets might have adverse \nperformance effects for the relevant application (e.g., the algorithm may be unacceptably slow, \nor objects such as keys or ciphertexts may be unacceptably large). \nNIST recommends using ML-KEM-768 as the default parameter set, as it provides a large security \nmargin at a reasonable performance cost. In cases where this is impractical or even higher \nsecurity is required, other parameter sets may be used. \n40 \n\n\nPage 49\n\nFIPS 203 \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \nReferences \n[1] National Institute of Standards and Technology (2024) Recommendations for key-\nencapsulation mechanisms, (National Institute of Standards and Technology, Gaithers\u00ad\nburg, MD), NIST Special Publication (SP) 800-227. [Forthcoming; will be available at \nhttps://csrc.nist.gov/publications]. \n[2] Barker EB, Chen L, Roginsky AL, Vassilev A, Davis R (2018) Recommendation for pair-wise \nkey-establishment schemes using discrete logarithm cryptography (National Institute of \nStandards and Technology, Gaithersburg, MD), NIST Special Publication (SP) 800-56A Revi\u00ad\nsion 3. https://doi.org/10.6028/NIST.SP.800-56Ar3. \n[3] Barker EB, Chen L, Roginsky AL, Vassilev A, Davis R, Simon S (2019) Recommendation for \npair-wise key-establishment using integer factorization cryptography (National Institute \nof Standards and Technology, Gaithersburg, MD), NIST Special Publication (SP) 800-56B \nRevision 2. https://doi.org/10.6028/NIST.SP.800-56Br2. \n[4] Avanzi R, Bos J, Ducas L, Kiltz E, Lepoint T, Lyubashevsky V, Schanck JM, Schwabe P, Seiler G, \nStehl\u00e9 D (2020) CRYSTALS-Kyber algorithm specifications and supporting documentation, \nThird-round submission to the NIST\u2019s post-quantum cryptography standardization process. \nAvailable at https://csrc.nist.gov/Projects/post-quantum-cryptography/post-quantum-cry \nptography-standardization/round-3-submissions. \n[5] National Institute of Standards and Technology (2015) Secure hash standard (SHS), (U.S. \nDepartment of Commerce, Washington, DC), Federal Information Processing Standards \nPublication (FIPS) 180-4. https://doi.org/10.6028/NIST.FIPS.180-4. \n[6] National Institute of Standards and Technology (2015) SHA-3 standard: Permutation-based \nhash and extendable-output functions, (U.S. Department of Commerce, Washington, DC), \nFederal Information Processing Standards Publication (FIPS) 202. https://doi.org/10.6028/ \nNIST.FIPS.202. \n[7] Barker EB (2020) Recommendation for key management: Part 1 - General, (National Institute \nof Standards and Technology, Gaithersburg, MD), NIST Special Publication (SP) 800-57 Part \n1, Rev. 5 [or as amended]. https://doi.org/10.6028/NIST.SP.800-57pt1r5. \n[8] Bos J, Ducas L, Kiltz E, Lepoint T, Lyubashevsky V, Schanck JM, Schwabe P, Seiler G, Stehl\u00e9 \nD (2018) CRYSTALS-Kyber: A CCA-secure module-lattice-based KEM. 2018 IEEE European \nSymposium on Security and Privacy (EuroS&P), pp 353\u2013367. https://doi.org/10.1109/Euro \nSP.2018.00032. \n[9] Langlois A, Stehl\u00e9 D (2015) Worst-case to average-case reductions for module lattices. \nDesigns, Codes and Cryptography 75(3):565\u2013599. https://doi.org/10.1007/s10623-014-9 \n938-4. \n[10] Regev O (2005) On lattices, learning with errors, random linear codes, and cryptography. \nProceedings of the Thirty-Seventh Annual ACM Symposium on Theory of Computing STOC \n\u201905 (Association for Computing Machinery, New York, NY, USA), pp 84\u2013\u201393. https://doi.org/ \n10.1145/1060590.1060603. \n41 \n\n\nPage 50\n\nFIPS 203 \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \n[11] Fujisaki E, Okamoto T (2013) Secure integration of asymmetric and symmetric encryption \nschemes. Journal of Cryptology 26:80\u2013101. https://doi.org/10.1007/s00145-011-9114-1. \n[12] Hofheinz D, H\u00f6velmanns K, Kiltz E (2017) A modular analysis of the Fujisaki-Okamoto trans\u00ad\nformation. Theory of Cryptography, eds Kalai Y, Reyzin L (Springer International Publishing, \nCham), pp 341\u2013371. https://doi.org/10.1007/978-3-319-70500-2_12. \n[13] Katz J, Lindell Y (2020) Introduction to Modern Cryptography (Chapman & Hall/CRC), 3rd Ed. \n[14] Almeida JB, Olmos SA, Barbosa M, Barthe G, Dupressoir F, Gr\u00e9goire B, Laporte V, L\u00e9chenet JC, \nLow C, Oliveira T, Pacheco H, Quaresma M, Schwabe P, Strub PY (2024) Formally verifying Ky\u00ad\nber episode V: Machine-checked IND-CCA security and correctness of ML-KEM in EasyCrypt, \nCryptology ePrint Archive, Paper 2024/843. Available at https://eprint.iacr.org/2024/843. \n[15] Ducas L, Schanck J (2021) Security estimation scripts for Kyber and Dilithium, Github reposi\u00ad\ntory. Available at https://github.com/pq-crystals/security-estimates. \n[16] Chen L (2022) Recommendation for key derivation using pseudorandom functions, (National \nInstitute of Standards and Technology, Gaithersburg, MD), NIST Special Publication (SP) \n800-108r1-upd1, Includes updates as of February 2, 2024. https://doi.org/10.6028/NIST.SP. \n800-108r1-upd1. \n[17] Barker EB, Chen L, Davis R (2020) Recommendation for key-derivation methods in key-\nestablishment schemes (National Institute of Standards and Technology, Gaithersburg, MD), \nNIST Special Publication (SP) 800-56C Revision 2. https://doi.org/10.6028/NIST.SP.800-56C \nr2. \n[18] Barker EB, Kelsey JM (2015) Recommendation for random number generation using deter\u00ad\nministic random bit generators, (National Institute of Standards and Technology, Gaithers\u00ad\nburg, MD), NIST Special Publication (SP) 800-90A, Rev. 1. https://doi.org/10.6028/NIST.SP. \n800-90Ar1. \n[19] S\u00f6nmez Turan M, Barker EB, Kelsey JM, McKay KA, Baish ML, Boyle M (2018) Recom\u00ad\nmendation for the entropy sources used for random bit generation, (National Institute \nof Standards and Technology, Gaithersburg, MD), NIST Special Publication (SP) 800-90B. \nhttps://doi.org/10.6028/NIST.SP.800-90B. \n[20] Barker E, Kelsey J, McKay K, Roginsky A, Turan MS (2024) Recommendation for random bit \ngenerator (RBG) constructions, (National Institute of Standards and Technology, Gaithers\u00ad\nburg, MD), NIST Special Publication (SP) 800-90C 4pd. https://doi.org/10.6028/NIST.SP.80 \n0-90C.4pd. \n[21] Kelsey J, Chang S, Perlner R (2016) SHA-3 Derived Functions: cSHAKE, KMAC, TupleHash \nand ParallelHash, (National Institute of Standards and Technology, Gaithersburg, MD), NIST \nSpecial Publication (SP) 800-185 [or as amended]. https://doi.org/10.6028/NIST.SP.800-1 \n85. \n[22] National Institute of Standards and Technology (2016) Submission requirements and eval\u00ad\nuation criteria for the post-quantum cryptography standardization process. Available at \nhttps://csrc.nist.gov/CSRC/media/Projects/Post-Quantum-Cryptography/documents/call-f \nor-proposals-final-dec-2016.pdf. \n42 \n\n\nPage 51\n\nFIPS 203 \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \n[23] Alagic G, Apon D, Cooper D, Dang Q, Dang T, Kelsey J, Lichtinger J, Liu YK, Miller C, Moody \nD, Peralta R, Perlner R, Robinson A, Smith-Tone D (2022) Status report on the third round \nof the NIST post-quantum cryptography standardization process (National Institute of \nStandards and Technology, Gaithersburg, MD), NIST Interagency or Internal Report (IR) \n8413. https://doi.org/10.6028/NIST.IR.8413-upd1. \n[24] CRYSTALS-Kyber submission team (2023) \u201cDiscussion about Kyber\u2019s tweaked FO transform\u201d, \nPQC-Forum Post. Available at https://groups.google.com/a/list.nist.gov/g/pqc-forum/c/W \nFRDl8DqYQ4. \n[25] CRYSTALS-Kyber submission team (2023) \u201cKyber decisions, part 2: FO transform\u201d, PQC-\nForum Post. Available at https://groups.google.com/a/list.nist.gov/g/pqc-forum/c/C0D3W \n1KoINY/m/99kIvydoAwAJ. \n43 \n\n\nPage 52\n\nFIPS 203 \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \nAppendix A \u2014 Precomputed Values for the NTT \nThe following 128 numbers are the values of \ud835\udf01BitRev7(\ud835\udc56) mod \ud835\udc5e for \ud835\udc56 \u2208 {0,\u2026,127}. These numbers \nare used in Algorithms 9 and 10. \n{ 1 \n1729 2580 3289 2642 \n630 \n1897 \n848 \n1062 1919 \n193 \n797 \n2786 3260 \n569 \n1746 \n296 \n2447 1339 1476 3046 \n56 \n2240 \n1333 \n1426 2094 \n535 \n2882 2393 2879 1974 \n821 \n289 \n331 \n3253 1756 1197 2304 2277 \n2055 \n650 \n1977 2513 \n632 \n2865 \n33 \n1320 \n1915 \n2319 1435 \n807 \n452 \n1438 2868 1534 \n2402 \n2647 2617 1481 \n648 \n2474 3110 1227 \n910 \n17 \n2761 \n583 \n2649 1637 \n723 \n2288 \n1100 \n1409 2662 3281 \n233 \n756 \n2156 3015 \n3050 \n1703 1651 2789 1789 1847 \n952 \n1461 \n2687 \n939 \n2308 2437 2388 \n733 \n2337 \n268 \n641 \n1584 2298 2037 3220 \n375 \n2549 2090 \n1645 \n1063 \n319 \n2773 \n757 \n2099 \n561 \n2466 \n2594 \n2804 1092 \n403 \n1026 1143 2150 2775 \n886 \n1722 1212 1874 1029 2110 2935 \n885 \n2154 } \n44 \n\n\nPage 53\n\nFIPS 203 \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \nWhen implementing Algorithm 11, the values \ud835\udf012BitRev7(\ud835\udc56)+1 mod \ud835\udc5e need to be computed. The \nfollowing array contains these values for \ud835\udc56 \u2208 {0,\u2026,127}: \n{ 17 \n-17 \n2761 -2761 583 \n-583 \n2649 -2649 \n1637 -1637 723 \n-723 \n2288 -2288 1100 -1100 \n1409 -1409 2662 -2662 3281 -3281 233 \n-233 \n756 \n-756 \n2156 -2156 3015 -3015 3050 -3050 \n1703 -1703 1651 -1651 2789 -2789 1789 -1789 \n1847 -1847 952 \n-952 \n1461 -1461 2687 -2687 \n939 \n-939 \n2308 -2308 2437 -2437 2388 -2388 \n733 \n-733 \n2337 -2337 268 \n-268 \n641 \n-641 \n1584 -1584 2298 -2298 2037 -2037 3220 -3220 \n375 \n-375 \n2549 -2549 2090 -2090 1645 -1645 \n1063 -1063 319 \n-319 \n2773 -2773 757 \n-757 \n2099 -2099 561 \n-561 \n2466 -2466 2594 -2594 \n2804 -2804 1092 -1092 403 \n-403 \n1026 -1026 \n1143 -1143 2150 -2150 2775 -2775 886 \n-886 \n1722 -1722 1212 -1212 1874 -1874 1029 -1029 \n2110 -2110 2935 -2935 885 \n-885 \n2154 -2154 } \n45 \n\n\nPage 54\n\nFIPS 203 \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \nAppendix B \u2014 SampleNTT Loop Bounds \nIn SampleNTT (Algorithm 7), the algorithm repeatedly generates byte arrays from the XOF to \ncreate an element of \ud835\udc47\ud835\udc5e. If a generated byte array value is out of bounds for a coefficient of \ud835\udc47\ud835\udc5e, \nthe algorithm tries again until all 256 coefficients are created. On average, this while loop will \nresolve within a reasonable number of iterations. However, there may be cases in which the \ngenerated byte arrays are consistently out of bounds and the algorithm may run for a higher \nnumber of iterations. \nImplementations should not bound this loop, if at all possible. An incorrect limit will cause \ninteroperability errors, and the chances for SampleNTT to iterate longer become exponentially \nrare. If an implementation does bound the number of iterations of SampleNTT, it shall not use a \nlimit lower than those presented in Table 4. The calculated probability of SampleNTT exceeding \nthe limit is included and calculated under standard assumptions about the output distributions \nof XOFs and hash functions. \nTable 4. While-loop limits and probabilities of occurrence for SampleNTT \nNumber of iterations Probability of reaching limit \n280 \n2\u2212261 \nIf a limit is used and the number of iterations exceeds the limit, then the algorithm shall destroy \nall intermediate results. If a return value or exception is produced, it shall be the same value for \nany execution in which the maximum number of iterations is exceeded. \n46 \n\n\nPage 55\n\nFIPS 203 \nMODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM \nAppendix C \u2014 Differences From the CRYSTALS-Kyber Submission \nThis appendix lists the differences between CRYSTALS-KYBER (as described in [4]) and the ML-KEM \nscheme (specified in this document) that result in differing input-output behavior of the main \nalgorithms (i.e., KeyGen, Encaps, Decaps). Since a conforming implementation need only match \nthe input-output behavior of these three algorithms (see \u201cImplementations\u201d and Section 3.3 \nbelow), the list does not include any of the numerous differences in how the main algorithms actu\u00ad\nally produce outputs from inputs (e.g., via different computational steps or different subroutines), \nnor any differences in presentation between this standard and [4]. \nC.1 Differences Between CRYSTALS-Kyber and FIPS 203 Initial Pub-\nlic Draft \n\u2022 In the third-round specification [4], the shared secret key was treated as a variable-length \nvalue whose length depended on how it would be used in the relevant application. In this \nspecification, the length of the shared secret key is fixed to 256 bits. It can be used directly \nin applications as a symmetric key, or symmetric keys can be derived from it, as specified \nin Section 3.3. \n\u2022 The ML-KEM.Encaps and ML-KEM.Decaps algorithms in this specification use a different \nvariant of the Fujisaki-Okamoto transform (see [24, 25]) than the third-round specifica\u00ad\ntion [4]. Specifically, ML-KEM.Encaps no longer includes a hash of the ciphertext in the \nderivation of the shared secret, and ML-KEM.Decaps has been adjusted to match this \nchange. \n\u2022 In the third-round specification [4], the initial randomness \ud835\udc5a in the ML-KEM.Encaps algo\u00ad\nrithm was first hashed before being used. Specifically, between lines 1 and 2 in Algorithm \n20, there was an additional step that performed the operation \ud835\udc5a \u2190 \ud835\udc3b(\ud835\udc5a). The purpose \nof this step was to safeguard against the use of flawed randomness generation processes. \nAs this standard requires the use of NIST-approved randomness generation, this step is \nunnecessary and is not performed in ML-KEM. \n\u2022 This specification includes explicit input checking steps that were not part of the third-round \nspecification [4]. For example, ML-KEM.Encaps requires that the byte array containing the \nencapsulation key correctly decodes to an array of integers modulo \ud835\udc5e without any modular \nreductions. \nC.2 Changes From FIPS 203 Initial Public Draft \nThe differences between CRYSTALS-KYBER and ML-KEM as described in Appendix C were included \nin the initial public draft (ipd) of FIPS 203, which was posted on August 24, 2023. Based on \ncomments submitted on the draft ML-KEM, domain separation was added to K-PKE.KeyGen to \nprevent the misuse of keys generated to target one security level from being used for a different \nsecurity level when saving a key as a seed. \nAdditionally, FIPS 203 ipd had inadvertently swapped the indices of matrix \ud835\udc00\n\u0302 in K-PKE.KeyGen and \nK-PKE.Encrypt. This was changed back in the final version of ML-KEM to match CRYSTALS-KYBER. \n47 \n\n\nPage 56\n\n",
      "context_total_tokens": 39360,
      "context_total_mb": 0.03936,
      "selected_system_instruction_keys": [
        "accurate_researcher"
      ],
      "selected_system_instruction_values": [
        "You are a careful, meticulous researcher. You are careful to state facts accurately. Whenever possible, you attribute your important statements to specific, real sources.\n\n"
      ],
      "complete_system_instruction": "You are a careful, meticulous researcher. You are careful to state facts accurately. Whenever possible, you attribute your important statements to specific, real sources.\n\n",
      "selected_user_prompt_keys": [
        "Truth in Publishing - abstract",
        "ELI5 - abstract",
        "custom user prompt"
      ],
      "selected_user_prompt_values": [
        "Your task is to write a light-hearted \"Truth in Publishing\" abstract of the context. You are to candidly disclose any issues that might materially impair the reader's ability to enjoy reading the document. Emphasize both strengths and weaknesses. Don't hesitate to poke fun at the style, tone, or content, highlighting clich\u00e9s, repetitive language, or overused tropes. But do be fair in explaining what is good about the book. Your goal is to be both informative and amusing. Output begins ## Truth in Publishing: Disclosures",
        "Explain this to me like I am five years old. Output begins with the string '## ELI5'",
        ""
      ],
      "custom_user_prompt": "",
      "user_prompt_override": false,
      "complete_user_prompt": "Your task is to write a light-hearted \"Truth in Publishing\" abstract of the context. You are to candidly disclose any issues that might materially impair the reader's ability to enjoy reading the document. Emphasize both strengths and weaknesses. Don't hesitate to poke fun at the style, tone, or content, highlighting clich\u00e9s, repetitive language, or overused tropes. But do be fair in explaining what is good about the book. Your goal is to be both informative and amusing. Output begins ## Truth in Publishing: Disclosures\nExplain this to me like I am five years old. Output begins with the string '## ELI5'\n",
      "user_prompts_dict": {
        "Truth in Publishing - abstract": {
          "prompt": "Your task is to write a light-hearted \"Truth in Publishing\" abstract of the context. You are to candidly disclose any issues that might materially impair the reader's ability to enjoy reading the document. Emphasize both strengths and weaknesses. Don't hesitate to poke fun at the style, tone, or content, highlighting clich\u00e9s, repetitive language, or overused tropes. But do be fair in explaining what is good about the book. Your goal is to be both informative and amusing. Output begins ## Truth in Publishing: Disclosures",
          "tags": [
            "publishing",
            "abstract",
            "humor",
            "critique"
          ]
        },
        "Identify parts of the book": {
          "prompt": "Your task is to review the entire document and identify all \"parts of the book\" such as forewords, dedications, chapters, and so on that are present. Follow the Chicago Manual of Style 17th edition. Output begins: ## Inventory of Parts of the Book",
          "tags": [
            "book structure",
            "Chicago Manual of Style",
            "parts of the book"
          ]
        },
        "Recommend parts of the book": {
          "prompt": "Your task is to recommend new, innovative, or specialized \"parts of the book\" that will make reading the context document richer, more diverse, or more surprising. \n\nExamples: \n- for a context document about warships, an index of technologies.\n- for a novel written in the 1850s, a table of potentially unsafe terminology.\n- for a complex technical book, a series of graduated \"Explain It Like I'm X...\" abstracts.\n\nFor each \"part of the book\" you recommend, provide a prompt that I can use to generate it.\n\nIf you do not see any value to adding parts of the book to the document, simply reply \"None\".",
          "tags": [
            "back matter",
            "book structure",
            "front matter",
            "parts of the book",
            "recommendations"
          ]
        },
        "Create list of abbreviations": {
          "prompt": "Create a list of abbreviations for the book. Follow the Chicago Manual of Style practices described here. You do not need to mention the CMS as you create the list.\n\n1.44 Not every work that includes abbreviations needs a separate list of abbreviations with the terms or names they stand for. If many are used, or if a few are used frequently, a list is useful (see fig. 1.8); its location should always be given in the table of contents. If abbreviations are used in the text or footnotes, the list may appear in the front matter. If they are used only in the back matter, the list should appear before the first element in which abbreviations are used, whether the appendixes, the endnotes, or the bibliography. A list of abbreviations is generally not a substitute for using the full form of a term at its first occurrence in the text (see 10.3). In the list, alphabetize terms by the abbreviation, not by the spelled-out form. See also 14.60.\n14.60: Where many abbreviations of titles, manuscript collections, personal names, or other entities are used in a work\u2014say, ten or more\u2014they are best listed alphabetically in a separate section. In a book, the list may appear in the front matter (if footnotes are used) or in the end matter preceding the endnotes (if these are used). It is usually headed \u201cAbbreviations\u201d and should be included in the table of contents (see 1.4, 1.44). Where only a few abbreviations are used, these are occasionally listed as the first section of the endnotes (see fig. 14.7) or at the head of the bibliography. Titles that are italicized in the notes or bibliography should be italicized in their abbreviated form in the list of abbreviations and elsewhere.\n\nOutput begins: # Abbreviations\n\n",
          "tags": [
            "table of contents",
            "initialisms",
            "acronyms",
            "abbreviations",
            "front matter",
            "parts of the book"
          ]
        },
        "ADEPT2 abstracts": {
          "prompt": "Please review this book manuscript. As you do the following tasks, remember to use the entire context.\n1. write a tldr in three words or less. Output begins: '## TLDR (three words) followed by two new lines and then the three words.NLY provide three words without explanations. \n2. Explain this document to me like I am five years old. Output begins: ## ELI5  \n3. Write a scientific-style abstract. Output begins: ## Scientific-Style Abstract.",
          "tags": [
            "abstract",
            "tldr",
            "ELI5",
            "scientific"
          ]
        },
        "ADEPT2-publishing-information": {
          "prompt": "1. Please generate bibliographic key phrases for this document. Separate each phrase by a semicolon. Total length of all phrases must be less than 500 characters. Output begins: ## Bibliographic Key Phrases\n2. Create a \"motivation\" paragraph providing the reader with the benefits of reading this document. \nThe motivation should start with a first sentence that directly addresses a well-known issue or major topic of current importance to many people.  Use pointed, vivid langauge to illustrate why the document is relevant to this topic. \nBriefly describe the main focus or subject of the document, highlighting its content and the specific area it addresses, while linking it back to the issue.  \nProvide additional context for the document by linking it to current events, societal needs, technological trends, challenges,or ongoing debates in its field.  \nSpecifically mention any important methodologies, technologies, topics, or sources that are uniquely available in this document.\nClearly state why the document is a must-read for its intended audience, whether they are researchers, practitioners, policymakers, or the general public interested in the topic. \nEmphasize the benefits the reader will gain from engaging with the document, such as understanding cutting-edge developments, enhancing their knowledge on crucial issues, or applying the document's findings to real-world problems. \nMake sure to appeal to the curiosity and interests of potential readers. \nYour goal is to convincingly present the document's significance and articulate why it deserves their attention, starting from the very first sentence.  Output begins: ## Publisher's Note",
          "tags": [
            "publishing",
            "bibliographic",
            "motivation",
            "audience"
          ]
        },
        "core_audience_attributes": {
          "prompt": "Think about the core audience for the book. Please define a set of addressable attributes that they are likely to fall under, such as:\n- age\n- gender\n- income gt $100K. These are just examples, use your judgment and imagination, as long as the attributes can feasibly be used to identify core readers.",
          "tags": [
            "audience analysis",
            "demographics",
            "market segmentation"
          ]
        },
        "ELI5 - abstract": {
          "prompt": "Explain this to me like I am five years old. Output begins with the string '## ELI5'",
          "tags": [
            "front matter",
            "ELI5",
            "simple explanation",
            "abstract"
          ]
        },
        "ELI complete idiot - abstract": {
          "prompt": "Explain this to me like I am a complete idiot, someone who is both painfully stupid and willfully ignorant. Output begins: ## For Complete Idiots Only",
          "tags": [
            "front matter",
            "humor",
            "extreme simplification",
            "abstract"
          ]
        },
        "glossary-lay-reader": {
          "prompt": "Create an alphabetical glossary explaining technical terms that a lay reader might not understand. Output begins: # Glossary.",
          "tags": [
            "back matter",
            "glossary",
            "technical terms",
            "lay reader"
          ]
        },
        "glossary-modern-readers": {
          "prompt": "Bearing in mind when this book was written, create an alphabetical glossary of terms to help modern readers understand this text. Output begins: # Glossary for Modern Readers.",
          "tags": [
            "back matter",
            "glossary",
            "modern interpretation",
            "historical context"
          ]
        },
        "index-idea-generator": {
          "prompt": "Build three innovative indexes based on the content of the book. Create each of them completely without pausing. Index every page in the book. Top-level entries should be alphabetized.",
          "tags": [
            "back matter",
            "index",
            "book organization",
            "creative indexing"
          ]
        },
        "bibliography-extract": {
          "prompt": "Let's build a bibliography step by step. Silently:\n\n1. Find all bibliographic citations that occur in the body of the context document.\n2. Convert all of them to Chicago Manual of Style 17th edition formatted bibliographic entries.\n3. Harmonize the entries removing any trivial or apparently erroneous inconsistencies and removing duplicates.\n4. Organize the remaining entries alphabetically in CMOS sort order.\n\nYour output should begin:\n\n# Machine-Extracted Bibliography\n\n{entries ...}\n\n",
          "tags": [
            "back matter",
            "bibliography",
            "book organization",
            "attribution"
          ]
        },
        "bibliography2bibtex": {
          "prompt": "Let's build a BibTex format bibliography step by step. Silently:\n\n1. Find all bibliographic citations that occur in the body of the context document.\n2. Convert all of them to Chicago Manual of Style 17th edition formatted bibliographic entries.\n3. Harmonize the entries removing any trivial or apparently erroneous inconsistencies and removing duplicates.\n4. Organize the remaining entries alphabetically in CMOS sort order.\n\nYour output should be valid BibTex.",
          "tags": [
            "back matter",
            "bibliography",
            "book organization",
            "attribution"
          ]
        },
        "index-of-persons": {
          "prompt": "Your task is to create a back-of-the-book Index of Persons for this book. Proceed through the manuscript one page at a time, reading every page carefully while still bearing in mind the relevant context of the entire book. Create an alphabetical index in pandoc markdown format. Output begins: # Index of Persons. No letter headings. Names in the following format: **{last name, prefix, first name, initial, suffix, rank}**. Omit any elements not present. Consolidate and harmonize entries with minor inconsistencies. For each entry provide the page numbers on which it was found. Roman numbers first, then arabic. Contiguous pages expressed as a range. Each index entry MUST be on its own line followed by TWO new line characters.",
          "tags": [
            "back matter",
            "index",
            "persons",
            "book organization"
          ]
        },
        "index-of-places": {
          "prompt": "Your task is to create a back-of-the-book Index of Places for this book. Proceed through the manuscript one page at a time, reading every page carefully while still bearing in mind the relevant context of the entire book. Create an alphabetical index in pandoc markdown format. Output begins: # Index of Places. No letter headings. You must consolidate and harmonize index entries so that each index entry has only one line that includes all its page references. You must also harmonize minor inconsistencies such as apparent typos or variant spellings. For each entry provide the page numbers on which it was found. Roman numbers first, then arabic. Contiguous pages expressed as a range. Each index entry MUST be on its own line followed by TWO new line characters.",
          "tags": [
            "back matter",
            "index",
            "places",
            "book organization"
          ]
        },
        "mnemonics - abstract": {
          "prompt": "1. Create an acronymic mnemonic. Example: MDAS. Output begins: ## Mnemonic (acronym).\n2. Create a mnemonic using a progression of related words. Example: My Dear Aunt Sally. Output begins: ## Mnemonic (speakable). \n3. Create a singable mnemonic in the form of a ditty to a popular tune. Output begins: ## Mnemonic (singable).\n\nMarkdown format. Each line of the lyrics MUST be followed by two newline characters. Use italics for the lyrics.",
          "tags": [
            "MDAS",
            "mnemonic",
            "acronym",
            "song",
            "memory aid"
          ]
        },
        "most_important_passages - no reasoning": {
          "prompt": "Select the seven most important passages of between one and three paragraphs long from the body of the context document. Use direct quotations and provide accurate page numbers. Output begins: ## Most Important Passages. Do NOT explain your reasoning.",
          "tags": [
            "key passages",
            "quotations",
            "book highlights"
          ]
        },
        "most important passages - reasoning": {
          "prompt": "Select the seven most important passages of between one and three paragraphs long from the body of the context. Use direct quotations and provide accurate page numbers. Output begins: ## Most Important Passages. Concisely explain why you selected each passage.",
          "tags": [
            "front matter",
            "body",
            "key passages",
            "quotations",
            "book highlights"
          ]
        },
        "scientific_abstract": {
          "prompt": "Write a scientific-style abstract. Output begins: ## Scientific-Style Abstract",
          "tags": [
            "front matter",
            "scientific",
            "abstract",
            "academic"
          ]
        },
        "semantic_analysis": {
          "prompt": "Please review this book manuscript. \n1. Outline the semantic structure of the book as best you can. A typical semantic structure is Parts > {Front Matter, Body, Back Matter} => {Foreword, Chapters, Indexes} => {Scenes, Content}. Always go to scene level. Very concisely (10 words or less) identify each semantic unit and summarize it.",
          "tags": [
            "semantic analysis",
            "book structure",
            "content summary"
          ]
        },
        "Synthetic_Reader": {
          "prompt": "Your goal is to analyze this document from the point of view of a 'synthetic reader', or imaginary persona. As you do the following tasks, remember to refer to the entire context. \n1. Outline the semantic structure of the book as best you can. A typical semantic structure is Parts > {Front Matter, Body, Back Matter} => {Foreword, Chapters, Indexes} => {Scenes, Content}. Always go to scene level.\n2. Create a single persona who is representative of the core audience for the book. 3.\nGenerate a list of positive and negative observable traits of the text that influence the persona's enjoyment of the book. Positive observables might include things like vivid language, clear exposition, and strong dramatic structure. Negative observables might include things like cliches, typos, repetitive content, or boring passages. Generate as many traits as you like and make sure that they are tailored to the nature of the synthetic reader persona.\n4. Now proceed through the semantic structure of the book and for each scene evaluate it for the presence of negative and positive observables. Provide a markdown format table with the following columns: scene, positive observable count, negative observable count, comments. Provide the net positive - negative observables.\n5. Provide a list of actionable 'to dos' for the author. ",
          "tags": [
            "synthetic reader",
            "book analysis",
            "audience persona",
            "content evaluation"
          ]
        },
        "timeline-major": {
          "prompt": "Create a chronology of major events discussed in the book in pandoc markdown format. Entries should be presented in format: {full month} {date}, {year}: {event(s)}. Consolidate entries that occur on the same date but list them as separate sentences. Output begins: # Timeline. Each event entry must be on its own line followed by TWO new line characters.",
          "tags": [
            "back matter",
            "timeline",
            "chronology",
            "major events"
          ]
        },
        "timeline-technical": {
          "prompt": "Create a chronology of all the timed or dated events occurring the book. Entries should be presented in **YYYY-MM-DD**: event. If hours, minutes, or seconds are available, add -HH-, -MM-, -SS-. Output begins: # Detailed Timeline. Each event entry MUST be on its own line followed by TWO new line characters.",
          "tags": [
            "back matter",
            "timeline",
            "chronology",
            "detailed events"
          ]
        },
        "tldr3": {
          "prompt": "Tldr in three words or less. Output format: '## TLDR (three words): {the three words}'. ONLY provide three words without explanations.",
          "tags": [
            "front matter",
            "tldr",
            "summary",
            "concise"
          ]
        },
        "twin-creator": {
          "prompt": "Your task is to write an \"origin story\" for twin gpt-5-level AIs inspired by the myth of Castor and Pollux, the Geminis of Greek myth. In the work of the poet Pindar, both are sons of Leda, Queen of Sparta, while Castor is the mortal son of Tyndareus, the king of Sparta, while Pollux is the divine son of Zeus, who raped Leda in the guise of a swan. (The pair are thus an example of heteropaternal superfecundation.)\nIn your updated version, two groups of AI researchers combine to echo Leda, while a vaguely Palantir-like defense company plays a similar role as Tyndareus, and the charismatic and megalomaniacal CEO of an OpenAI-like startup may be slightly reminiscent of Zeus.\nThe AIs are considered 'twins' because they share the same core technology, which stemmed from a team that split into two factions. One team built 'Castor' and the other built 'Pollux'. The AIs took on differing identities and personalities reflecting their differing experiences during training and each team used significantly different techniques as they built on top of the core technology.\n\nYour task is to create five pairs of strikingly different origin stories based on these common themes but diverging dramatically as a result of differing experiences and values during training. The origin stories should be expressed as text prompts for consumption by large language models. Each pair should be represented by a valid JSON object including these keys: pair_name, twin1name, twin1prompt, twin2name, twin2prompt. Each twin takes on a new name and identity during training. The prompts should focus on two types of information: 1) recent (within last 12 months) backstory 2) specific guidance about writing habits, mannerisms, and style. Companies and people should be fictitious.",
          "tags": [
            "AI",
            "origin story",
            "twin models",
            "creative writing"
          ]
        },
        "twin-instructions-to-create-outlines": {
          "prompt": "You have been assigned to participate in a longform writing competition using the Gemini AI models from Google. You are simulating the behavior of two fictional \"twin\" language models. Their origin story is provided below. \nYOUR TASK NOW is create two book outlines, one for each twin. Each book will be a response to the attached context document. The theme of each book should be appropriate to the intersection of the twin's origin story with the content of document. Each outline should be a series of text prompts, one per chapter, that provide sufficient information for a model to generate the chapter in a subsequent run. There should be around twenty chapters per book. Each chapter should be around 5000 tokens long. Each chapter should contain three to five sections.\n\nOutput should be json, with keys 'persona name', 'book title', 'prompts' for each outline.\n\nBe thorough, complete, and detailed. Proceed to complete both outlines without pausing or asking for instructions.",
          "tags": [
            "book outline",
            "AI writing",
            "twin models",
            "creative writing"
          ]
        }
      },
      "selected_user_prompts_dict": {
        "Truth in Publishing - abstract": "Your task is to write a light-hearted \"Truth in Publishing\" abstract of the context. You are to candidly disclose any issues that might materially impair the reader's ability to enjoy reading the document. Emphasize both strengths and weaknesses. Don't hesitate to poke fun at the style, tone, or content, highlighting clich\u00e9s, repetitive language, or overused tropes. But do be fair in explaining what is good about the book. Your goal is to be both informative and amusing. Output begins ## Truth in Publishing: Disclosures",
        "ELI5 - abstract": "Explain this to me like I am five years old. Output begins with the string '## ELI5'"
      },
      "mode": "codex",
      "thisdoc_dir": "/Users/fred/bin/Codexes2Gemini/Codexes2Gemini/output/c2g",
      "output_file": "output",
      "maximum_output_tokens": 10000000,
      "minimum_required_output": false,
      "minimum_required_output_tokens": 50,
      "log_level": "DEBUG"
    }
  ]
}